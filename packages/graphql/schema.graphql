# Custom scalar types
scalar JSON
scalar DateTime

type Runbook {
  id: ID!
  name: String!
  version: String!
  dag: JSON!
  createdAt: DateTime!
}

enum RunState {
  QUEUED
  LEASED
  RUNNING
  SUCCEEDED
  FAILED
  TIMED_OUT
  ABORTED
}

type Run {
  id: ID!
  runbookId: ID!
  tenantId: String!
  state: RunState!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type NarrativeMetric {
  timestamp: DateTime!
  rt: Float
  velocity: Float
  eliteUptake: Int
  communityPenetration: Float
}

type NarrativeRiskProfile {
  narrativeId: ID!
  currentRt: Float
  riskScore: Float
  velocity: Float
  eliteUptake: Int
  communityPenetration: Float
  history(limit: Int): [NarrativeMetric!]!
}

type Watchlist {
  id: ID!
  name: String!
  ownerId: ID!
  items: [String!]!
  alertConfig: AlertConfig
}

type AlertConfig {
  rtThreshold: Float
  riskScoreThreshold: Float
  notifyChannels: [String!]
}

type AlertEvent {
  narrativeId: ID!
  type: String!
  value: Float!
  timestamp: DateTime!
}

type Query {
  runbooks(limit: Int = 50, after: ID): [Runbook!]!
  run(id: ID!): Run
  narrativesNearTippingPoint(limit: Int, minRt: Float): [NarrativeRiskProfile!]!
  myWatchlists: [Watchlist!]!
}

input AlertConfigInput {
  rtThreshold: Float
  riskScoreThreshold: Float
  notifyChannels: [String!]
}

input CreateWatchlistInput {
  name: String!
  narrativeIds: [ID!]
  alertConfig: AlertConfigInput
}

input LaunchRunInput {
  runbookId: ID!
  tenantId: String!
  params: JSON
}
type Mutation {
  launchRun(input: LaunchRunInput!): Run!
  abortRun(id: ID!): Run!
  createWatchlist(input: CreateWatchlistInput!): Watchlist!
  addToWatchlist(watchlistId: ID!, narrativeId: ID!): Watchlist!
  setNarrativeAlertConfig(narrativeId: ID!, config: AlertConfigInput): String!
}

type Subscription {
  onNarrativeAlert(watchlistId: ID): AlertEvent!
}
