/**
 * Alert Schemas
 *
 * Defines the structure of alerts generated by the signal processing pipeline.
 * Alerts are the primary output of the rule engine when conditions are met.
 *
 * @module alert
 */

import { z } from 'zod';

import type { SignalEnvelope } from './signal-envelope.js';

/**
 * Alert severity levels
 */
export const AlertSeverity = {
  INFO: 'info',
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  CRITICAL: 'critical',
} as const;

export type AlertSeverityType = (typeof AlertSeverity)[keyof typeof AlertSeverity];

/**
 * Alert status lifecycle
 */
export const AlertStatus = {
  NEW: 'new',
  ACKNOWLEDGED: 'acknowledged',
  IN_PROGRESS: 'in_progress',
  RESOLVED: 'resolved',
  SUPPRESSED: 'suppressed',
  FALSE_POSITIVE: 'false_positive',
  ESCALATED: 'escalated',
} as const;

export type AlertStatusType = (typeof AlertStatus)[keyof typeof AlertStatus];

/**
 * Alert type categories
 */
export const AlertType = {
  THRESHOLD: 'threshold',
  PATTERN: 'pattern',
  ANOMALY: 'anomaly',
  CORRELATION: 'correlation',
  TEMPORAL: 'temporal',
  ABSENCE: 'absence',
  RATE: 'rate',
} as const;

export type AlertTypeType = (typeof AlertType)[keyof typeof AlertType];

/**
 * Reference to a signal that triggered the alert
 */
export const SignalReferenceSchema = z.object({
  /** Signal ID */
  signalId: z.string().uuid(),

  /** Signal type */
  signalType: z.string(),

  /** Timestamp of the signal */
  timestamp: z.number(),

  /** Relevance score (0-1) for this signal in the alert */
  relevance: z.number().min(0).max(1).default(1),

  /** Key fields from the signal payload */
  keyFields: z.record(z.string(), z.unknown()).optional(),
});

export type SignalReference = z.infer<typeof SignalReferenceSchema>;

/**
 * Rule that triggered the alert
 */
export const TriggeringRuleSchema = z.object({
  /** Rule ID */
  ruleId: z.string(),

  /** Rule name */
  ruleName: z.string(),

  /** Rule version */
  ruleVersion: z.string(),

  /** Condition that was matched */
  matchedCondition: z.string(),

  /** Threshold or pattern that triggered */
  triggerValue: z.unknown().optional(),

  /** Actual value that caused the trigger */
  actualValue: z.unknown().optional(),

  /** Confidence score for pattern/anomaly matches */
  confidence: z.number().min(0).max(1).optional(),
});

export type TriggeringRule = z.infer<typeof TriggeringRuleSchema>;

/**
 * Alert context with additional metadata
 */
export const AlertContextSchema = z.object({
  /** Investigation ID if part of an active investigation */
  investigationId: z.string().optional(),

  /** Case ID if assigned to a case */
  caseId: z.string().optional(),

  /** Entity IDs related to this alert */
  relatedEntities: z.array(z.string()).default([]),

  /** Previous related alerts */
  relatedAlerts: z.array(z.string()).default([]),

  /** Geographic context */
  location: z
    .object({
      latitude: z.number(),
      longitude: z.number(),
      placeName: z.string().optional(),
      country: z.string().optional(),
    })
    .optional(),

  /** Time window context */
  timeWindow: z
    .object({
      start: z.number(),
      end: z.number(),
      windowType: z.enum(['tumbling', 'sliding', 'session']),
      windowSize: z.number(),
    })
    .optional(),

  /** Custom context fields */
  custom: z.record(z.string(), z.unknown()).optional(),
});

export type AlertContext = z.infer<typeof AlertContextSchema>;

/**
 * Alert actions and recommendations
 */
export const AlertActionSchema = z.object({
  /** Action type */
  actionType: z.enum([
    'investigate',
    'acknowledge',
    'escalate',
    'notify',
    'automate',
    'suppress',
  ]),

  /** Action description */
  description: z.string(),

  /** Priority of the action */
  priority: z.number().min(1).max(10).default(5),

  /** Automation script/workflow ID */
  automationId: z.string().optional(),

  /** Target for notification */
  notificationTarget: z.string().optional(),
});

export type AlertAction = z.infer<typeof AlertActionSchema>;

/**
 * Complete Alert schema
 */
export const AlertSchema = z.object({
  /** Unique alert identifier */
  alertId: z.string().uuid(),

  /** Alert type */
  alertType: z.enum([
    AlertType.THRESHOLD,
    AlertType.PATTERN,
    AlertType.ANOMALY,
    AlertType.CORRELATION,
    AlertType.TEMPORAL,
    AlertType.ABSENCE,
    AlertType.RATE,
  ]),

  /** Alert severity */
  severity: z.enum([
    AlertSeverity.INFO,
    AlertSeverity.LOW,
    AlertSeverity.MEDIUM,
    AlertSeverity.HIGH,
    AlertSeverity.CRITICAL,
  ]),

  /** Alert status */
  status: z
    .enum([
      AlertStatus.NEW,
      AlertStatus.ACKNOWLEDGED,
      AlertStatus.IN_PROGRESS,
      AlertStatus.RESOLVED,
      AlertStatus.SUPPRESSED,
      AlertStatus.FALSE_POSITIVE,
      AlertStatus.ESCALATED,
    ])
    .default(AlertStatus.NEW),

  /** Tenant ID for multi-tenancy */
  tenantId: z.string().min(1),

  /** Alert title */
  title: z.string().min(1).max(200),

  /** Detailed description */
  description: z.string().max(4000),

  /** Unix timestamp when alert was created */
  createdAt: z.number(),

  /** Unix timestamp when alert was last updated */
  updatedAt: z.number(),

  /** Unix timestamp when alert expires (optional) */
  expiresAt: z.number().optional(),

  /** Rule that triggered this alert */
  triggeringRule: TriggeringRuleSchema,

  /** References to signals that contributed to this alert */
  signalReferences: z.array(SignalReferenceSchema).min(1),

  /** Alert context */
  context: AlertContextSchema.default({
    relatedEntities: [],
    relatedAlerts: [],
  }),

  /** Recommended actions */
  recommendedActions: z.array(AlertActionSchema).default([]),

  /** Policy labels for access control */
  policyLabels: z.array(z.string()).default([]),

  /** Classification level */
  classification: z.string().optional(),

  /** Tags for categorization */
  tags: z.array(z.string()).default([]),

  /** Suppression info if suppressed */
  suppression: z
    .object({
      suppressedAt: z.number(),
      suppressedBy: z.string(),
      reason: z.string(),
      expiresAt: z.number().optional(),
    })
    .optional(),

  /** Acknowledgment info */
  acknowledgment: z
    .object({
      acknowledgedAt: z.number(),
      acknowledgedBy: z.string(),
      notes: z.string().optional(),
    })
    .optional(),

  /** Resolution info */
  resolution: z
    .object({
      resolvedAt: z.number(),
      resolvedBy: z.string(),
      resolutionType: z.enum([
        'fixed',
        'false_positive',
        'no_action_needed',
        'other',
      ]),
      notes: z.string().optional(),
    })
    .optional(),

  /** Schema version */
  schemaVersion: z.string().default('1.0.0'),
});

export type Alert = z.infer<typeof AlertSchema>;

/**
 * Alert creation input (subset of full alert)
 */
export const CreateAlertInputSchema = z.object({
  alertType: AlertSchema.shape.alertType,
  severity: AlertSchema.shape.severity,
  tenantId: z.string().min(1),
  title: z.string().min(1).max(200),
  description: z.string().max(4000),
  triggeringRule: TriggeringRuleSchema,
  signalReferences: z.array(SignalReferenceSchema).min(1),
  context: AlertContextSchema.optional(),
  recommendedActions: z.array(AlertActionSchema).optional(),
  policyLabels: z.array(z.string()).optional(),
  classification: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

export type CreateAlertInput = z.infer<typeof CreateAlertInputSchema>;

/**
 * Alert update input
 */
export const UpdateAlertInputSchema = z.object({
  status: AlertSchema.shape.status.optional(),
  severity: AlertSchema.shape.severity.optional(),
  tags: z.array(z.string()).optional(),
  context: AlertContextSchema.partial().optional(),
  acknowledgment: AlertSchema.shape.acknowledgment.optional(),
  resolution: AlertSchema.shape.resolution.optional(),
  suppression: AlertSchema.shape.suppression.optional(),
});

export type UpdateAlertInput = z.infer<typeof UpdateAlertInputSchema>;

/**
 * Create a new alert
 */
export function createAlert(input: CreateAlertInput): Alert {
  const now = Date.now();

  return {
    alertId: crypto.randomUUID(),
    alertType: input.alertType,
    severity: input.severity,
    status: AlertStatus.NEW,
    tenantId: input.tenantId,
    title: input.title,
    description: input.description,
    createdAt: now,
    updatedAt: now,
    triggeringRule: input.triggeringRule,
    signalReferences: input.signalReferences,
    context: input.context ?? { relatedEntities: [], relatedAlerts: [] },
    recommendedActions: input.recommendedActions ?? [],
    policyLabels: input.policyLabels ?? [],
    classification: input.classification,
    tags: input.tags ?? [],
    schemaVersion: '1.0.0',
  };
}

/**
 * Create alert from signal envelope and rule match
 */
export function createAlertFromSignal(
  envelope: SignalEnvelope,
  ruleMatch: {
    ruleId: string;
    ruleName: string;
    ruleVersion: string;
    condition: string;
    alertType: AlertTypeType;
    severity: AlertSeverityType;
    title: string;
    description: string;
    triggerValue?: unknown;
    actualValue?: unknown;
    confidence?: number;
  },
): Alert {
  const now = Date.now();

  return {
    alertId: crypto.randomUUID(),
    alertType: ruleMatch.alertType,
    severity: ruleMatch.severity,
    status: AlertStatus.NEW,
    tenantId: envelope.metadata.tenantId,
    title: ruleMatch.title,
    description: ruleMatch.description,
    createdAt: now,
    updatedAt: now,
    triggeringRule: {
      ruleId: ruleMatch.ruleId,
      ruleName: ruleMatch.ruleName,
      ruleVersion: ruleMatch.ruleVersion,
      matchedCondition: ruleMatch.condition,
      triggerValue: ruleMatch.triggerValue,
      actualValue: ruleMatch.actualValue,
      confidence: ruleMatch.confidence,
    },
    signalReferences: [
      {
        signalId: envelope.metadata.signalId,
        signalType: envelope.metadata.signalType,
        timestamp: envelope.metadata.timestamp,
        relevance: 1,
      },
    ],
    context: {
      relatedEntities: [],
      relatedAlerts: [],
      location: envelope.location
        ? {
            latitude: envelope.location.latitude,
            longitude: envelope.location.longitude,
          }
        : undefined,
    },
    recommendedActions: [],
    policyLabels: envelope.metadata.policyLabels,
    classification: envelope.metadata.classification,
    tags: envelope.metadata.tags,
    schemaVersion: '1.0.0',
  };
}

/**
 * Validate an alert
 */
export function validateAlert(input: unknown): z.SafeParseReturnType<unknown, Alert> {
  return AlertSchema.safeParse(input);
}

/**
 * Check if alert should be suppressed based on deduplication window
 */
export function shouldSuppressAlert(
  newAlert: Alert,
  existingAlerts: Alert[],
  deduplicationWindowMs: number = 300000, // 5 minutes default
): boolean {
  const cutoff = newAlert.createdAt - deduplicationWindowMs;

  return existingAlerts.some(
    (existing) =>
      existing.triggeringRule.ruleId === newAlert.triggeringRule.ruleId &&
      existing.tenantId === newAlert.tenantId &&
      existing.createdAt > cutoff &&
      existing.status !== AlertStatus.RESOLVED &&
      existing.status !== AlertStatus.FALSE_POSITIVE,
  );
}

/**
 * Calculate alert priority score for ordering
 */
export function calculateAlertPriority(alert: Alert): number {
  const severityScores: Record<AlertSeverityType, number> = {
    [AlertSeverity.INFO]: 1,
    [AlertSeverity.LOW]: 2,
    [AlertSeverity.MEDIUM]: 3,
    [AlertSeverity.HIGH]: 4,
    [AlertSeverity.CRITICAL]: 5,
  };

  const typeMultipliers: Record<AlertTypeType, number> = {
    [AlertType.THRESHOLD]: 1.0,
    [AlertType.PATTERN]: 1.2,
    [AlertType.ANOMALY]: 1.3,
    [AlertType.CORRELATION]: 1.5,
    [AlertType.TEMPORAL]: 1.1,
    [AlertType.ABSENCE]: 1.0,
    [AlertType.RATE]: 1.1,
  };

  const severityScore = severityScores[alert.severity] ?? 3;
  const typeMultiplier = typeMultipliers[alert.alertType] ?? 1.0;
  const signalCount = Math.min(alert.signalReferences.length, 10);
  const confidence = alert.triggeringRule.confidence ?? 1.0;

  return severityScore * typeMultiplier * (1 + signalCount * 0.1) * confidence;
}
