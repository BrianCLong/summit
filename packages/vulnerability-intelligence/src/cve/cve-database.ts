import {
  CVE,
  CVSSSeverity,
  Vulnerability,
  ExploitAvailability,
  VulnerabilityRiskAssessment,
  RiskFactor
} from '../types';

/**
 * CVE Database Manager
 */
export class CVEDatabase {
  private cves: Map<string, CVE> = new Map();
  private vulnerabilities: Map<string, Vulnerability> = new Map();

  /**
   * Add CVE to database
   */
  addCVE(cve: CVE): void {
    this.cves.set(cve.id, cve);
  }

  /**
   * Get CVE by ID
   */
  getCVE(id: string): CVE | undefined {
    return this.cves.get(id);
  }

  /**
   * Search CVEs
   */
  searchCVEs(query: {
    keyword?: string;
    severity?: CVSSSeverity;
    vendor?: string;
    product?: string;
    dateFrom?: Date;
    dateTo?: Date;
  }): CVE[] {
    let results = Array.from(this.cves.values());

    if (query.keyword) {
      const keyword = query.keyword.toLowerCase();
      results = results.filter(
        cve =>
          cve.description.toLowerCase().includes(keyword) ||
          cve.id.toLowerCase().includes(keyword)
      );
    }

    if (query.severity) {
      results = results.filter(cve => cve.severity === query.severity);
    }

    if (query.vendor) {
      const vendor = query.vendor.toLowerCase();
      results = results.filter(cve =>
        cve.affectedProducts?.some(p => p.vendor.toLowerCase().includes(vendor))
      );
    }

    if (query.product) {
      const product = query.product.toLowerCase();
      results = results.filter(cve =>
        cve.affectedProducts?.some(p => p.product.toLowerCase().includes(product))
      );
    }

    if (query.dateFrom) {
      results = results.filter(cve => cve.publishedDate >= query.dateFrom!);
    }

    if (query.dateTo) {
      results = results.filter(cve => cve.publishedDate <= query.dateTo!);
    }

    return results;
  }

  /**
   * Get CVEs by severity
   */
  getCVEsBySeverity(severity: CVSSSeverity): CVE[] {
    return Array.from(this.cves.values()).filter(cve => cve.severity === severity);
  }

  /**
   * Get recent CVEs
   */
  getRecentCVEs(days: number = 7): CVE[] {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - days);

    return Array.from(this.cves.values())
      .filter(cve => cve.publishedDate >= cutoff)
      .sort((a, b) => b.publishedDate.getTime() - a.publishedDate.getTime());
  }

  /**
   * Calculate CVSS severity from score
   */
  static calculateSeverity(score: number): CVSSSeverity {
    if (score === 0) return CVSSSeverity.NONE;
    if (score < 4.0) return CVSSSeverity.LOW;
    if (score < 7.0) return CVSSSeverity.MEDIUM;
    if (score < 9.0) return CVSSSeverity.HIGH;
    return CVSSSeverity.CRITICAL;
  }

  /**
   * Parse CVSS v3 vector
   */
  static parseCVSSVector(vector: string): Record<string, string> {
    const components: Record<string, string> = {};
    const parts = vector.replace('CVSS:3.1/', '').replace('CVSS:3.0/', '').split('/');

    for (const part of parts) {
      const [key, value] = part.split(':');
      if (key && value) {
        components[key] = value;
      }
    }

    return components;
  }

  /**
   * Get statistics
   */
  getStatistics(): {
    total: number;
    bySeverity: Record<CVSSSeverity, number>;
    thisWeek: number;
    thisMonth: number;
  } {
    const cves = Array.from(this.cves.values());
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const bySeverity: Record<CVSSSeverity, number> = {
      [CVSSSeverity.NONE]: 0,
      [CVSSSeverity.LOW]: 0,
      [CVSSSeverity.MEDIUM]: 0,
      [CVSSSeverity.HIGH]: 0,
      [CVSSSeverity.CRITICAL]: 0
    };

    for (const cve of cves) {
      bySeverity[cve.severity]++;
    }

    return {
      total: cves.length,
      bySeverity,
      thisWeek: cves.filter(c => c.publishedDate >= weekAgo).length,
      thisMonth: cves.filter(c => c.publishedDate >= monthAgo).length
    };
  }
}

/**
 * Vulnerability Risk Calculator
 */
export class VulnerabilityRiskCalculator {
  /**
   * Calculate risk assessment
   */
  calculateRisk(
    vulnerability: Vulnerability,
    assetCriticality: 'low' | 'medium' | 'high' | 'critical',
    networkExposure: 'internal' | 'limited' | 'public'
  ): VulnerabilityRiskAssessment {
    const baseScore = vulnerability.cvssScore;

    // Calculate temporal score based on exploit availability
    const temporalMultiplier = this.getTemporalMultiplier(vulnerability.exploitAvailability);
    const temporalScore = baseScore * temporalMultiplier;

    // Calculate environmental score
    const environmentalMultiplier = this.getEnvironmentalMultiplier(assetCriticality, networkExposure);
    const environmentalScore = baseScore * environmentalMultiplier;

    // Overall risk score
    const overallRiskScore = (baseScore + temporalScore + environmentalScore) / 3;

    // Calculate exploitability and impact
    const exploitabilityScore = this.calculateExploitability(vulnerability);
    const impactScore = this.calculateImpact(vulnerability);

    // Determine factors
    const factors = this.identifyRiskFactors(vulnerability, assetCriticality, networkExposure);

    // Generate recommendations
    const recommendations = this.generateRecommendations(vulnerability, factors);

    // Determine priority
    const priority = this.determinePriority(overallRiskScore, vulnerability.exploitAvailability);

    // Estimate remediation time
    const estimatedRemediation = this.estimateRemediationTime(vulnerability);

    return {
      vulnerabilityId: vulnerability.id,
      baseScore,
      temporalScore,
      environmentalScore,
      overallRiskScore,
      exploitabilityScore,
      impactScore,
      factors,
      recommendations,
      priority,
      estimatedRemediation
    };
  }

  /**
   * Prioritize vulnerabilities
   */
  prioritizeVulnerabilities(
    vulnerabilities: Vulnerability[],
    assetCriticality: 'low' | 'medium' | 'high' | 'critical' = 'medium',
    networkExposure: 'internal' | 'limited' | 'public' = 'limited'
  ): VulnerabilityRiskAssessment[] {
    const assessments = vulnerabilities.map(v =>
      this.calculateRisk(v, assetCriticality, networkExposure)
    );

    return assessments.sort((a, b) => b.overallRiskScore - a.overallRiskScore);
  }

  private getTemporalMultiplier(exploitAvailability: ExploitAvailability): number {
    const multipliers: Record<ExploitAvailability, number> = {
      [ExploitAvailability.NOT_AVAILABLE]: 0.85,
      [ExploitAvailability.POC_AVAILABLE]: 0.94,
      [ExploitAvailability.FUNCTIONAL_EXPLOIT]: 0.97,
      [ExploitAvailability.WEAPONIZED]: 1.0,
      [ExploitAvailability.IN_THE_WILD]: 1.0
    };
    return multipliers[exploitAvailability];
  }

  private getEnvironmentalMultiplier(
    assetCriticality: string,
    networkExposure: string
  ): number {
    const criticalityMultiplier: Record<string, number> = {
      'low': 0.5,
      'medium': 0.75,
      'high': 1.0,
      'critical': 1.25
    };

    const exposureMultiplier: Record<string, number> = {
      'internal': 0.7,
      'limited': 0.85,
      'public': 1.0
    };

    return (criticalityMultiplier[assetCriticality] || 1) *
           (exposureMultiplier[networkExposure] || 1);
  }

  private calculateExploitability(vulnerability: Vulnerability): number {
    let score = 5;

    if (vulnerability.exploitAvailability === ExploitAvailability.IN_THE_WILD) {
      score = 10;
    } else if (vulnerability.exploitAvailability === ExploitAvailability.WEAPONIZED) {
      score = 9;
    } else if (vulnerability.exploitAvailability === ExploitAvailability.FUNCTIONAL_EXPLOIT) {
      score = 7;
    } else if (vulnerability.exploitAvailability === ExploitAvailability.POC_AVAILABLE) {
      score = 5;
    } else {
      score = 2;
    }

    return score;
  }

  private calculateImpact(vulnerability: Vulnerability): number {
    // Base impact on CVSS score
    return vulnerability.cvssScore * 0.9;
  }

  private identifyRiskFactors(
    vulnerability: Vulnerability,
    assetCriticality: string,
    networkExposure: string
  ): RiskFactor[] {
    const factors: RiskFactor[] = [];

    factors.push({
      name: 'Base CVSS Score',
      weight: 0.3,
      value: vulnerability.cvssScore,
      description: `Base vulnerability severity: ${vulnerability.severity}`
    });

    factors.push({
      name: 'Exploit Availability',
      weight: 0.25,
      value: this.getExploitValue(vulnerability.exploitAvailability),
      description: `Exploit status: ${vulnerability.exploitAvailability}`
    });

    factors.push({
      name: 'Asset Criticality',
      weight: 0.25,
      value: this.getCriticalityValue(assetCriticality),
      description: `Asset criticality: ${assetCriticality}`
    });

    factors.push({
      name: 'Network Exposure',
      weight: 0.2,
      value: this.getExposureValue(networkExposure),
      description: `Network exposure: ${networkExposure}`
    });

    return factors;
  }

  private getExploitValue(availability: ExploitAvailability): number {
    const values: Record<ExploitAvailability, number> = {
      [ExploitAvailability.NOT_AVAILABLE]: 2,
      [ExploitAvailability.POC_AVAILABLE]: 5,
      [ExploitAvailability.FUNCTIONAL_EXPLOIT]: 7,
      [ExploitAvailability.WEAPONIZED]: 9,
      [ExploitAvailability.IN_THE_WILD]: 10
    };
    return values[availability];
  }

  private getCriticalityValue(criticality: string): number {
    const values: Record<string, number> = {
      'low': 2,
      'medium': 5,
      'high': 8,
      'critical': 10
    };
    return values[criticality] || 5;
  }

  private getExposureValue(exposure: string): number {
    const values: Record<string, number> = {
      'internal': 3,
      'limited': 6,
      'public': 10
    };
    return values[exposure] || 6;
  }

  private generateRecommendations(
    vulnerability: Vulnerability,
    factors: RiskFactor[]
  ): string[] {
    const recommendations: string[] = [];

    if (vulnerability.patches.length > 0) {
      recommendations.push(`Apply patch: ${vulnerability.patches[0].version}`);
    }

    if (vulnerability.mitigations.length > 0) {
      recommendations.push(`Implement mitigation: ${vulnerability.mitigations[0].description}`);
    }

    if (vulnerability.exploitAvailability === ExploitAvailability.IN_THE_WILD) {
      recommendations.push('URGENT: Active exploitation detected - prioritize immediate remediation');
    }

    if (vulnerability.severity === CVSSSeverity.CRITICAL) {
      recommendations.push('Isolate affected systems until patch can be applied');
    }

    if (recommendations.length === 0) {
      recommendations.push('Monitor for vendor patch availability');
      recommendations.push('Review network segmentation for affected assets');
    }

    return recommendations;
  }

  private determinePriority(
    riskScore: number,
    exploitAvailability: ExploitAvailability
  ): 'critical' | 'high' | 'medium' | 'low' {
    if (riskScore >= 9 || exploitAvailability === ExploitAvailability.IN_THE_WILD) {
      return 'critical';
    }
    if (riskScore >= 7 || exploitAvailability === ExploitAvailability.WEAPONIZED) {
      return 'high';
    }
    if (riskScore >= 4) {
      return 'medium';
    }
    return 'low';
  }

  private estimateRemediationTime(vulnerability: Vulnerability): number {
    let hours = 2; // Base time

    if (vulnerability.patches.length > 0) {
      hours += 1; // Patch application
    } else {
      hours += 4; // Workaround implementation
    }

    if (vulnerability.severity === CVSSSeverity.CRITICAL) {
      hours += 2; // Extra testing
    }

    return hours;
  }
}
