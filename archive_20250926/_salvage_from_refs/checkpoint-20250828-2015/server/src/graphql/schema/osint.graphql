# OSINT schema (MVP-1)

type OsintSource {
  id: ID!
  name: String!
  kind: OsintSourceKind!
  url: String!
  license: LicenseRef!
  rateLimitPerMin: Int!
  enabled: Boolean!
  lastRunAt: DateTime
  tags: [String!]!
}

enum OsintSourceKind { RSS JSON_API TAXII GDELT ACLED WIKIDATA CUSTOM }

input CreateOsintSourceInput {
  name: String!
  kind: OsintSourceKind!
  url: String!
  licenseId: ID!
  rateLimitPerMin: Int = 60
  tags: [String!]
}

type FetchTask {
  id: ID!
  sourceId: ID!
  status: TaskStatus!
  scheduledAt: DateTime!
  startedAt: DateTime
  finishedAt: DateTime
  error: String
  createdBy: ID!
}

enum TaskStatus { QUEUED RUNNING SUCCEEDED FAILED }

interface OsintItem {
  id: ID!
  title: String
  summary: String
  url: String
  publishedAt: DateTime
  language: String
  hash: String!
  license: LicenseRef!
  policy: PolicyLabels!
  provenance: [ProvenanceStep!]!
}

type OsintDocument implements OsintItem {
  id: ID!
  title: String
  summary: String
  url: String
  publishedAt: DateTime
  language: String
  hash: String!
  license: LicenseRef!
  policy: PolicyLabels!
  provenance: [ProvenanceStep!]!
  entities: [EntityRef!]!
  claims: [Claim!]!
}

# Minimal supporting types for MVP
type LicenseRef { id: ID!, name: String }
type PolicyLabels { tags: [String!]! }
type ProvenanceStep { kind: String!, ts: DateTime!, note: String }
type EntityRef { id: ID!, kind: String, name: String }
type Claim { id: ID!, text: String, confidence: Float }

extend type Query {
  osintSources(search: String, kind: OsintSourceKind, enabled: Boolean): [OsintSource!]!
  osintItems(search: String, tag: String, after: String, limit: Int = 50, sort: OsintSort = DATE): [OsintItem!]!
}

enum OsintSort { RELEVANCE DATE }

extend type Mutation {
  createOsintSource(input: CreateOsintSourceInput!): OsintSource!
  scheduleFetch(sourceId: ID!): FetchTask!
  reprocessOsintItem(id: ID!): OsintItem!
}

type OsintIngestEvent { kind: String!, itemId: ID, sourceId: ID, taskId: ID, message: String }

# Export API
enum ExportFormat { CSV JSON ZIP }

type ExportResult { id: ID!, url: String!, expiresAt: DateTime! }

extend type Mutation {
  exportOsintBundle(ids: [ID!]!, format: ExportFormat!): ExportResult!
}

# Health dashboard
type OsintHealth {
  sourceId: ID!
  name: String!
  lastRunAt: DateTime
  lastStatus: String
  itemsIngested: Int
  errorRate: Float
  nextRunAt: DateTime
  avgLatency: Int
  p95Latency: Int
}

extend type Query {
  osintHealth(sourceId: ID): [OsintHealth!]!
  erSuggestions(filter: ERFilter, limit: Int = 50, after: String): [ERSuggestion!]!
  myWatchlists: [Watchlist!]!
  alerts(watchlistId: ID, status: String, after: String, limit: Int = 50): [Alert!]!
  osintRuns(sourceId: ID!, limit: Int = 10): [OsintRun!]!
}

input ERFilter { kind: String, minConfidence: Float = 0.7, status: String = "OPEN" }

type ERSuggestion { id: ID!, leftId: ID!, rightId: ID!, confidence: Float!, rationale: JSON!, status: String!, createdAt: DateTime! }

extend type Mutation {
  acceptErSuggestion(id: ID!): Boolean!
  rejectErSuggestion(id: ID!): Boolean!
  createWatchlist(name: String!, rules: JSON!): Watchlist!
  addWatchlistMember(watchlistId: ID!, userId: ID!, role: String = "VIEWER"): Boolean!
  ackAlert(id: ID!): Boolean!
}

type Watchlist { id: ID!, name: String!, ownerId: ID, rules: JSON!, createdAt: DateTime!, updatedAt: DateTime! }
type Alert { id: ID!, watchlistId: ID!, entityHash: ID, docHash: ID!, ruleId: String, status: String!, createdAt: DateTime! }
type OsintRun { startedAt: DateTime!, finishedAt: DateTime, status: String!, itemsIngested: Int!, latencyMs: Int, error: String }

extend type Subscription {
  osintIngestEvents: OsintIngestEvent!
}

# Deconfliction utilities
extend type Query { mergeLineage(canonicalId: ID!): [ID!]! }
extend type Mutation { undoMerge(canonicalId: ID!, last: Boolean = true): Boolean! }

# Cases core (MVP-7a)
type Case { id: ID!, tenantId: String, name: String!, status: String!, priority: String, summary: String, createdBy: String, createdAt: DateTime!, updatedAt: DateTime! }
type CaseItem { id: ID!, caseId: ID!, kind: String!, refId: ID!, tags: [String!]!, addedBy: String, addedAt: DateTime! }
type CaseNote { id: ID!, caseId: ID!, authorId: ID, body: String!, createdAt: DateTime! }
type CaseTimeline { id: ID!, caseId: ID!, at: DateTime!, event: String!, payload: JSON! }

input CaseInput { tenantId: String, name: String!, priority: String, summary: String }
input CaseUpdateInput { name: String, priority: String, summary: String }

extend type Query {
  cases(search: String, status: String, after: String, limit: Int = 50): [Case!]!
  case(id: ID!): Case
  caseItems(caseId: ID!): [CaseItem!]!
  caseTimeline(caseId: ID!, limit: Int = 100): [CaseTimeline!]!
}

extend type Mutation {
  createCase(input: CaseInput!): Case!
  updateCase(id: ID!, input: CaseUpdateInput!): Case!
  addCaseItem(caseId: ID!, kind: String!, refId: ID!, tags: [String!]): CaseItem!
  addCaseNote(caseId: ID!, body: String!): CaseNote!
  removeCaseItem(id: ID!): Boolean!
  closeCase(id: ID!): Boolean!
  exportCaseBundle(caseId: ID!, format: ExportFormat!): ExportResult!
}
