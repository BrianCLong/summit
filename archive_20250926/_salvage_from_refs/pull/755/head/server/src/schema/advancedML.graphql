# Advanced ML Schema for IntelGraph
# Supports GPU acceleration, quantum computing, and distributed training

# System Information Types
type MLSystemInfo {
  healthy: Boolean!
  platform: MLPlatformInfo
  cpu: MLCPUInfo
  memory: MLMemoryInfo
  pytorch: MLPyTorchInfo
  gpus: [MLGPUInfo!]
  timestamp: String!
  error: String
}

type MLPlatformInfo {
  system: String!
  release: String!
  version: String!
  machine: String!
  processor: String!
  pythonVersion: String!
}

type MLCPUInfo {
  physicalCores: Int!
  logicalCores: Int!
  maxFrequency: Float
  currentFrequency: Float
}

type MLMemoryInfo {
  totalGb: Float!
  availableGb: Float!
}

type MLPyTorchInfo {
  version: String!
  cudaAvailable: Boolean!
  cudaVersion: String
  cudnnVersion: String
  gpuCount: Int!
}

type MLGPUInfo {
  id: Int!
  name: String!
  memoryTotalGb: Float!
  computeCapability: String
}

# Model Types
type MLModel {
  id: String!
  type: MLModelType!
  status: MLModelStatus!
  createdAt: String!
  device: String!
  memoryUsage: MLMemoryUsage
}

type MLMemoryUsage {
  cpuMemoryGb: Float!
  cpuPercent: Float!
  gpuMemoryAllocatedGb: Float
  gpuMemoryReservedGb: Float
  gpuMemoryMaxAllocatedGb: Float
}

enum MLModelType {
  ACCELERATED_GNN
  QUANTUM_GNN
  HYBRID
}

enum MLModelStatus {
  READY
  TRAINING
  TRAINED
  OPTIMIZED
  ERROR
}

enum MLArchitecture {
  GCN
  SAGE
  GAT
}

enum MLOptimizationType {
  TENSORRT
  TORCHSCRIPT
  QUANTIZATION
}

enum MLTargetPrecision {
  FP16
  INT8
}

enum MLAnalysisType {
  ANOMALY_DETECTION
  LINK_PREDICTION
  NODE_CLASSIFICATION
}

enum QuantumProblemType {
  COMBINATORIAL
  GRAPH_COLORING
  TSP
}

# Metrics Types
type MLMetrics {
  system: MLSystemMetrics!
  models: MLModelMetrics!
  timestamp: String!
}

type MLSystemMetrics {
  currentStatus: MLCurrentStatus!
  aggregated5min: MLAggregatedMetrics!
  aggregated1hour: MLAggregatedMetrics!
  collectionInfo: MLCollectionInfo!
}

type MLCurrentStatus {
  timestamp: String!
  system: MLSystemStatus
  gpus: [MLGPUStatus!]
}

type MLSystemStatus {
  cpuPercent: Float!
  memoryPercent: Float!
  memoryUsedGb: Float!
  memoryTotalGb: Float!
  diskUsagePercent: Float!
  networkBytesSent: Int!
  networkBytesRecv: Int!
}

type MLGPUStatus {
  gpuId: Int!
  name: String!
  memoryUsedMb: Float!
  memoryTotalMb: Float!
  memoryPercent: Float!
  utilizationPercent: Float!
  temperatureC: Float!
  powerWatts: Float!
}

type MLAggregatedMetrics {
  timeWindowMinutes: Int!
  system: MLSystemAggregation
  gpus: [MLGPUAggregation!]
  models: [MLModelAggregation!]
}

type MLSystemAggregation {
  avgCpuPercent: Float!
  maxCpuPercent: Float!
  avgMemoryPercent: Float!
  maxMemoryPercent: Float!
  totalNetworkSentGb: Float!
  totalNetworkRecvGb: Float!
  sampleCount: Int!
}

type MLGPUAggregation {
  gpuId: Int!
  avgUtilizationPercent: Float!
  maxUtilizationPercent: Float!
  avgMemoryPercent: Float!
  maxMemoryPercent: Float!
  avgTemperatureC: Float!
  maxTemperatureC: Float!
  avgPowerWatts: Float!
  maxPowerWatts: Float!
  sampleCount: Int!
}

type MLModelAggregation {
  modelId: String!
  avgInferenceTimeMs: Float!
  minInferenceTimeMs: Float!
  maxInferenceTimeMs: Float!
  avgThroughput: Float!
  maxThroughput: Float!
  avgMemoryUsageMb: Float!
  maxMemoryUsageMb: Float!
  sampleCount: Int!
}

type MLModelMetrics {
  modelMetrics: [MLModelMetric!]!
}

type MLModelMetric {
  modelId: String!
  status: MLModelStatus!
  createdAt: String!
  modelType: MLModelType!
  memoryUsage: MLMemoryUsage
}

type MLCollectionInfo {
  collecting: Boolean!
  intervalSeconds: Float!
  maxHistory: Int!
  gpuAvailable: Boolean!
  numGpus: Int!
}

# Input Types
input CreateMLModelInput {
  modelType: MLModelType
  numNodeFeatures: Int
  hiddenChannels: Int
  numClasses: Int
  architecture: MLArchitecture
  useQuantization: Boolean
  quantizationBits: Int
  useQuantum: Boolean
  quantumQubits: Int
}

input MLTrainingConfig {
  batchSize: Int
  learningRate: Float
  numEpochs: Int
  useMixedPrecision: Boolean
  useDistributed: Boolean
}

input MLGraphData {
  nodeFeatures: [[Float!]!]!
  edgeIndex: [[Int!]!]!
  batchIndices: [Int!]
}

input QuantumOptimizationInput {
  problemType: QuantumProblemType!
  costFunction: String! # JSON string
  numQubits: Int
  numIterations: Int
}

# Response Types
type CreateMLModelResponse {
  success: Boolean!
  modelId: String
  message: String
  config: String # JSON string of model config
  error: String
}

type TrainMLModelResponse {
  success: Boolean!
  message: String
  modelId: String!
  trainingConfig: String # JSON string
  error: String
}

type MLInferenceResponse {
  success: Boolean!
  modelId: String!
  predictions: [[Float!]!]
  confidenceScores: [Float!]
  inferenceTime: Float!
  device: String!
  error: String
}

type OptimizeMLModelResponse {
  success: Boolean!
  message: String
  modelId: String!
  optimizationType: MLOptimizationType!
  targetPrecision: MLTargetPrecision!
  error: String
}

type QuantumOptimizationResponse {
  success: Boolean!
  optimalParameters: [Float!]
  finalCost: Float!
  numQubits: Int!
  numIterations: Int!
  problemType: QuantumProblemType!
  error: String
}

type GraphMLAnalysisResponse {
  success: Boolean!
  graphId: String!
  analysisType: MLAnalysisType!
  predictions: [[Float!]!]
  confidenceScores: [Float!]
  inferenceTime: Float!
  modelInfo: String! # JSON string
  insights: [String!]!
  error: String
}

type QuantumGraphOptimizationResponse {
  success: Boolean!
  graphId: String!
  optimizationType: String!
  optimalSolution: [Float!]
  finalCost: Float!
  quantumAdvantage: Boolean!
  graphInfo: String! # JSON string
  recommendations: [String!]!
  error: String
}

type DeleteMLModelResponse {
  success: Boolean!
  message: String
  modelId: String!
  error: String
}

# Root Types
type Query {
  # System Information
  mlSystemInfo: MLSystemInfo!
  
  # Model Management
  mlModels: [MLModel!]!
  
  # Metrics and Monitoring
  mlMetrics: MLMetrics!
}

type Mutation {
  # Model Lifecycle
  createMLModel(input: CreateMLModelInput!): CreateMLModelResponse!
  trainMLModel(modelId: String!, trainingConfig: MLTrainingConfig): TrainMLModelResponse!
  optimizeMLModel(
    modelId: String!
    optimizationType: MLOptimizationType
    targetPrecision: MLTargetPrecision
  ): OptimizeMLModelResponse!
  deleteMLModel(modelId: String!): DeleteMLModelResponse!
  
  # Inference and Analysis
  runMLInference(modelId: String!, graphData: MLGraphData!): MLInferenceResponse!
  analyzeGraphWithML(
    graphId: String!
    analysisType: MLAnalysisType
  ): GraphMLAnalysisResponse!
  
  # Quantum Computing
  runQuantumOptimization(input: QuantumOptimizationInput!): QuantumOptimizationResponse!
  optimizeGraphWithQuantum(
    graphId: String!
    optimizationType: String
    numQubits: Int
  ): QuantumGraphOptimizationResponse!
}

# Subscriptions for real-time ML monitoring
type Subscription {
  # Real-time metrics updates
  mlMetricsUpdates: MLMetrics!
  
  # Model training progress
  modelTrainingProgress(modelId: String!): String!
  
  # System health updates
  mlSystemHealthUpdates: MLSystemInfo!
}
