name: GA Provenance Verification Gates
# Sprint 26: Enterprise-grade provenance verification for GA cutover

on:
  workflow_call:
    inputs:
      image_uri:
        description: 'Container image URI to verify'
        required: true
        type: string
      image_digest:
        description: 'Container image digest'
        required: true
        type: string
      deployment_env:
        description: 'Target deployment environment'
        required: true
        type: string
      bypass_emergency:
        description: 'Emergency bypass (requires approval)'
        required: false
        type: boolean
        default: false
    outputs:
      verification_status:
        description: 'Overall verification status'
        value: ${{ jobs.provenance-verification.outputs.status }}
      slsa_level:
        description: 'SLSA level achieved'
        value: ${{ jobs.provenance-verification.outputs.slsa_level }}
      security_grade:
        description: 'Security grade assigned'
        value: ${{ jobs.security-verification.outputs.grade }}

permissions:
  contents: read
  id-token: write
  attestations: read
  packages: read
  issues: write  # For creating verification reports

env:
  COSIGN_EXPERIMENTAL: 1

jobs:
  provenance-verification:
    name: "Provenance Verification"
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.verify-status.outputs.status }}
      slsa_level: ${{ steps.slsa-check.outputs.level }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install verification tools
        run: |
          # Install Cosign
          curl -O -L "https://github.com/sigstore/cosign/releases/download/v2.2.4/cosign-linux-amd64"
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign

          # Install SLSA verifier
          curl -Lo slsa-verifier https://github.com/slsa-framework/slsa-verifier/releases/download/v2.5.1/slsa-verifier-linux-amd64
          sudo mv slsa-verifier /usr/local/bin/
          sudo chmod +x /usr/local/bin/slsa-verifier

          # Install in-toto verifier
          pip install in-toto

      - name: Emergency bypass check
        if: ${{ inputs.bypass_emergency == true }}
        run: |
          echo "ðŸš¨ EMERGENCY BYPASS REQUESTED"
          echo "Environment: ${{ inputs.deployment_env }}"
          echo "Image: ${{ inputs.image_uri }}"
          echo "Requester: ${{ github.actor }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Log emergency bypass
          cat > emergency-bypass.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "requester": "${{ github.actor }}",
            "environment": "${{ inputs.deployment_env }}",
            "image_uri": "${{ inputs.image_uri }}",
            "image_digest": "${{ inputs.image_digest }}",
            "run_id": "${{ github.run_id }}",
            "reason": "Emergency deployment bypass",
            "approval_required": true
          }
          EOF

          # Create bypass issue for audit trail
          cat > bypass-issue.md <<EOF
          # ðŸš¨ Emergency Provenance Bypass Request

          **Environment:** ${{ inputs.deployment_env }}
          **Image:** ${{ inputs.image_uri }}
          **Digest:** ${{ inputs.image_digest }}
          **Requester:** ${{ github.actor }}
          **Timestamp:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ## Required Actions
          - [ ] Security team approval
          - [ ] Engineering manager approval
          - [ ] Document post-incident review
          - [ ] Schedule retroactive verification

          **Auto-generated by GA Provenance Gates**
          EOF

          # Only proceed if this is a pre-approved emergency
          if [[ "${{ inputs.deployment_env }}" == "production" ]]; then
            echo "âŒ Production emergency bypass requires manual approval"
            echo "Create emergency approval issue and re-run with proper authorization"
            exit 1
          fi

      - name: Verify image signature
        id: verify-signature
        run: |
          echo "ðŸ” Verifying image signature..."

          # Verify Cosign signature
          cosign verify ${{ inputs.image_uri }} \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            --output json > signature-verification.json

          SIGNATURE_VALID=$(jq length signature-verification.json)

          if [[ $SIGNATURE_VALID -gt 0 ]]; then
            echo "âœ… Image signature verified"
            echo "signature_valid=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Image signature verification failed"
            echo "signature_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Verify SLSA provenance
        id: slsa-check
        run: |
          echo "ðŸ“‹ Verifying SLSA provenance..."

          # Verify SLSA provenance with slsa-verifier
          slsa-verifier verify-image ${{ inputs.image_uri }} \
            --source-uri github.com/${{ github.repository }} \
            --output-file slsa-verification.json || SLSA_EXIT_CODE=$?

          if [[ ${SLSA_EXIT_CODE:-0} -eq 0 ]]; then
            SLSA_LEVEL=$(jq -r '.predicate.buildDefinition.buildType' slsa-verification.json | grep -o 'slsa-[0-9]' || echo "slsa-1")
            echo "âœ… SLSA provenance verified: $SLSA_LEVEL"
            echo "level=$SLSA_LEVEL" >> $GITHUB_OUTPUT
            echo "slsa_valid=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ SLSA provenance verification failed"
            echo "level=slsa-0" >> $GITHUB_OUTPUT
            echo "slsa_valid=false" >> $GITHUB_OUTPUT

            # For GA, SLSA-3 is required
            if [[ "${{ inputs.deployment_env }}" == "production" ]]; then
              exit 1
            fi
          fi

      - name: Verify SBOM attestation
        id: verify-sbom
        run: |
          echo "ðŸ“¦ Verifying SBOM attestation..."

          # Verify SBOM attestation
          cosign verify-attestation ${{ inputs.image_uri }} \
            --type spdx \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            --output json > sbom-verification.json

          if [[ $? -eq 0 ]]; then
            # Extract and validate SBOM
            jq -r '.payload' sbom-verification.json | base64 -d > sbom-payload.json
            SBOM_PACKAGES=$(jq '.predicate.packages | length' sbom-payload.json)

            echo "âœ… SBOM attestation verified: $SBOM_PACKAGES packages"
            echo "sbom_valid=true" >> $GITHUB_OUTPUT
            echo "package_count=$SBOM_PACKAGES" >> $GITHUB_OUTPUT
          else
            echo "âŒ SBOM attestation verification failed"
            echo "sbom_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Verify vulnerability attestation
        id: verify-vulns
        run: |
          echo "ðŸ›¡ï¸ Verifying vulnerability attestation..."

          # Verify vulnerability attestation
          cosign verify-attestation ${{ inputs.image_uri }} \
            --type vuln \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            --output json > vuln-verification.json

          if [[ $? -eq 0 ]]; then
            # Extract vulnerability data
            jq -r '.payload' vuln-verification.json | base64 -d > vuln-payload.json
            CRITICAL_VULNS=$(jq '.predicate.critical' vuln-payload.json)
            HIGH_VULNS=$(jq '.predicate.high' vuln-payload.json)

            echo "ðŸ” Vulnerability scan results:"
            echo "  Critical: $CRITICAL_VULNS"
            echo "  High: $HIGH_VULNS"

            echo "vuln_valid=true" >> $GITHUB_OUTPUT
            echo "critical_vulns=$CRITICAL_VULNS" >> $GITHUB_OUTPUT
            echo "high_vulns=$HIGH_VULNS" >> $GITHUB_OUTPUT
          else
            echo "âŒ Vulnerability attestation verification failed"
            echo "vuln_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Verify supply chain metadata
        id: verify-supply-chain
        run: |
          echo "ðŸ”— Verifying supply chain metadata..."

          # Check for additional supply chain attestations
          cosign verify-attestation ${{ inputs.image_uri }} \
            --type slsaprovenance \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            --output json > provenance-verification.json

          if [[ $? -eq 0 ]]; then
            # Extract provenance metadata
            jq -r '.payload' provenance-verification.json | base64 -d > provenance-payload.json

            # Check builder identity
            BUILDER_ID=$(jq -r '.predicate.builder.id' provenance-payload.json)
            BUILD_TYPE=$(jq -r '.predicate.buildType' provenance-payload.json)

            echo "ðŸ—ï¸ Build metadata:"
            echo "  Builder: $BUILDER_ID"
            echo "  Build Type: $BUILD_TYPE"

            # Validate trusted builder
            if [[ "$BUILDER_ID" == *"github.com/actions"* ]] || [[ "$BUILDER_ID" == *"slsa-framework"* ]]; then
              echo "âœ… Trusted builder verified"
              echo "trusted_builder=true" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ Unknown builder: $BUILDER_ID"
              echo "trusted_builder=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ Supply chain verification failed"
            echo "trusted_builder=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Generate verification report
        id: verify-status
        run: |
          # Create verification summary
          cat > verification-report.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "image_uri": "${{ inputs.image_uri }}",
            "image_digest": "${{ inputs.image_digest }}",
            "environment": "${{ inputs.deployment_env }}",
            "verification_results": {
              "signature_valid": ${{ steps.verify-signature.outputs.signature_valid }},
              "slsa_valid": ${{ steps.slsa-check.outputs.slsa_valid }},
              "slsa_level": "${{ steps.slsa-check.outputs.level }}",
              "sbom_valid": ${{ steps.verify-sbom.outputs.sbom_valid }},
              "vuln_valid": ${{ steps.verify-vulns.outputs.vuln_valid }},
              "trusted_builder": ${{ steps.verify-supply-chain.outputs.trusted_builder }}
            },
            "security_metrics": {
              "critical_vulnerabilities": ${{ steps.verify-vulns.outputs.critical_vulns || 0 }},
              "high_vulnerabilities": ${{ steps.verify-vulns.outputs.high_vulns || 0 }},
              "package_count": ${{ steps.verify-sbom.outputs.package_count || 0 }}
            },
            "emergency_bypass": ${{ inputs.bypass_emergency }}
          }
          EOF

          # Determine overall status
          SIGNATURE_OK="${{ steps.verify-signature.outputs.signature_valid }}"
          SLSA_OK="${{ steps.slsa-check.outputs.slsa_valid }}"
          SBOM_OK="${{ steps.verify-sbom.outputs.sbom_valid }}"
          VULN_OK="${{ steps.verify-vulns.outputs.vuln_valid }}"
          BUILDER_OK="${{ steps.verify-supply-chain.outputs.trusted_builder }}"

          if [[ "$SIGNATURE_OK" == "true" && "$SLSA_OK" == "true" && "$SBOM_OK" == "true" && "$VULN_OK" == "true" && "$BUILDER_OK" == "true" ]]; then
            echo "âœ… All provenance verifications passed"
            echo "status=PASS" >> $GITHUB_OUTPUT
          elif [[ "${{ inputs.bypass_emergency }}" == "true" ]]; then
            echo "âš ï¸ Emergency bypass enabled - proceeding with warnings"
            echo "status=BYPASS" >> $GITHUB_OUTPUT
          else
            echo "âŒ Provenance verification failed"
            echo "status=FAIL" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: provenance-verification-${{ inputs.deployment_env }}
          path: |
            verification-report.json
            signature-verification.json
            slsa-verification.json
            sbom-verification.json
            vuln-verification.json
            provenance-verification.json
            emergency-bypass.json

  security-verification:
    name: "Security Policy Verification"
    runs-on: ubuntu-latest
    needs: provenance-verification
    outputs:
      grade: ${{ steps.security-grade.outputs.grade }}
    steps:
      - name: Download verification artifacts
        uses: actions/download-artifact@v4
        with:
          name: provenance-verification-${{ inputs.deployment_env }}

      - name: Evaluate security policy
        id: security-grade
        run: |
          echo "ðŸ›¡ï¸ Evaluating security policy compliance..."

          # Load verification results
          CRITICAL_VULNS=$(jq '.security_metrics.critical_vulnerabilities' verification-report.json)
          HIGH_VULNS=$(jq '.security_metrics.high_vulnerabilities' verification-report.json)
          SLSA_LEVEL=$(jq -r '.verification_results.slsa_level' verification-report.json)

          # Security grading logic
          GRADE="F"
          SECURITY_SCORE=0

          # SLSA level scoring
          case "$SLSA_LEVEL" in
            "slsa-3"|"slsa-4")
              SECURITY_SCORE=$((SECURITY_SCORE + 40))
              echo "âœ… SLSA Level 3+ (+40 points)"
              ;;
            "slsa-2")
              SECURITY_SCORE=$((SECURITY_SCORE + 25))
              echo "âš ï¸ SLSA Level 2 (+25 points)"
              ;;
            *)
              echo "âŒ SLSA Level insufficient (0 points)"
              ;;
          esac

          # Vulnerability scoring
          if [[ $CRITICAL_VULNS -eq 0 ]]; then
            SECURITY_SCORE=$((SECURITY_SCORE + 30))
            echo "âœ… No critical vulnerabilities (+30 points)"
          else
            echo "âŒ $CRITICAL_VULNS critical vulnerabilities (0 points)"
          fi

          if [[ $HIGH_VULNS -le 5 ]]; then
            SECURITY_SCORE=$((SECURITY_SCORE + 20))
            echo "âœ… Low high-severity vulnerabilities (+20 points)"
          else
            echo "âš ï¸ $HIGH_VULNS high-severity vulnerabilities (+10 points)"
            SECURITY_SCORE=$((SECURITY_SCORE + 10))
          fi

          # Supply chain verification
          TRUSTED_BUILDER=$(jq '.verification_results.trusted_builder' verification-report.json)
          if [[ "$TRUSTED_BUILDER" == "true" ]]; then
            SECURITY_SCORE=$((SECURITY_SCORE + 10))
            echo "âœ… Trusted builder (+10 points)"
          fi

          # Assign grade
          if [[ $SECURITY_SCORE -ge 90 ]]; then
            GRADE="A"
          elif [[ $SECURITY_SCORE -ge 80 ]]; then
            GRADE="B"
          elif [[ $SECURITY_SCORE -ge 70 ]]; then
            GRADE="C"
          elif [[ $SECURITY_SCORE -ge 60 ]]; then
            GRADE="D"
          fi

          echo "ðŸ“Š Security Score: $SECURITY_SCORE/100 (Grade: $GRADE)"
          echo "grade=$GRADE" >> $GITHUB_OUTPUT
          echo "score=$SECURITY_SCORE" >> $GITHUB_OUTPUT

          # Environment-specific requirements
          case "${{ inputs.deployment_env }}" in
            "production")
              if [[ "$GRADE" < "B" ]] || [[ $CRITICAL_VULNS -gt 0 ]]; then
                echo "âŒ Production deployment requires Grade B+ and zero critical vulnerabilities"
                exit 1
              fi
              ;;
            "staging")
              if [[ "$GRADE" < "C" ]]; then
                echo "âŒ Staging deployment requires Grade C+"
                exit 1
              fi
              ;;
          esac

      - name: Generate security report
        run: |
          # Create detailed security report
          cat > security-report.md <<EOF
          # ðŸ›¡ï¸ Security Verification Report

          **Image:** \`${{ inputs.image_uri }}\`
          **Environment:** ${{ inputs.deployment_env }}
          **Timestamp:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Security Grade:** ${{ steps.security-grade.outputs.grade }}
          **Security Score:** ${{ steps.security-grade.outputs.score }}/100

          ## Verification Results

          | Component | Status | Details |
          |-----------|--------|---------|
          | Image Signature | $(jq -r '.verification_results.signature_valid' verification-report.json | sed 's/true/âœ… Verified/g; s/false/âŒ Failed/g') | Cosign signature verification |
          | SLSA Provenance | $(jq -r '.verification_results.slsa_valid' verification-report.json | sed 's/true/âœ… Verified/g; s/false/âŒ Failed/g') | $(jq -r '.verification_results.slsa_level' verification-report.json) |
          | SBOM Attestation | $(jq -r '.verification_results.sbom_valid' verification-report.json | sed 's/true/âœ… Verified/g; s/false/âŒ Failed/g') | $(jq '.security_metrics.package_count' verification-report.json) packages |
          | Vulnerability Scan | $(jq -r '.verification_results.vuln_valid' verification-report.json | sed 's/true/âœ… Verified/g; s/false/âŒ Failed/g') | Critical: $(jq '.security_metrics.critical_vulnerabilities' verification-report.json), High: $(jq '.security_metrics.high_vulnerabilities' verification-report.json) |
          | Trusted Builder | $(jq -r '.verification_results.trusted_builder' verification-report.json | sed 's/true/âœ… Verified/g; s/false/âŒ Failed/g') | GitHub Actions verified |

          ## Security Policy Compliance

          $(if [[ "${{ inputs.deployment_env }}" == "production" ]]; then
            echo "**Production Requirements:**"
            echo "- âœ… Security Grade B+ required"
            echo "- âœ… Zero critical vulnerabilities"
            echo "- âœ… SLSA Level 3+ provenance"
          else
            echo "**${{ inputs.deployment_env }} Requirements:**"
            echo "- âœ… Security Grade C+ required"
            echo "- âš ï¸ Limited critical vulnerabilities allowed"
          fi)

          ## Recommendations

          $(if [[ "$(jq '.security_metrics.critical_vulnerabilities' verification-report.json)" -gt 0 ]]; then
            echo "- ðŸš¨ **Critical:** Address $(jq '.security_metrics.critical_vulnerabilities' verification-report.json) critical vulnerabilities before production deployment"
          fi)

          $(if [[ "$(jq -r '.verification_results.slsa_level' verification-report.json)" != "slsa-3" ]] && [[ "$(jq -r '.verification_results.slsa_level' verification-report.json)" != "slsa-4" ]]; then
            echo "- âš ï¸ **Recommended:** Upgrade to SLSA Level 3+ for enhanced supply chain security"
          fi)

          ---
          *Generated by IntelGraph GA Provenance Gates*
          EOF

      - name: Upload security report
        uses: actions/upload-artifact@v4
        with:
          name: security-report-${{ inputs.deployment_env }}
          path: security-report.md

  deployment-gate:
    name: "Deployment Gate"
    runs-on: ubuntu-latest
    needs: [provenance-verification, security-verification]
    if: ${{ needs.provenance-verification.outputs.status == 'PASS' || needs.provenance-verification.outputs.status == 'BYPASS' }}
    steps:
      - name: Deployment approval
        run: |
          echo "ðŸš€ Deployment Gate Assessment"
          echo "================================"
          echo "Environment: ${{ inputs.deployment_env }}"
          echo "Image: ${{ inputs.image_uri }}"
          echo "Provenance Status: ${{ needs.provenance-verification.outputs.status }}"
          echo "SLSA Level: ${{ needs.provenance-verification.outputs.slsa_level }}"
          echo "Security Grade: ${{ needs.security-verification.outputs.grade }}"
          echo "Emergency Bypass: ${{ inputs.bypass_emergency }}"

          # Final deployment decision
          if [[ "${{ needs.provenance-verification.outputs.status }}" == "PASS" ]] && [[ "${{ needs.security-verification.outputs.grade }}" =~ ^[ABC]$ ]]; then
            echo "âœ… DEPLOYMENT APPROVED"
            echo "All provenance and security requirements met"
          elif [[ "${{ inputs.bypass_emergency }}" == "true" ]]; then
            echo "âš ï¸ DEPLOYMENT APPROVED WITH BYPASS"
            echo "Emergency bypass activated - manual review required"
          else
            echo "âŒ DEPLOYMENT REJECTED"
            echo "Provenance or security requirements not met"
            exit 1
          fi

      - name: Create deployment manifest
        run: |
          # Generate deployment manifest with verification metadata
          cat > deployment-manifest.json <<EOF
          {
            "deployment": {
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "environment": "${{ inputs.deployment_env }}",
              "image_uri": "${{ inputs.image_uri }}",
              "image_digest": "${{ inputs.image_digest }}",
              "workflow_run": "${{ github.run_id }}"
            },
            "verification": {
              "provenance_status": "${{ needs.provenance-verification.outputs.status }}",
              "slsa_level": "${{ needs.provenance-verification.outputs.slsa_level }}",
              "security_grade": "${{ needs.security-verification.outputs.grade }}",
              "emergency_bypass": ${{ inputs.bypass_emergency }}
            },
            "attestations": {
              "signature_verified": true,
              "sbom_attached": true,
              "vulnerabilities_scanned": true,
              "provenance_validated": true
            },
            "compliance": {
              "slsa_compliant": $(if [[ "${{ needs.provenance-verification.outputs.slsa_level }}" =~ slsa-[34] ]]; then echo "true"; else echo "false"; fi),
              "security_compliant": $(if [[ "${{ needs.security-verification.outputs.grade }}" =~ ^[ABC]$ ]]; then echo "true"; else echo "false"; fi),
              "deployment_approved": true
            }
          }
          EOF

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-${{ inputs.deployment_env }}
          path: deployment-manifest.json