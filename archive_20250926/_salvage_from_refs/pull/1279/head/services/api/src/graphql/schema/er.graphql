# Entity Resolution GraphQL Schema
# Adjudication queue, confidence bands, and decision management

type Query {
  # Get ER queue for adjudication
  erQueue(input: ERQueueInput!): ERQueueResponse!

  # Get ER candidate details
  erCandidate(id: ID!): ERCandidate

  # Get ER statistics and metrics
  erStats(tenantId: String!, days: Int = 7): ERStats!

  # Get ER configuration
  erConfig(tenantId: String!): ERConfig!
}

type Mutation {
  # Submit ER candidates for processing
  erSubmitCandidates(input: ERSubmitInput!): ERSubmitResponse!

  # Make decisions on ER candidates
  erMakeDecision(input: ERDecisionInput!): ERDecisionResponse!

  # Bulk decisions
  erBulkDecision(input: ERBulkDecisionInput!): ERBulkDecisionResponse!

  # Undo a decision
  erUndoDecision(candidateId: ID!, reason: String): ERDecisionResponse!

  # Update ER configuration
  erUpdateConfig(input: ERConfigInput!): Boolean!

  # Trigger auto-merge process
  erTriggerAutoMerge(tenantId: String!): ERAutoMergeResponse!
}

# Input types
input ERQueueInput {
  tenantId: String!
  confidenceBand: ERConfidenceBand
  entityType: String
  offset: Int = 0
  limit: Int = 50
  sortBy: ERQueueSortBy = CONFIDENCE_DESC
  includeExpired: Boolean = false
}

input ERSubmitInput {
  tenantId: String!
  candidates: [ERCandidateInput!]!
  sourceSystem: String
  batchMetadata: JSON
}

input ERCandidateInput {
  primaryEntityId: String!
  primaryEntityType: String!
  primaryEntityData: JSON!
  candidateEntityId: String!
  candidateEntityType: String!
  candidateEntityData: JSON!
  priority: Int = 0
  expiresInHours: Int
}

input ERDecisionInput {
  candidateId: ID!
  decision: ERDecision!
  reason: String
  metadata: JSON
}

input ERBulkDecisionInput {
  candidateIds: [ID!]!
  decision: ERDecision!
  reason: String
  metadata: JSON
}

input ERConfigInput {
  tenantId: String!
  highThreshold: Float
  midThreshold: Float
  autoMergeEnabled: Boolean
  autoMergeThreshold: Float
  queueTtlHours: Int
  maxQueueSize: Int
}

# Enums
enum ERConfidenceBand {
  LOW
  MID
  HIGH
}

enum ERDecision {
  APPROVE
  REJECT
  SOFT_SPLIT
  UNDO
}

enum ERQueueSortBy {
  CONFIDENCE_DESC
  CONFIDENCE_ASC
  CREATED_DESC
  CREATED_ASC
  PRIORITY_DESC
  EXPIRES_SOON
}

enum ERCandidateStatus {
  PENDING
  APPROVED
  REJECTED
  AUTO_MERGED
  EXPIRED
}

# Response types
type ERQueueResponse {
  candidates: [ERCandidate!]!
  totalCount: Int!
  hasMore: Boolean!
  queueStats: ERQueueStats!
}

type ERCandidate {
  id: ID!
  tenantId: String!

  # Primary entity
  primaryEntityId: String!
  primaryEntityType: String!
  primaryEntityData: JSON!

  # Candidate entity
  candidateEntityId: String!
  candidateEntityType: String!
  candidateEntityData: JSON!

  # Confidence scoring
  confidenceScore: Float!
  confidenceBand: ERConfidenceBand!
  similarityFactors: JSON!

  # Queue management
  status: ERCandidateStatus!
  queuePriority: Int!
  minutesInQueue: Float!
  expiresAt: String
  isExpired: Boolean!

  # Metadata
  algorithmVersion: String!
  createdAt: String!
  updatedAt: String!

  # Decision history
  decisions: [ERDecision!]!
  lastDecision: ERDecisionRecord
}

type ERDecisionRecord {
  id: ID!
  decision: ERDecision!
  decidedAt: String!
  decidedByUserId: String
  decidedBySystem: Boolean!
  reason: String
  metadata: JSON
}

type ERQueueStats {
  totalPending: Int!
  highConfidence: Int!
  midConfidence: Int!
  lowConfidence: Int!
  avgQueueTimeHours: Float!
  oldestCandidateAgeHours: Float!
}

type ERStats {
  # Queue metrics
  queueStats: ERQueueStats!

  # Decision metrics
  decisionStats: ERDecisionStats!

  # Auto-merge metrics
  autoMergeStats: ERAutoMergeStats!

  # Confidence distribution
  confidenceDistribution: ERConfidenceDistribution!

  # Performance metrics
  performanceMetrics: ERPerformanceMetrics!
}

type ERDecisionStats {
  totalDecisions: Int!
  approvedCount: Int!
  rejectedCount: Int!
  softSplitCount: Int!
  undoCount: Int!
  approvalRate: Float!
  avgDecisionTimeMinutes: Float!
  decisionsByBand: [ERDecisionByBand!]!
}

type ERDecisionByBand {
  confidenceBand: ERConfidenceBand!
  totalDecisions: Int!
  approvalRate: Float!
  avgConfidence: Float!
}

type ERAutoMergeStats {
  totalAutoMerges: Int!
  avgConfidence: Float!
  successRate: Float!
  avgProcessingTimeMs: Float!
  dailyCounts: [ERDailyCount!]!
}

type ERDailyCount {
  date: String!
  count: Int!
}

type ERConfidenceDistribution {
  high: Int!
  mid: Int!
  low: Int!
  avgScore: Float!
  scoreHistogram: [ERScoreBucket!]!
}

type ERScoreBucket {
  rangeStart: Float!
  rangeEnd: Float!
  count: Int!
}

type ERPerformanceMetrics {
  avgProcessingTimeMs: Float!
  throughputPerHour: Float!
  queueEfficiency: Float!
  precisionEstimate: Float!
  recallEstimate: Float!
}

type ERSubmitResponse {
  batchId: String!
  processedCount: Int!
  successfulCount: Int!
  failedCount: Int!
  autoMergedCount: Int!
  queuedCount: Int!
  duplicateCount: Int!
  processingTimeMs: Int!
  results: [ERSubmitResult!]!
}

type ERSubmitResult {
  candidateId: String!
  status: ERSubmitStatus!
  confidenceScore: Float!
  confidenceBand: ERConfidenceBand!
  autoMerged: Boolean!
  reason: String
}

enum ERSubmitStatus {
  QUEUED
  AUTO_MERGED
  REJECTED
  DUPLICATE
}

type ERDecisionResponse {
  candidateId: ID!
  decision: ERDecision!
  newStatus: ERCandidateStatus!
  processingTimeMs: Int!
  mergeStats: ERMergeStats
}

type ERBulkDecisionResponse {
  processedCount: Int!
  successfulCount: Int!
  failedCount: Int!
  results: [ERDecisionResponse!]!
  processingTimeMs: Int!
}

type ERMergeStats {
  mergedEntityId: String!
  propertiesMerged: Int!
  relationshipsTransferred: Int!
  neo4jStats: ERNeo4jStats!
}

type ERNeo4jStats {
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
  propertiesSet: Int!
}

type ERConfig {
  tenantId: String!
  highThreshold: Float!
  midThreshold: Float!
  autoMergeEnabled: Boolean!
  autoMergeThreshold: Float!
  queueTtlHours: Int!
  maxQueueSize: Int!
  algorithmVersion: String!
  similarityFactors: [ERSimilarityFactor!]!
}

type ERSimilarityFactor {
  name: String!
  type: ERSimilarityType!
  weight: Float!
  applicableEntityTypes: [String!]!
  enabled: Boolean!
  description: String
}

enum ERSimilarityType {
  EXACT_MATCH
  FUZZY_MATCH
  SEMANTIC
  STRUCTURAL
}

type ERAutoMergeResponse {
  batchId: String!
  processedCount: Int!
  successfulMerges: Int!
  failedMerges: Int!
  skippedMerges: Int!
  processingTimeMs: Int!
}

# Subscriptions for real-time updates
type Subscription {
  # Subscribe to queue updates
  erQueueUpdates(tenantId: String!): ERQueueUpdate!

  # Subscribe to decision events
  erDecisionEvents(tenantId: String!): ERDecisionEvent!

  # Subscribe to auto-merge events
  erAutoMergeEvents(tenantId: String!): ERAutoMergeEvent!
}

type ERQueueUpdate {
  type: ERQueueUpdateType!
  candidate: ERCandidate
  queueStats: ERQueueStats!
  timestamp: String!
}

enum ERQueueUpdateType {
  CANDIDATE_ADDED
  CANDIDATE_UPDATED
  CANDIDATE_REMOVED
  CANDIDATE_EXPIRED
  STATS_UPDATED
}

type ERDecisionEvent {
  candidateId: ID!
  decision: ERDecision!
  decidedBy: String
  timestamp: String!
  metadata: JSON
}

type ERAutoMergeEvent {
  batchId: String!
  candidateId: ID!
  status: String!
  mergeStats: ERMergeStats
  timestamp: String!
}

# Custom scalars
scalar JSON