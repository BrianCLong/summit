# NLâ†’Cypher GraphQL Schema
# Natural language query interface with constraint enforcement

type Query {
  # Preview natural language query without execution
  nlqPreview(input: NlqPreviewInput!): NlqPreviewResponse!

  # Execute natural language query
  nlqExecute(input: NlqExecuteInput!): NlqExecuteResponse!

  # Validate Cypher query
  nlqValidate(input: NlqValidateInput!): NlqValidateResponse!

  # Get available schema for query hints
  nlqSchema(tenantId: String!): NlqSchemaResponse!
}

# Input types
input NlqPreviewInput {
  prompt: String!
  maxResults: Int = 100
  timeoutMs: Int = 30000
  explainLevel: ExplainLevel = DETAILED
  includeExplanation: Boolean = true
  enforcementMode: EnforcementMode = BLOCK
  conversationId: String
  previousQueries: [String!]
}

input NlqExecuteInput {
  prompt: String
  cypher: String
  parameters: JSON
  maxResults: Int = 100
  timeoutMs: Int = 30000
  explainLevel: ExplainLevel = DETAILED
  includeExplanation: Boolean = true
  dryRun: Boolean = false
  enforcementMode: EnforcementMode = BLOCK
}

input NlqValidateInput {
  cypher: String!
  enforcementMode: EnforcementMode = BLOCK
}

# Enum types
enum ExplainLevel {
  BASIC
  DETAILED
  TECHNICAL
}

enum EnforcementMode {
  BLOCK
  WARN
  ALLOW
}

enum ViolationSeverity {
  INFO
  WARNING
  ERROR
}

enum ViolationCategory {
  READONLY
  LIMIT
  COMPLEXITY
  PATTERN
  TIMEOUT
}

enum DecisionType {
  ALLOWED
  BLOCKED
  MODIFIED
}

# Response types
type NlqPreviewResponse {
  requestId: String!
  cypher: String!
  originalCypher: String
  confidence: Float!
  decision: DecisionType!
  explanation: QueryExplanation
  constraintAnalysis: ConstraintAnalysis!
  metadata: TranslationMetadata!
}

type NlqExecuteResponse {
  requestId: String!
  cypher: String!
  originalCypher: String
  results: [JSON!]!
  columns: [String!]!
  summary: ExecutionSummary!
  queryPlan: QueryPlan
  warnings: [String!]!
  explanation: QueryExplanation
  constraintAnalysis: ConstraintAnalysis!
  metadata: TranslationMetadata!
}

type NlqValidateResponse {
  isValid: Boolean!
  syntaxErrors: [String!]!
  constraintAnalysis: ConstraintAnalysis!
}

type NlqSchemaResponse {
  nodeLabels: [String!]!
  relationshipTypes: [String!]!
  propertyKeys: JSON!
  indexes: [IndexInfo!]!
  constraints: [SchemaConstraint!]!
  version: String!
}

# Constraint and explanation types
type ConstraintAnalysis {
  queryId: String!
  originalCypher: String!
  modifiedCypher: String
  violations: [ConstraintViolation!]!
  estimatedCost: Float!
  complexityScore: Float!
  isAllowed: Boolean!
  enforcementMode: EnforcementMode!
  reasons: [String!]!
}

type ConstraintViolation {
  code: String!
  message: String!
  severity: ViolationSeverity!
  category: ViolationCategory!
  suggestion: String
  autoFix: String
}

type QueryExplanation {
  summary: String!
  decision: DecisionType!
  confidence: Float!
  reasons: [ExplanationReason!]!
  suggestions: [String!]!
  autoFixes: [AutoFix!]!
  policyVersion: String!
  explainId: String!
}

type ExplanationReason {
  category: String!
  severity: ViolationSeverity!
  title: String!
  description: String!
  technicalDetails: String
  learnMoreUrl: String
}

type AutoFix {
  description: String!
  originalQuery: String!
  fixedQuery: String!
  confidence: Float!
  safetyNote: String
}

# Execution types
type ExecutionSummary {
  resultCount: Int!
  executionTimeMs: Int!
  consumedUnits: Float
}

type QueryPlan {
  operators: [PlanOperator!]!
  estimatedRows: Int!
  dbHits: Int!
  pageCacheHits: Int!
  pageCacheMisses: Int!
}

type PlanOperator {
  operatorType: String!
  estimatedRows: Int!
  dbHits: Int!
  variables: [String!]!
  details: JSON!
  children: [PlanOperator!]!
}

# Schema types
type IndexInfo {
  label: String!
  properties: [String!]!
  type: IndexType!
}

type SchemaConstraint {
  label: String!
  properties: [String!]!
  type: ConstraintType!
}

enum IndexType {
  BTREE
  FULLTEXT
  VECTOR
}

enum ConstraintType {
  UNIQUE
  EXISTS
  NODE_KEY
}

# Metadata
type TranslationMetadata {
  translationTimeMs: Int!
  constraintTimeMs: Int!
  modelVersion: String
  schemaVersion: String
  promptTokens: Int
  completionTokens: Int
}

# Mutations for schema management
type Mutation {
  # Refresh schema cache
  nlqRefreshSchema(tenantId: String!): NlqSchemaResponse!

  # Update constraint configuration
  nlqUpdateConstraints(input: ConstraintConfigInput!): Boolean!
}

input ConstraintConfigInput {
  readonly: ReadonlyConfigInput
  limits: LimitsConfigInput
  complexity: ComplexityConfigInput
  timeouts: TimeoutsConfigInput
  patterns: PatternsConfigInput
}

input ReadonlyConfigInput {
  enabled: Boolean
  allowedWriteFunctions: [String!]
  allowedProcedures: [String!]
}

input LimitsConfigInput {
  defaultLimit: Int
  maxLimit: Int
  autoInject: Boolean
}

input ComplexityConfigInput {
  maxVarLengthPaths: Int
  maxTraversalDepth: Int
  maxCartesianProductSize: Int
  costBudget: Float
}

input TimeoutsConfigInput {
  queryTimeoutMs: Int
  parseTimeoutMs: Int
}

input PatternsConfigInput {
  forbiddenPatterns: [String!]
  warningPatterns: [String!]
}

# Subscriptions for real-time updates
type Subscription {
  # Subscribe to constraint violation alerts
  nlqConstraintAlerts(tenantId: String!): ConstraintAlert!

  # Subscribe to schema changes
  nlqSchemaChanges(tenantId: String!): SchemaChangeEvent!
}

type ConstraintAlert {
  timestamp: String!
  tenantId: String!
  userId: String!
  queryId: String!
  violations: [ConstraintViolation!]!
  severity: ViolationSeverity!
}

type SchemaChangeEvent {
  timestamp: String!
  tenantId: String!
  changeType: SchemaChangeType!
  details: JSON!
}

enum SchemaChangeType {
  LABELS_ADDED
  LABELS_REMOVED
  RELATIONSHIPS_ADDED
  RELATIONSHIPS_REMOVED
  INDEXES_ADDED
  INDEXES_REMOVED
  CONSTRAINTS_ADDED
  CONSTRAINTS_REMOVED
}

# Custom scalar for flexible JSON data
scalar JSON