# IntelGraph GA Cutover Go/No-Go Decision Matrix
# Sprint 26: Real-time gate validation and automated decision tracking

apiVersion: v1
kind: ConfigMap
metadata:
  name: go-no-go-matrix
  namespace: intelgraph
  labels:
    app: intelgraph
    component: cutover-management
    version: v1.0.0-ga
data:
  matrix-config.yaml: |
    # Go/No-Go Decision Matrix Configuration
    release_info:
      name: "Sprint 26 GA Cutover"
      target_date: "2025-09-17T09:00:00Z"
      environment: "production"
      change_type: "GA"

    gates:
      G1:
        name: "SLO Readiness"
        owner: "SRE On-call"
        description: "P0-P2 SLOs green with adequate error budget"
        threshold:
          p0_availability: 99.9
          p1_availability: 99.5
          p2_availability: 99.0
          error_budget_remaining_days: 14
        validation:
          method: "prometheus_query"
          queries:
            - name: "p0_slo_compliance"
              query: "min(slo_compliance_p0) * 100"
              threshold: ">= 99.9"
            - name: "error_budget_remaining"
              query: "min(error_budget_remaining_days)"
              threshold: ">= 14"
          dashboard_url: "https://grafana.intelgraph.dev/d/slo-overview"
        auto_validation: true

      G2:
        name: "K6 Performance"
        owner: "Performance Engineering"
        description: "Load test scenarios pass latency/error/throughput thresholds"
        threshold:
          graphql_read_p95_ms: 350
          graphql_write_p95_ms: 700
          neo4j_1hop_p95_ms: 300
          error_rate_percent: 0.1
          min_throughput_rps: 1000
        validation:
          method: "k6_report"
          command: "./tools/k6/run-ga-validation.sh production full"
          success_criteria:
            - "all_scenarios_passed == true"
            - "rollback_triggers_detected == false"
          report_path: "reports/k6-ga-validation.html"
        auto_validation: true

      G3:
        name: "Provenance/Supply-Chain"
        owner: "Security Engineering"
        description: "SLSA-3 attestations present, policy passes, zero exceptions"
        threshold:
          slsa_level: 3
          attestation_coverage_percent: 100
          policy_exceptions: 0
          signature_verification: true
        validation:
          method: "verify_bundle"
          command: "./tools/verify-bundle/verify-bundle.sh --target production --strict"
          success_criteria:
            - "slsa_level >= 3"
            - "attestations_present == true"
            - "signatures_valid == true"
            - "policy_exceptions == 0"
        auto_validation: true

      G4:
        name: "Change Freeze"
        owner: "Release Manager"
        description: "Freeze active, exceptions documented and approved"
        threshold:
          freeze_active: true
          documented_exceptions: true
          unapproved_exceptions: 0
        validation:
          method: "igctl_status"
          command: "igctl freeze status --format json"
          success_criteria:
            - "freeze_status == 'enforced'"
            - "unapproved_exceptions == 0"
        auto_validation: true

      G5:
        name: "DR/Backup"
        owner: "DR Lead"
        description: "Recent drill successful, RPO/RTO met, restore verified"
        threshold:
          last_drill_days: 7
          rpo_seconds: 300
          rto_seconds: 600
          restore_verified: true
        validation:
          method: "igctl_dr"
          command: "igctl dr status --recent 7d"
          success_criteria:
            - "last_drill_age_days <= 7"
            - "last_drill_success == true"
            - "rpo_met == true"
            - "rto_met == true"
        auto_validation: true

      G6:
        name: "Cost Guardrails"
        owner: "FinOps"
        description: "Forecast within budget, downshift rules armed"
        threshold:
          infrastructure_budget_utilization: 0.80
          llm_budget_utilization: 0.80
          total_budget_utilization: 0.80
          downshift_rules_armed: true
        validation:
          method: "cost_dashboard"
          queries:
            - name: "infrastructure_utilization"
              query: "intelgraph:budget_utilization_infrastructure"
              threshold: "<= 0.80"
            - name: "llm_utilization"
              query: "intelgraph:budget_utilization_llm"
              threshold: "<= 0.80"
            - name: "downshift_armed"
              query: "cost_guardrails_downshift_armed"
              threshold: "== 1"
          dashboard_url: "https://grafana.intelgraph.dev/d/cost-guardrails"
        auto_validation: true

      G7:
        name: "Security"
        owner: "Application Security"
        description: "OPA policies green, WebAuthn step-up enabled"
        threshold:
          opa_policy_health: true
          webauthn_enabled: true
          policy_decision_latency_p95_ms: 25
          step_up_success_rate: 0.99
        validation:
          method: "security_check"
          queries:
            - name: "opa_health"
              query: "up{job='opa'}"
              threshold: "== 1"
            - name: "webauthn_enabled"
              query: "webauthn_enforcement_enabled"
              threshold: "== 1"
            - name: "policy_latency"
              query: "histogram_quantile(0.95, opa_decision_duration_seconds_bucket)"
              threshold: "<= 0.025"
        auto_validation: true

      G8:
        name: "Support & Communications"
        owner: "Support Lead"
        description: "On-call staffed, status page ready, templates queued"
        threshold:
          oncall_coverage: true
          status_page_ready: true
          communication_templates_ready: true
          war_room_active: true
        validation:
          method: "manual_checklist"
          checklist:
            - "Primary on-call engineer assigned and available"
            - "Secondary on-call engineer assigned and available"
            - "Status page templates uploaded and tested"
            - "Customer communication templates ready"
            - "War room bridge established and tested"
            - "Escalation procedures verified"
        auto_validation: false

      G9:
        name: "Privacy & Data Protection"
        owner: "Privacy Engineering"
        description: "DSAR endpoints responsive, regional routing compliant, DLP clean"
        threshold:
          dsar_p95_ms: 500
          dsar_p99_ms: 900
          residency_match_rate: 1.0
          dlp_info_or_higher_findings: 0
          retention_policy_compliance: true
        validation:
          method: "privacy_validation"
          queries:
            - name: "dsar_latency_p95"
              query: "histogram_quantile(0.95, rate(dsar_request_duration_seconds_bucket[5m]))"
              threshold: "<= 0.5"
            - name: "dsar_latency_p99"
              query: "histogram_quantile(0.99, rate(dsar_request_duration_seconds_bucket[5m]))"
              threshold: "<= 0.9"
            - name: "residency_compliance"
              query: "data_residency_compliance_rate"
              threshold: "== 1.0"
            - name: "dlp_findings"
              query: "sum(dlp_findings_total{severity=~'info|warning|critical'})"
              threshold: "== 0"
          command: "./tools/privacy/validate-data-protection.sh --env production"
        auto_validation: true

      G10:
        name: "IAM & Breakglass"
        owner: "Security Engineering"
        description: "Breakglass procedures tested, service accounts validated"
        threshold:
          webauthn_success_rate: 0.99
          breakglass_window_minutes: 60
          service_account_auth_success: true
          audit_trail_complete: true
        validation:
          method: "iam_validation"
          queries:
            - name: "webauthn_success_rate"
              query: "rate(webauthn_stepup_success_total[5m]) / rate(webauthn_stepup_total[5m])"
              threshold: ">= 0.99"
            - name: "breakglass_audit"
              query: "increase(breakglass_access_total[1h])"
              threshold: ">= 0"
          command: "igctl drill rehearse --env prod --scenario iam-breakglass"
          success_criteria:
            - "breakglass_access_granted == true"
            - "audit_logs_generated == true"
            - "time_limited_access == true"
        auto_validation: true

      G11:
        name: "Data Migration & Backfill Safety"
        owner: "Data Engineering"
        description: "Migration idempotent, shadow reads consistent, N-1 compatible"
        threshold:
          diff_ratio_max: 0.001
          n1_compatibility_hours: 24
          shadow_read_consistency: 0.999
          migration_idempotent: true
        validation:
          method: "migration_validation"
          queries:
            - name: "shadow_read_diff"
              query: "migration_shadow_read_diff_ratio"
              threshold: "<= 0.001"
            - name: "schema_compatibility"
              query: "schema_n1_compatibility_check"
              threshold: "== 1"
          command: "./tools/data/validate-migration-safety.sh --sample-size 10000"
          success_criteria:
            - "diff_ratio <= 0.001"
            - "idempotency_verified == true"
            - "rollback_tested == true"
        auto_validation: true

      G12:
        name: "Third-Party & LLM Cost Health"
        owner: "FinOps Engineering"
        description: "Vendor rate limits healthy, cost spikes contained"
        threshold:
          vendor_error_ratio_max: 0.002
          vendor_latency_p95_ms: 800
          llm_spike_multiplier_max: 2
          rate_limit_headroom_min: 0.2
        validation:
          method: "vendor_health_validation"
          queries:
            - name: "vendor_error_rate"
              query: "sum(rate(vendor_requests_total{status=~'4..|5..'}[5m])) / sum(rate(vendor_requests_total[5m]))"
              threshold: "<= 0.002"
            - name: "vendor_latency_p95"
              query: "histogram_quantile(0.95, rate(vendor_request_duration_seconds_bucket[5m]))"
              threshold: "<= 0.8"
            - name: "llm_cost_spike"
              query: "rate(llm_cost_usd_total[5m]) / rate(llm_cost_usd_total[1h] offset 1h)"
              threshold: "<= 2"
            - name: "rate_limit_headroom"
              query: "vendor_rate_limit_headroom_ratio"
              threshold: ">= 0.2"
          command: "./tools/finops/validate-vendor-health.sh --check-all"
        auto_validation: true

    decision_logic:
      go_criteria:
        required_gates: ["G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8", "G9", "G10", "G11", "G12"]
        allow_manual_override: true
        override_approvers:
          - "engineering-manager"
          - "sre-lead"
          - "cto"
          - "privacy-lead"
          - "data-lead"
        override_requires_justification: true

      no_go_criteria:
        any_critical_gate_failed: ["G1", "G2", "G3", "G9", "G11"]  # Performance, Provenance, Privacy, Data Migration
        security_gate_required: ["G3", "G7", "G10"]  # Provenance, Security, IAM
        cost_gate_required: ["G6", "G12"]  # Cost Guardrails, Vendor Health
        privacy_gate_required: ["G9"]  # Privacy & Data Protection

    approval_workflow:
      required_approvers:
        - role: "Product Manager"
          gate_dependencies: ["G8"]
        - role: "Engineering Manager"
          gate_dependencies: ["G1", "G2", "G4"]
        - role: "SRE Lead"
          gate_dependencies: ["G1", "G5"]
        - role: "Security Lead"
          gate_dependencies: ["G3", "G7"]
        - role: "FinOps Lead"
          gate_dependencies: ["G6"]
        - role: "Support Lead"
          gate_dependencies: ["G8"]

      approval_timeout: "4h"
      emergency_override: true
      audit_log: true

    notification:
      channels:
        - type: "slack"
          webhook_url: "${SLACK_CUTOVER_WEBHOOK}"
          events: ["gate_status_change", "decision_made", "approval_required"]

        - type: "email"
          recipients: ["cutover-team@intelgraph.dev"]
          events: ["final_decision", "emergency_override"]

      templates:
        gate_passed: |
          ✅ Gate {{ .gate_name }} ({{ .gate_id }}) PASSED
          Owner: {{ .owner }}
          Validation: {{ .validation_method }}
          Details: {{ .validation_details }}

        gate_failed: |
          ❌ Gate {{ .gate_name }} ({{ .gate_id }}) FAILED
          Owner: {{ .owner }}
          Threshold: {{ .threshold }}
          Actual: {{ .actual_value }}
          Action Required: {{ .remediation_steps }}

        final_go: |
          🚀 GA CUTOVER: GO DECISION APPROVED
          Release: Sprint 26 GA
          Scheduled: {{ .cutover_time }}
          Approved by: {{ .approvers }}
          Gate Status: {{ .gate_summary }}

        final_no_go: |
          🛑 GA CUTOVER: NO-GO DECISION
          Release: Sprint 26 GA
          Blocked Gates: {{ .failed_gates }}
          Next Review: {{ .next_review_time }}
          Action Items: {{ .action_items }}

  matrix-tracker.ts: |
    // Go/No-Go Matrix Real-time Tracker
    import { EventEmitter } from 'events';
    import { PrometheusApi } from '@prometheus-io/client';
    import { execSync } from 'child_process';

    export interface Gate {
      id: string;
      name: string;
      owner: string;
      description: string;
      threshold: any;
      validation: {
        method: string;
        queries?: Array<{name: string; query: string; threshold: string}>;
        command?: string;
        success_criteria?: string[];
        checklist?: string[];
      };
      auto_validation: boolean;
      status?: 'pending' | 'checking' | 'passed' | 'failed' | 'manual_override';
      last_check?: Date;
      validation_details?: any;
    }

    export interface DecisionMatrix {
      release_info: {
        name: string;
        target_date: string;
        environment: string;
        change_type: string;
      };
      gates: { [key: string]: Gate };
      decision_logic: any;
      approval_workflow: any;
      final_decision?: 'GO' | 'NO-GO' | 'PENDING';
      approvals?: { [role: string]: boolean };
    }

    export class GoNoGoTracker extends EventEmitter {
      private matrix: DecisionMatrix;
      private prometheus: PrometheusApi;
      private validationInterval: NodeJS.Timeout;

      constructor(configPath: string) {
        super();
        this.matrix = this.loadMatrix(configPath);
        this.prometheus = new PrometheusApi({
          endpoint: process.env.PROMETHEUS_URL || 'http://prometheus:9090'
        });

        // Start continuous validation for auto gates
        this.startContinuousValidation();
      }

      private loadMatrix(configPath: string): DecisionMatrix {
        // Load matrix configuration from YAML
        const yaml = require('yaml');
        const fs = require('fs');
        const config = yaml.parse(fs.readFileSync(configPath, 'utf8'));
        return config;
      }

      async validateGate(gateId: string): Promise<boolean> {
        const gate = this.matrix.gates[gateId];
        if (!gate) {
          throw new Error(`Gate ${gateId} not found`);
        }

        gate.status = 'checking';
        gate.last_check = new Date();
        this.emit('gate_status_change', { gate_id: gateId, status: 'checking' });

        try {
          let result: boolean;

          switch (gate.validation.method) {
            case 'prometheus_query':
              result = await this.validatePrometheusQueries(gate);
              break;
            case 'k6_report':
              result = await this.validateK6Report(gate);
              break;
            case 'verify_bundle':
              result = await this.validateProvenance(gate);
              break;
            case 'igctl_status':
            case 'igctl_dr':
              result = await this.validateIgctl(gate);
              break;
            case 'cost_dashboard':
              result = await this.validateCostMetrics(gate);
              break;
            case 'security_check':
              result = await this.validateSecurityMetrics(gate);
              break;
            case 'manual_checklist':
              result = await this.validateManualChecklist(gate);
              break;
            default:
              throw new Error(`Unknown validation method: ${gate.validation.method}`);
          }

          gate.status = result ? 'passed' : 'failed';
          this.emit('gate_status_change', {
            gate_id: gateId,
            status: gate.status,
            details: gate.validation_details
          });

          return result;

        } catch (error) {
          gate.status = 'failed';
          gate.validation_details = { error: error.message };
          this.emit('gate_status_change', { gate_id: gateId, status: 'failed', error: error.message });
          return false;
        }
      }

      private async validatePrometheusQueries(gate: Gate): Promise<boolean> {
        const queries = gate.validation.queries || [];
        let allPassed = true;
        const results: any = {};

        for (const query of queries) {
          try {
            const result = await this.prometheus.query({
              query: query.query,
              time: new Date()
            });

            const value = this.extractMetricValue(result);
            const passed = this.evaluateThreshold(value, query.threshold);

            results[query.name] = { value, threshold: query.threshold, passed };
            if (!passed) allPassed = false;

          } catch (error) {
            results[query.name] = { error: error.message, passed: false };
            allPassed = false;
          }
        }

        gate.validation_details = { prometheus_results: results };
        return allPassed;
      }

      private async validateK6Report(gate: Gate): Promise<boolean> {
        try {
          const command = gate.validation.command || '';
          const output = execSync(command, { encoding: 'utf8' });

          // Parse K6 output for success criteria
          const criteria = gate.validation.success_criteria || [];
          let allMet = true;
          const results: any = {};

          for (const criterion of criteria) {
            // Parse criterion like "all_scenarios_passed == true"
            const [metric, operator, expected] = criterion.split(/\s+/);
            const actual = this.extractFromK6Output(output, metric);
            const met = this.evaluateCondition(actual, operator, expected);

            results[criterion] = { actual, expected, met };
            if (!met) allMet = false;
          }

          gate.validation_details = { k6_results: results, output_summary: this.summarizeK6Output(output) };
          return allMet;

        } catch (error) {
          gate.validation_details = { error: error.message };
          return false;
        }
      }

      private async validateProvenance(gate: Gate): Promise<boolean> {
        try {
          const command = gate.validation.command || '';
          const output = execSync(command, { encoding: 'utf8' });

          // Parse verify-bundle output
          const criteria = gate.validation.success_criteria || [];
          let allMet = true;
          const results: any = {};

          for (const criterion of criteria) {
            const [metric, operator, expected] = criterion.split(/\s+/);
            const actual = this.extractFromVerifyOutput(output, metric);
            const met = this.evaluateCondition(actual, operator, expected);

            results[criterion] = { actual, expected, met };
            if (!met) allMet = false;
          }

          gate.validation_details = { provenance_results: results };
          return allMet;

        } catch (error) {
          gate.validation_details = { error: error.message };
          return false;
        }
      }

      private async validateIgctl(gate: Gate): Promise<boolean> {
        try {
          const command = gate.validation.command || '';
          const output = execSync(command, { encoding: 'utf8' });
          const data = JSON.parse(output);

          const criteria = gate.validation.success_criteria || [];
          let allMet = true;
          const results: any = {};

          for (const criterion of criteria) {
            const [path, operator, expected] = criterion.split(/\s+/);
            const actual = this.getNestedValue(data, path);
            const met = this.evaluateCondition(actual, operator, expected);

            results[criterion] = { actual, expected, met };
            if (!met) allMet = false;
          }

          gate.validation_details = { igctl_results: results, raw_data: data };
          return allMet;

        } catch (error) {
          gate.validation_details = { error: error.message };
          return false;
        }
      }

      private async validateCostMetrics(gate: Gate): Promise<boolean> {
        return this.validatePrometheusQueries(gate); // Reuse Prometheus validation
      }

      private async validateSecurityMetrics(gate: Gate): Promise<boolean> {
        return this.validatePrometheusQueries(gate); // Reuse Prometheus validation
      }

      private async validateManualChecklist(gate: Gate): Promise<boolean> {
        // Manual gates require external approval
        const checklist = gate.validation.checklist || [];
        gate.validation_details = {
          checklist_items: checklist.map(item => ({ item, status: 'pending' })),
          requires_manual_approval: true
        };
        return false; // Always requires manual intervention
      }

      async validateAllGates(): Promise<{ passed: string[], failed: string[], manual: string[] }> {
        const passed: string[] = [];
        const failed: string[] = [];
        const manual: string[] = [];

        for (const [gateId, gate] of Object.entries(this.matrix.gates)) {
          if (gate.auto_validation) {
            const result = await this.validateGate(gateId);
            if (result) {
              passed.push(gateId);
            } else {
              failed.push(gateId);
            }
          } else {
            manual.push(gateId);
          }
        }

        return { passed, failed, manual };
      }

      async makeDecision(): Promise<'GO' | 'NO-GO' | 'PENDING'> {
        const validation = await this.validateAllGates();
        const required = this.matrix.decision_logic.go_criteria.required_gates;

        // Check if all required gates are passed
        const allRequiredPassed = required.every((gateId: string) =>
          validation.passed.includes(gateId) ||
          this.matrix.gates[gateId].status === 'manual_override'
        );

        if (allRequiredPassed && validation.manual.length === 0) {
          this.matrix.final_decision = 'GO';
        } else if (validation.failed.some((gateId: string) =>
          this.matrix.decision_logic.no_go_criteria.any_critical_gate_failed.includes(gateId)
        )) {
          this.matrix.final_decision = 'NO-GO';
        } else {
          this.matrix.final_decision = 'PENDING';
        }

        this.emit('decision_made', {
          decision: this.matrix.final_decision,
          validation_summary: validation,
          timestamp: new Date()
        });

        return this.matrix.final_decision;
      }

      private startContinuousValidation(): void {
        this.validationInterval = setInterval(async () => {
          for (const [gateId, gate] of Object.entries(this.matrix.gates)) {
            if (gate.auto_validation && gate.status !== 'passed') {
              await this.validateGate(gateId);
            }
          }
        }, 30000); // Validate every 30 seconds
      }

      // Utility methods
      private extractMetricValue(result: any): number {
        // Extract value from Prometheus result
        if (result.data?.result?.[0]?.value?.[1]) {
          return parseFloat(result.data.result[0].value[1]);
        }
        return 0;
      }

      private evaluateThreshold(value: number, threshold: string): boolean {
        const match = threshold.match(/([><=!]+)\s*([0-9.]+)/);
        if (!match) return false;

        const operator = match[1];
        const expected = parseFloat(match[2]);

        switch (operator) {
          case '>=': return value >= expected;
          case '<=': return value <= expected;
          case '>': return value > expected;
          case '<': return value < expected;
          case '==': return Math.abs(value - expected) < 0.001;
          case '!=': return Math.abs(value - expected) >= 0.001;
          default: return false;
        }
      }

      private evaluateCondition(actual: any, operator: string, expected: string): boolean {
        switch (operator) {
          case '==': return String(actual) === expected;
          case '!=': return String(actual) !== expected;
          case '>=': return Number(actual) >= Number(expected);
          case '<=': return Number(actual) <= Number(expected);
          case '>': return Number(actual) > Number(expected);
          case '<': return Number(actual) < Number(expected);
          default: return false;
        }
      }

      private extractFromK6Output(output: string, metric: string): any {
        // Parse K6 output for specific metrics
        // Implementation depends on K6 output format
        return null;
      }

      private extractFromVerifyOutput(output: string, metric: string): any {
        // Parse verify-bundle output for specific metrics
        return null;
      }

      private getNestedValue(obj: any, path: string): any {
        return path.split('.').reduce((current, key) => current?.[key], obj);
      }

      private summarizeK6Output(output: string): string {
        // Summarize K6 output for display
        return output.substring(0, 500) + '...';
      }

      stop(): void {
        if (this.validationInterval) {
          clearInterval(this.validationInterval);
        }
      }
    }