#!/usr/bin/env node

/**
 * IntelGraph Merge Metrics Dashboard
 * Comprehensive monitoring and analytics for PR merge velocity and CI health
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

class MergeMetricsDashboard {
  constructor() {
    this.startTime = new Date();
    this.metrics = {
      totalPRs: 0,
      mergedToday: 0,
      autoMergeEnabled: 0,
      ciHealthScore: 0,
      avgMergeTime: 0,
      conflictRate: 0,
      staleCount: 0,
    };
  }

  async collectMetrics() {
    // console.log('🔍 Collecting merge metrics...');

    try {
      // Total PRs
      const totalPRs = JSON.parse(
        execSync('gh pr list --state open --json number', { encoding: 'utf8' }),
      );
      this.metrics.totalPRs = totalPRs.length;

      // PRs merged today
      const today = new Date().toISOString().split('T')[0];
      const mergedToday = JSON.parse(
        execSync(`gh pr list --state merged --json mergedAt,number --limit 100`, {
          encoding: 'utf8',
        }),
      ).filter((pr) => pr.mergedAt && pr.mergedAt.startsWith(today));
      this.metrics.mergedToday = mergedToday.length;

      // Auto-merge enabled PRs
      const autoMergePRs = JSON.parse(
        execSync('gh pr list --state open --json number,autoMergeRequest', { encoding: 'utf8' }),
      ).filter((pr) => pr.autoMergeRequest !== null);
      this.metrics.autoMergeEnabled = autoMergePRs.length;

      // CI health score (success rate of last 50 runs)
      const recentRuns = JSON.parse(
        execSync('gh run list --limit 50 --json conclusion', { encoding: 'utf8' }),
      );
      const successfulRuns = recentRuns.filter((run) => run.conclusion === 'success').length;
      this.metrics.ciHealthScore = Math.round((successfulRuns / recentRuns.length) * 100);

      // Stale PRs (>14 days old)
      const stalePRs = JSON.parse(
        execSync('gh pr list --state open --json number,updatedAt', { encoding: 'utf8' }),
      ).filter((pr) => {
        const daysSinceUpdate =
          (Date.now() - new Date(pr.updatedAt).getTime()) / (1000 * 60 * 60 * 24);
        return daysSinceUpdate > 14;
      });
      this.metrics.staleCount = stalePRs.length;

      // Average merge time (sample of recent merges)
      const recentMerges = JSON.parse(
        execSync('gh pr list --state merged --json createdAt,mergedAt --limit 20', {
          encoding: 'utf8',
        }),
      ).filter((pr) => pr.createdAt && pr.mergedAt);

      if (recentMerges.length > 0) {
        const mergeTimes = recentMerges.map((pr) => {
          const created = new Date(pr.createdAt);
          const merged = new Date(pr.mergedAt);
          return (merged - created) / (1000 * 60 * 60); // hours
        });
        this.metrics.avgMergeTime =
          Math.round((mergeTimes.reduce((a, b) => a + b, 0) / mergeTimes.length) * 10) / 10;
      }
    } catch (error) {
      // console.error('Error collecting metrics:', error.message);
    }
  }

  generateReport() {
    const report = `
# 📊 IntelGraph Merge Metrics Dashboard

**Generated**: ${this.startTime.toISOString()}

## 🎯 Key Performance Indicators

| Metric | Value | Status |
|--------|-------|--------|
| **Open PRs** | ${this.metrics.totalPRs} | ${this.getStatusIcon(this.metrics.totalPRs < 30)} |
| **Merged Today** | ${this.metrics.mergedToday} | ${this.getStatusIcon(this.metrics.mergedToday > 0)} |
| **Auto-merge Enabled** | ${this.metrics.autoMergeEnabled} | ${this.getStatusIcon(this.metrics.autoMergeEnabled > 0)} |
| **CI Health Score** | ${this.metrics.ciHealthScore}% | ${this.getStatusIcon(this.metrics.ciHealthScore > 80)} |
| **Avg Merge Time** | ${this.metrics.avgMergeTime}h | ${this.getStatusIcon(this.metrics.avgMergeTime < 48)} |
| **Stale PRs** | ${this.metrics.staleCount} | ${this.getStatusIcon(this.metrics.staleCount < 5)} |

## 📈 Health Assessment

${this.generateHealthAssessment()}

## 🚀 Recommendations

${this.generateRecommendations()}

## 🔧 Quick Actions

\`\`\`bash
# Enable auto-merge on all ready PRs
gh pr list --state open --json number,mergeable,isDraft | \\
  jq -r '.[] | select(.mergeable == "MERGEABLE" and (.isDraft | not)) | .number' | \\
  xargs -I {} gh pr merge {} --auto --squash

# Check CI health
gh run list --limit 20 --json conclusion,workflowName

# Review stale PRs  
gh pr list --state open --json number,title,updatedAt | \\
  jq '.[] | select((now - (.updatedAt | fromdateiso8601)) > (14 * 86400))'
\`\`\`

---
*Dashboard auto-generated by IntelGraph Release Engineering*
`;

    return report;
  }

  getStatusIcon(isGood) {
    return isGood ? '✅' : '⚠️';
  }

  generateHealthAssessment() {
    const score = this.calculateOverallHealth();

    if (score >= 85) {
      return '🟢 **EXCELLENT** - Repository health is optimal. Merge velocity is high, CI is stable.';
    } else if (score >= 70) {
      return '🟡 **GOOD** - Generally healthy with minor areas for improvement.';
    } else if (score >= 50) {
      return '🟠 **NEEDS ATTENTION** - Several metrics below optimal. Consider intervention.';
    } else {
      return '🔴 **CRITICAL** - Multiple health indicators failing. Immediate action required.';
    }
  }

  calculateOverallHealth() {
    const weights = {
      prCount: this.metrics.totalPRs < 30 ? 20 : Math.max(0, 20 - (this.metrics.totalPRs - 30)),
      ciHealth: this.metrics.ciHealthScore * 0.3,
      autoMerge: Math.min(
        20,
        (this.metrics.autoMergeEnabled / Math.max(1, this.metrics.totalPRs)) * 20,
      ),
      staleness: Math.max(0, 20 - this.metrics.staleCount * 2),
      velocity: Math.min(10, this.metrics.mergedToday * 2),
    };

    return Math.round(Object.values(weights).reduce((a, b) => a + b, 0));
  }

  generateRecommendations() {
    const recommendations = [];

    if (this.metrics.totalPRs > 30) {
      recommendations.push(
        '🔄 **High PR Count**: Consider batch processing session or stale PR cleanup',
      );
    }

    if (this.metrics.ciHealthScore < 80) {
      recommendations.push('🏗️ **CI Health**: Review failing workflows and implement fixes');
    }

    if (this.metrics.staleCount > 5) {
      recommendations.push('📅 **Stale PRs**: Review and close/update PRs older than 14 days');
    }

    if (this.metrics.autoMergeEnabled < this.metrics.totalPRs * 0.5) {
      recommendations.push('🤖 **Auto-merge**: Enable auto-merge on more ready PRs');
    }

    if (this.metrics.avgMergeTime > 72) {
      recommendations.push('⏱️ **Merge Time**: Review PR approval and merge processes');
    }

    return recommendations.length > 0
      ? recommendations.map((r) => `- ${r}`).join('\n')
      : '✅ No immediate recommendations - system is healthy!';
  }

  async saveReport(outputPath) {
    const report = this.generateReport();
    fs.writeFileSync(outputPath, report);
    // console.log(`📝 Report saved to ${outputPath}`);
    return report;
  }

  async sendSlackNotification(webhookUrl) {
    if (!webhookUrl) return;

    const healthScore = this.calculateOverallHealth();
    const color = healthScore >= 80 ? 'good' : healthScore >= 60 ? 'warning' : 'danger';

    const payload = {
      attachments: [
        {
          color: color,
          title: '📊 IntelGraph Merge Metrics Report',
          fields: [
            { title: 'Open PRs', value: this.metrics.totalPRs.toString(), short: true },
            { title: 'CI Health', value: `${this.metrics.ciHealthScore}%`, short: true },
            { title: 'Merged Today', value: this.metrics.mergedToday.toString(), short: true },
            { title: 'Auto-merge', value: this.metrics.autoMergeEnabled.toString(), short: true },
          ],
          footer: 'IntelGraph Release Engineering',
          ts: Math.floor(Date.now() / 1000),
        },
      ],
    };

    // Would send to Slack webhook if URL provided
    // console.log('📱 Slack notification payload prepared:', JSON.stringify(payload, null, 2));
  }
}

// CLI execution
async function main() {
  const dashboard = new MergeMetricsDashboard();

  // console.log('🚀 Starting IntelGraph Merge Metrics Dashboard...');

  await dashboard.collectMetrics();

  const outputPath = path.join(__dirname, '..', 'docs', 'MERGE_METRICS.md');
  await dashboard.saveReport(outputPath);

  // Optional Slack notification
  const slackWebhook = process.env.SLACK_WEBHOOK_URL;
  if (slackWebhook) {
    await dashboard.sendSlackNotification(slackWebhook);
  }

  // console.log('✅ Merge metrics dashboard complete!');
  // console.log(`📊 Overall Health Score: ${dashboard.calculateOverallHealth()}/100`);
}

if (require.main === module) {
  main().catch(console.error);
}

export default MergeMetricsDashboard;
