name: Global Absorption v2 - Always Green Repository

on:
  schedule:
    # Every 4 hours during business days
    - cron: '0 */4 * * 1-5'
    # Every 8 hours on weekends
    - cron: '0 */8 * * 0,6'
  workflow_dispatch:
    inputs:
      batch_size:
        description: 'Number of PRs to process per batch'
        required: false
        default: '20'
      max_batches:
        description: 'Maximum number of batches to run'
        required: false
        default: '10'
      dry_run:
        description: 'Run in dry-run mode (no actual changes)'
        required: false
        default: 'false'

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write

jobs:
  global-absorption:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18.20.4'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq bc
        npm ci --no-audit --no-fund || npm install --no-audit --no-fund
    
    - name: Configure Git
      run: |
        git config --global user.name "global-absorption-bot"
        git config --global user.email "absorption@intelgraph.com"
        git config --global rerere.enabled true
        git config --global rerere.autoupdate true
        git config --global pull.rebase true
    
    - name: Repository Health Assessment
      id: health_check
      run: |
        echo "ðŸ” Assessing repository health..."
        
        # Get current repository status
        TOTAL_PRS=$(gh pr list --state open --limit 1000 --json number | jq length)
        AUTO_MERGE_COUNT=$(gh pr list --state open --limit 1000 --json number,autoMergeRequest | jq '[.[] | select(.autoMergeRequest)] | length')
        MERGEABLE_COUNT=$(gh pr list --state open --limit 1000 --json number,mergeable | jq '[.[] | select(.mergeable == "MERGEABLE")] | length')
        
        # Calculate metrics
        REMAINING=$((TOTAL_PRS - AUTO_MERGE_COUNT))
        COVERAGE=$(echo "$AUTO_MERGE_COUNT * 100 / $TOTAL_PRS" | bc)
        
        echo "ðŸ“Š Repository Health Metrics:"
        echo "  Total PRs: $TOTAL_PRS"
        echo "  Auto-merge enabled: $AUTO_MERGE_COUNT"
        echo "  Mergeable PRs: $MERGEABLE_COUNT"
        echo "  Remaining to process: $REMAINING"
        echo "  Coverage: $COVERAGE%"
        
        # Export for next steps
        echo "total_prs=$TOTAL_PRS" >> $GITHUB_OUTPUT
        echo "auto_merge_count=$AUTO_MERGE_COUNT" >> $GITHUB_OUTPUT
        echo "mergeable_count=$MERGEABLE_COUNT" >> $GITHUB_OUTPUT
        echo "remaining=$REMAINING" >> $GITHUB_OUTPUT
        echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
        
        # Determine if processing is needed
        if [ "$REMAINING" -gt 0 ]; then
          echo "needs_processing=true" >> $GITHUB_OUTPUT
        else
          echo "needs_processing=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Automated PR Processing
      if: steps.health_check.outputs.needs_processing == 'true'
      env:
        BATCH_SIZE: ${{ github.event.inputs.batch_size || '20' }}
        MAX_BATCHES: ${{ github.event.inputs.max_batches || '10' }}
        DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "ðŸš€ Starting automated PR processing..."
        echo "  Batch size: $BATCH_SIZE"
        echo "  Max batches: $MAX_BATCHES"
        echo "  Dry run: $DRY_RUN"
        
        BATCH_NUM=1
        PROCESSED_TOTAL=0
        
        while [ $BATCH_NUM -le $MAX_BATCHES ]; do
          echo ""
          echo "=== BATCH $BATCH_NUM: Processing up to $BATCH_SIZE PRs ==="
          
          # Get PRs that need processing (mergeable first)
          BATCH_PRS=$(gh pr list --state open --limit 1000 --json number,title,mergeable,autoMergeRequest,isDraft \
          | jq -r --arg batch_size "$BATCH_SIZE" '
            [.[] 
            | select(.isDraft|not) 
            | select(.autoMergeRequest == null)
            | select(.mergeable == "MERGEABLE" or .mergeable == "CONFLICTING")
            ] 
            | sort_by(.mergeable == "MERGEABLE" | not)  # Mergeable first
            | limit($batch_size|tonumber; .[])
            | "\(.number)\t\(.title)\t\(.mergeable)"
          ')
          
          if [ -z "$BATCH_PRS" ]; then
            echo "âœ… No more PRs to process - all done!"
            break
          fi
          
          BATCH_COUNT=$(echo "$BATCH_PRS" | wc -l)
          echo "Processing $BATCH_COUNT PRs in batch $BATCH_NUM"
          
          # Process each PR in the batch
          echo "$BATCH_PRS" | while IFS=$'\t' read -r PR_NUM TITLE MERGEABLE; do
            echo "  Processing PR #$PR_NUM ($MERGEABLE): $TITLE"
            
            if [ "$DRY_RUN" = "true" ]; then
              echo "    ðŸ” DRY RUN - would process PR #$PR_NUM"
              continue
            fi
            
            if [ "$MERGEABLE" = "MERGEABLE" ]; then
              # Enable auto-merge on mergeable PRs
              if gh pr merge "$PR_NUM" --auto --squash 2>/dev/null || gh pr merge "$PR_NUM" --auto --merge 2>/dev/null; then
                echo "    âœ… Auto-merge enabled"
                gh pr edit "$PR_NUM" --add-label "processed:global-absorption-v2,status:auto-merge" 2>/dev/null || true
              else
                echo "    âš ï¸ Auto-merge failed - may need review"
                gh pr edit "$PR_NUM" --add-label "needs:review,processed:failed" 2>/dev/null || true
              fi
            else
              # Mark conflicted PRs for manual resolution
              echo "    ðŸ”§ Conflicted PR - marking for manual resolution"
              gh pr edit "$PR_NUM" --add-label "status:conflicted,needs:manual-rebase" 2>/dev/null || true
              
              # Add helpful comment if not already commented by bot
              EXISTING_COMMENTS=$(gh pr view "$PR_NUM" --json comments --jq '.comments[] | select(.author.login == "github-actions[bot]") | length')
              if [ "$EXISTING_COMMENTS" -eq 0 ]; then
                gh pr comment "$PR_NUM" --body "ðŸ¤– **Automated Conflict Resolution Required**

This PR has merge conflicts detected by the Global Absorption Protocol v2.

**Resolution steps:**
1. \`git fetch origin main\`
2. \`git checkout <your-branch>\`  
3. \`git rebase origin/main\`
4. Resolve conflicts and \`git add .\`
5. \`git rebase --continue\`
6. \`git push --force-with-lease\`

Auto-merge will be enabled automatically once conflicts are resolved and CI passes.

*Generated by Global Absorption Protocol v2 - Always Green Repository*" 2>/dev/null || true
              fi
            fi
            
            sleep 1  # Rate limiting
          done
          
          PROCESSED_TOTAL=$((PROCESSED_TOTAL + BATCH_COUNT))
          BATCH_NUM=$((BATCH_NUM + 1))
          
          # Rate limiting between batches
          sleep 5
        done
        
        echo ""
        echo "ðŸ“Š Processing Summary:"
        echo "  Batches completed: $((BATCH_NUM - 1))"
        echo "  Total PRs processed: $PROCESSED_TOTAL"
    
    - name: Update Repository Health Metrics
      if: always()
      run: |
        echo "ðŸ“ˆ Updating final repository health metrics..."
        
        # Generate comprehensive health report
        FINAL_TOTAL=$(gh pr list --state open --limit 1000 --json number | jq length)
        FINAL_AUTO=$(gh pr list --state open --limit 1000 --json number,autoMergeRequest | jq '[.[] | select(.autoMergeRequest)] | length')
        FINAL_COVERAGE=$(echo "$FINAL_AUTO * 100 / $FINAL_TOTAL" | bc)
        FINAL_REMAINING=$((FINAL_TOTAL - FINAL_AUTO))
        
        # Update metrics dashboard
        if [ -f "scripts/merge-metrics-dashboard.js" ]; then
          node scripts/merge-metrics-dashboard.js || echo "Dashboard update completed"
        fi
        
        echo "ðŸ“Š Final Repository State:"
        echo "  Total PRs: $FINAL_TOTAL"
        echo "  Auto-merge enabled: $FINAL_AUTO"
        echo "  Coverage: $FINAL_COVERAGE%"
        echo "  Still remaining: $FINAL_REMAINING"
        
        # Create workflow summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # ðŸ¤– Global Absorption v2 - Execution Summary
        
        **Repository Health Metrics:**
        - Total PRs: $FINAL_TOTAL
        - Auto-merge enabled: $FINAL_AUTO  
        - Coverage: $FINAL_COVERAGE%
        - Remaining to process: $FINAL_REMAINING
        
        **Workflow Status:** $(if [ "$FINAL_REMAINING" -eq 0 ]; then echo "âœ… Complete - 100% Coverage Achieved!"; else echo "ðŸ”„ In Progress - Continue Processing"; fi)
        
        **Next Steps:** 
        $(if [ "$FINAL_REMAINING" -eq 0 ]; then 
          echo "- âœ… Repository is fully processed and self-healing"
          echo "- âœ… All PRs have auto-merge enabled or are properly labeled"  
          echo "- âœ… Continuous monitoring active"
        else
          echo "- ðŸ”„ $FINAL_REMAINING PRs still need processing"
          echo "- ðŸ• Next automated run will continue processing"
          echo "- ðŸ”§ Conflicted PRs marked for manual resolution"
        fi)
        
        *Generated by Global Absorption Protocol v2*
        EOF
    
    - name: Alert on High Backlog
      if: steps.health_check.outputs.remaining > 50
      run: |
        echo "âš ï¸ High backlog detected: ${{ steps.health_check.outputs.remaining }} PRs remaining"
        echo "Consider running manual processing or increasing automation frequency"
        
        # Could send Slack/email alerts here if webhooks configured
        # curl -X POST -H 'Content-type: application/json' --data '{"text":"High PR backlog detected in ${{ github.repository }}: ${{ steps.health_check.outputs.remaining }} PRs need processing"}' $SLACK_WEBHOOK_URL

  repository-maintenance:
    runs-on: ubuntu-latest
    needs: global-absorption
    if: always()
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Repository Cleanup
      run: |
        echo "ðŸ§¹ Performing repository maintenance..."
        
        # Clean up old workflow runs (keep last 50)
        gh run list --limit 100 --json databaseId,status,conclusion \
        | jq -r '.[] | select(.conclusion == "completed" or .conclusion == "cancelled" or .conclusion == "failure") | .databaseId' \
        | tail -n +51 \
        | head -20 \
        | xargs -I {} gh run delete {} 2>/dev/null || true
        
        # Clean up old branch refs if they exist
        git remote prune origin || true
        
        echo "âœ… Repository maintenance complete"