package sdn

import (
	"bytes"
	"compress/gzip"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"io"
	"sort"
)

// ErrIntegrityMismatch indicates that decoded bytes failed hash validation.
var ErrIntegrityMismatch = errors.New("sdn: integrity mismatch")

// EncodeDeltasToWire serialises deltas into a compact gzip-compressed JSON wire format and returns the payload and its integrity hash.
func EncodeDeltasToWire(deltas []Delta) ([]byte, string, error) {
	ordered := append([]Delta(nil), deltas...)
	sort.Slice(ordered, func(i, j int) bool {
		if ordered[i].LamportTime == ordered[j].LamportTime {
			return ordered[i].ID < ordered[j].ID
		}
		return ordered[i].LamportTime < ordered[j].LamportTime
	})

	raw, err := json.Marshal(ordered)
	if err != nil {
		return nil, "", err
	}

	var buf bytes.Buffer
	gz := gzip.NewWriter(&buf)
	if _, err := gz.Write(raw); err != nil {
		return nil, "", err
	}
	if err := gz.Close(); err != nil {
		return nil, "", err
	}

	hash := sha256.Sum256(buf.Bytes())
	return buf.Bytes(), hex.EncodeToString(hash[:]), nil
}

// DecodeDeltasFromWire inflates data generated by EncodeDeltasToWire and validates its hash.
func DecodeDeltasFromWire(data []byte, expectedHash string) ([]Delta, error) {
	hash := sha256.Sum256(data)
	if expectedHash != "" && hex.EncodeToString(hash[:]) != expectedHash {
		return nil, ErrIntegrityMismatch
	}
	reader, err := gzip.NewReader(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}
	defer reader.Close()

	payload, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var deltas []Delta
	if err := json.Unmarshal(payload, &deltas); err != nil {
		return nil, err
	}
	return deltas, nil
}
