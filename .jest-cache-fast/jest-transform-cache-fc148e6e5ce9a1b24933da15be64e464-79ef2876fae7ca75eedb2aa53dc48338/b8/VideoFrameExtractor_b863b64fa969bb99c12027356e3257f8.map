{"file":"/Users/brianlong/Developer/summit/server/src/ai/engines/VideoFrameExtractor.ts","mappings":"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","names":[],"sources":["/Users/brianlong/Developer/summit/server/src/ai/engines/VideoFrameExtractor.ts"],"sourcesContent":["import ffmpeg from 'fluent-ffmpeg';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport pino from 'pino';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst logger = pino({ name: 'VideoFrameExtractor' });\n\nexport interface FrameExtractionOptions {\n  frameRate?: number; // Frames per second (e.g., 1 for 1fps)\n  interval?: number; // Extract a frame every X seconds\n  outputDir?: string; // Directory to save extracted frames\n  outputFormat?: string; // e.g., 'png', 'jpg'\n  startTime?: number; // Start time in seconds\n  endTime?: number; // End time in seconds\n  extractAudio?: boolean; // Whether to extract audio stream\n}\n\nexport interface ExtractedFrame {\n  framePath: string; // Path to the extracted image file\n  timestamp: number; // Timestamp of the frame in seconds\n  frameNumber: number; // Sequential frame number\n}\n\nexport interface ExtractedAudio {\n  audioPath: string; // Path to the extracted audio file\n  duration: number; // Duration of the audio in seconds\n}\n\nexport class VideoFrameExtractor {\n  private ffmpegPath: string;\n  private ffprobePath: string;\n  private tempDir: string;\n\n  constructor(ffmpegPath: string, ffprobePath: string, tempDir: string) {\n    this.ffmpegPath = ffmpegPath;\n    this.ffprobePath = ffprobePath;\n    this.tempDir = tempDir;\n\n    ffmpeg.setFfmpegPath(this.ffmpegPath);\n    ffmpeg.setFfprobePath(this.ffprobePath);\n  }\n\n  /**\n   * Extracts frames and optionally audio from a video file.\n   * @param videoPath Absolute path to the input video file.\n   * @param options Frame extraction options.\n   * @returns An object containing extracted frames and audio (if requested).\n   */\n  async extract(\n    videoPath: string,\n    options: FrameExtractionOptions = {}\n  ): Promise<{ frames: ExtractedFrame[]; audio?: ExtractedAudio }> {\n    const {\n      frameRate,\n      interval,\n      outputDir = path.join(this.tempDir, `frames-${uuidv4()}`),\n      outputFormat = 'png',\n      startTime,\n      endTime,\n      extractAudio = false,\n    } = options;\n\n    await fs.mkdir(outputDir, { recursive: true });\n    logger.info(`Extracting frames to: ${outputDir}`);\n\n    const frames: ExtractedFrame[] = [];\n    let audio: ExtractedAudio | undefined;\n    let frameCount = 0;\n\n    return new Promise(async (resolve, reject) => {\n      const command = ffmpeg(videoPath);\n\n      if (startTime !== undefined) {\n        command.seekInput(startTime);\n      }\n      if (endTime !== undefined) {\n        command.duration(endTime - (startTime || 0));\n      }\n\n      if (frameRate) {\n        command.fps(frameRate);\n      } else if (interval) {\n        command.addOption('-vf', `fps=1/${interval}`);\n      } else {\n        // Default to 1 frame per second if neither frameRate nor interval is specified\n        command.fps(1);\n      }\n\n      command\n        .output(`${outputDir}/frame-%s.${outputFormat}`)\n        .on('filenames', (filenames: string[]) => {\n          filenames.forEach((filename) => {\n            const timestampMatch = filename.match(/frame-(\\d+(\\.\\d+)?)\\./);\n            const timestamp = timestampMatch ? parseFloat(timestampMatch[1]) : 0; // Extract timestamp from filename\n            frames.push({\n              framePath: path.join(outputDir, filename),\n              timestamp: timestamp,\n              frameNumber: frameCount++, // Simple sequential numbering\n            });\n          });\n        })\n        .on('end', async () => {\n          logger.info(`Finished frame extraction for ${videoPath}. Extracted ${frames.length} frames.`);\n          if (extractAudio) {\n            try {\n              audio = await this.extractAudioStream(videoPath, outputDir, startTime, endTime);\n              logger.info(`Finished audio extraction for ${videoPath}.`);\n            } catch (audioErr) {\n              logger.error(`Failed to extract audio: ${audioErr}`);\n              // Continue without audio if extraction fails\n            }\n          }\n          resolve({ frames, audio });\n        })\n        .on('error', (err: Error) => {\n          logger.error(`Error during frame extraction for ${videoPath}: ${err.message}`);\n          reject(err);\n        })\n        .run();\n    });\n  }\n\n  /**\n   * Extracts the audio stream from a video file.\n   * @param videoPath Absolute path to the input video file.\n   * @param outputDir Directory to save the extracted audio file.\n   * @param startTime Start time in seconds.\n   * @param endTime End time in seconds.\n   * @returns Path to the extracted audio file.\n   */\n  private async extractAudioStream(\n    videoPath: string,\n    outputDir: string,\n    startTime?: number,\n    endTime?: number\n  ): Promise<ExtractedAudio> {\n    const audioFileName = `audio-${uuidv4()}.mp3`;\n    const audioPath = path.join(outputDir, audioFileName);\n\n    return new Promise((resolve, reject) => {\n      const command = ffmpeg(videoPath);\n\n      if (startTime !== undefined) {\n        command.seekInput(startTime);\n      }\n      if (endTime !== undefined) {\n        command.duration(endTime - (startTime || 0));\n      }\n\n      command\n        .output(audioPath)\n        .noVideo()\n        .audioCodec('libmp3lame')\n        .on('end', async () => {\n          // Get audio duration\n          const metadata = await this.getVideoMetadata(videoPath);\n          const duration = metadata.format.duration || 0;\n          resolve({ audioPath, duration });\n        })\n        .on('error', (err: Error) => {\n          reject(err);\n        })\n        .run();\n    });\n  }\n\n  /**\n   * Gets metadata of a video file using ffprobe.\n   * @param videoPath Absolute path to the video file.\n   * @returns Video metadata.\n   */\n  private async getVideoMetadata(videoPath: string): Promise<ffmpeg.FfprobeData> {\n    return new Promise((resolve, reject) => {\n      ffmpeg.ffprobe(videoPath, (err, metadata) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(metadata);\n        }\n      });\n    });\n  }\n\n  /**\n   * Cleans up temporary directories created during extraction.\n   * @param dirPath Path to the directory to remove.\n   */\n  async cleanup(dirPath: string): Promise<void> {\n    try {\n      await fs.rm(dirPath, { recursive: true, force: true });\n      logger.info(`Cleaned up temporary directory: ${dirPath}`);\n    } catch (error) {\n      logger.error(`Failed to clean up directory ${dirPath}: ${error}`);\n    }\n  }\n}\n"],"version":3}