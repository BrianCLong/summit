d26c5160982609602e017957133ee334
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha256Hex = sha256Hex;
exports.leafHash = leafHash;
exports.buildMerkle = buildMerkle;
exports.proofForLeaf = proofForLeaf;
exports.verifyProof = verifyProof;
const crypto_1 = require("crypto");
function sha256Hex(buf) {
    const h = (0, crypto_1.createHash)('sha256');
    h.update(buf);
    return h.digest('hex');
}
// Deterministic leaf encoding for a step
function leafHash(step) {
    const s = JSON.stringify(step, Object.keys(step).sort());
    return sha256Hex(Buffer.from(s));
}
function buildMerkle(leavesHex) {
    if (leavesHex.length === 0)
        return { root: sha256Hex(Buffer.from('EMPTY')), layers: [[]] };
    let layer = leavesHex.slice();
    const layers = [layer];
    while (layer.length > 1) {
        const next = [];
        for (let i = 0; i < layer.length; i += 2) {
            const a = layer[i];
            const b = i + 1 < layer.length ? layer[i + 1] : layer[i]; // duplicate last if odd
            next.push(sha256Hex(Buffer.from(a + b)));
        }
        layer = next;
        layers.push(layer);
    }
    return { root: layer[0], layers };
}
function proofForLeaf(index, layers) {
    const path = [];
    let idx = index;
    for (let L = 0; L < layers.length - 1; L++) {
        const layer = layers[L];
        const isRight = idx % 2 === 1;
        const siblingIdx = isRight ? idx - 1 : idx + 1 >= layer.length ? idx : idx + 1;
        const dir = isRight ? 'L' : 'R';
        path.push({ dir, hash: layer[siblingIdx] });
        idx = Math.floor(idx / 2);
    }
    return path;
}
function verifyProof(leaf, path, expectedRoot) {
    let h = leaf;
    for (const p of path) {
        h = p.dir === 'L' ? sha256Hex(Buffer.from(p.hash + h)) : sha256Hex(Buffer.from(h + p.hash));
    }
    return h === expectedRoot;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2JyaWFubG9uZy9EZXZlbG9wZXIvc3VtbWl0L3BhY2thZ2VzL3Byb3YtbGVkZ2VyL3NyYy9tZXJrbGUudHMiLCJtYXBwaW5ncyI6Ijs7QUFDQSw4QkFFQztBQUdELDRCQUdDO0FBRUQsa0NBY0M7QUFFRCxvQ0FZQztBQUVELGtDQU1DO0FBL0NELG1DQUFvQztBQUNwQyxTQUFnQixTQUFTLENBQUMsR0FBb0I7SUFDNUMsTUFBTSxDQUFDLEdBQUcsSUFBQSxtQkFBVSxFQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN4RSxDQUFDO0FBRUQseUNBQXlDO0FBQ3pDLFNBQWdCLFFBQVEsQ0FBQyxJQUFTO0lBQ2hDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN6RCxPQUFPLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxTQUFtQjtJQUM3QyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQztRQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRyxNQUFNLEVBQUUsQ0FBRSxFQUFFLENBQUUsRUFBRSxDQUFDO0lBQzlGLElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUM5QixNQUFNLE1BQU0sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUN4QixNQUFNLElBQUksR0FBYSxFQUFFLENBQUM7UUFDMUIsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUMsQ0FBQyxJQUFFLENBQUMsRUFBQyxDQUFDO1lBQ2hDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLHdCQUF3QjtZQUM5RSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUNELEtBQUssR0FBRyxJQUFJLENBQUM7UUFBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFDRCxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQztBQUNwQyxDQUFDO0FBRUQsU0FBZ0IsWUFBWSxDQUFDLEtBQWEsRUFBRSxNQUFrQjtJQUM1RCxNQUFNLElBQUksR0FBaUMsRUFBRSxDQUFDO0lBQzlDLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQztJQUNoQixLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsTUFBTSxDQUFDLE1BQU0sR0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsQ0FBQztRQUNwQyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEIsTUFBTSxPQUFPLEdBQUcsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUIsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFDLENBQUMsQ0FBQztRQUN6RSxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUMsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRCxTQUFnQixXQUFXLENBQUMsSUFBWSxFQUFFLElBQWtDLEVBQUUsWUFBb0I7SUFDaEcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ2IsS0FBSyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNyQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlGLENBQUM7SUFDRCxPQUFPLENBQUMsS0FBSyxZQUFZLENBQUM7QUFDNUIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvYnJpYW5sb25nL0RldmVsb3Blci9zdW1taXQvcGFja2FnZXMvcHJvdi1sZWRnZXIvc3JjL21lcmtsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTZIZXgoYnVmOiBCdWZmZXIgfCBzdHJpbmcpIHtcbiAgY29uc3QgaCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpOyBoLnVwZGF0ZShidWYpOyByZXR1cm4gaC5kaWdlc3QoJ2hleCcpO1xufVxuXG4vLyBEZXRlcm1pbmlzdGljIGxlYWYgZW5jb2RpbmcgZm9yIGEgc3RlcFxuZXhwb3J0IGZ1bmN0aW9uIGxlYWZIYXNoKHN0ZXA6IGFueSkge1xuICBjb25zdCBzID0gSlNPTi5zdHJpbmdpZnkoc3RlcCwgT2JqZWN0LmtleXMoc3RlcCkuc29ydCgpKTtcbiAgcmV0dXJuIHNoYTI1NkhleChCdWZmZXIuZnJvbShzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZE1lcmtsZShsZWF2ZXNIZXg6IHN0cmluZ1tdKSB7XG4gIGlmIChsZWF2ZXNIZXgubGVuZ3RoID09PSAwKSByZXR1cm4geyByb290OiBzaGEyNTZIZXgoQnVmZmVyLmZyb20oJ0VNUFRZJykpICwgbGF5ZXJzOiBbIFtdIF0gfTtcbiAgbGV0IGxheWVyID0gbGVhdmVzSGV4LnNsaWNlKCk7XG4gIGNvbnN0IGxheWVycyA9IFtsYXllcl07XG4gIHdoaWxlIChsYXllci5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmV4dDogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7aTxsYXllci5sZW5ndGg7aSs9Mil7XG4gICAgICBjb25zdCBhID0gbGF5ZXJbaV07XG4gICAgICBjb25zdCBiID0gaSsxIDwgbGF5ZXIubGVuZ3RoID8gbGF5ZXJbaSsxXSA6IGxheWVyW2ldOyAvLyBkdXBsaWNhdGUgbGFzdCBpZiBvZGRcbiAgICAgIG5leHQucHVzaChzaGEyNTZIZXgoQnVmZmVyLmZyb20oYSArIGIpKSk7XG4gICAgfVxuICAgIGxheWVyID0gbmV4dDsgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICB9XG4gIHJldHVybiB7IHJvb3Q6IGxheWVyWzBdLCBsYXllcnMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb29mRm9yTGVhZihpbmRleDogbnVtYmVyLCBsYXllcnM6IHN0cmluZ1tdW10pIHtcbiAgY29uc3QgcGF0aDoge2RpcjonTCd8J1InOyBoYXNoOnN0cmluZ31bXSA9IFtdO1xuICBsZXQgaWR4ID0gaW5kZXg7XG4gIGZvciAobGV0IEw9MDsgTDxsYXllcnMubGVuZ3RoLTE7IEwrKyl7XG4gICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbTF07XG4gICAgY29uc3QgaXNSaWdodCA9IGlkeCAlIDIgPT09IDE7XG4gICAgY29uc3Qgc2libGluZ0lkeCA9IGlzUmlnaHQgPyBpZHgtMSA6IGlkeCsxID49IGxheWVyLmxlbmd0aCA/IGlkeCA6IGlkeCsxO1xuICAgIGNvbnN0IGRpciA9IGlzUmlnaHQgPyAnTCcgOiAnUic7XG4gICAgcGF0aC5wdXNoKHsgZGlyLCBoYXNoOiBsYXllcltzaWJsaW5nSWR4XSB9KTtcbiAgICBpZHggPSBNYXRoLmZsb29yKGlkeC8yKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVByb29mKGxlYWY6IHN0cmluZywgcGF0aDoge2RpcjonTCd8J1InOyBoYXNoOnN0cmluZ31bXSwgZXhwZWN0ZWRSb290OiBzdHJpbmcpIHtcbiAgbGV0IGggPSBsZWFmO1xuICBmb3IgKGNvbnN0IHAgb2YgcGF0aCkge1xuICAgIGggPSBwLmRpciA9PT0gJ0wnID8gc2hhMjU2SGV4KEJ1ZmZlci5mcm9tKHAuaGFzaCArIGgpKSA6IHNoYTI1NkhleChCdWZmZXIuZnJvbShoICsgcC5oYXNoKSk7XG4gIH1cbiAgcmV0dXJuIGggPT09IGV4cGVjdGVkUm9vdDtcbn0iXSwidmVyc2lvbiI6M30=