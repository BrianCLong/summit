d3ab61ca7785cc52065395f90cb37598
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const transport_1 = require("../../src/lib/assistant/transport");
const util_1 = require("util");
describe('Framed Stream Parser Fuzz Test', () => {
    const encoder = new util_1.TextEncoder();
    // Helper to simulate a fetch response with given chunks
    const mockFetchResponse = (chunks) => {
        let i = 0;
        return Promise.resolve({
            ok: true,
            body: {
                getReader() {
                    return {
                        read: () => Promise.resolve(i < chunks.length
                            ? { value: encoder.encode(chunks[i++]), done: false }
                            : { value: undefined, done: true }),
                        releaseLock() { },
                    };
                },
            },
        });
    };
    it('correctly parses mixed frame sizes and heartbeat inserts', async () => {
        const receivedEvents = [];
        const transport = (0, transport_1.createFetchStreamTransport)({
            baseUrl: '/api',
            getAuthToken: () => null,
        });
        transport.on((evt) => receivedEvents.push(evt));
        const testCases = [
            // Single full frames
            JSON.stringify({ type: 'status', value: 'thinking' }) + '\n',
            JSON.stringify({ type: 'token', value: 'Hello' }) + '\n',
            JSON.stringify({ type: 'done', cites: [] }) + '\n',
            // Mixed frame sizes (split across reads)
            JSON.stringify({ type: 'token', value: 'World' }).slice(0, 5),
            JSON.stringify({ type: 'token', value: 'World' }).slice(5) + '\n',
            // Multiple frames in one read
            JSON.stringify({ type: 'token', value: 'Foo' }) +
                '\n' +
                JSON.stringify({ type: 'token', value: 'Bar' }) +
                '\n',
            // Heartbeat/empty lines
            '\n',
            '\n',
            JSON.stringify({ type: 'token', value: 'Baz' }) + '\n',
            // Incomplete frame at the end
            JSON.stringify({ type: 'token', value: 'Incomplete' }).slice(0, 10),
        ];
        // Simulate fetch call
        // @ts-ignore
        global.fetch = jest.fn(() => mockFetchResponse(testCases));
        await transport.send('test', new AbortController().signal);
        // Wait for all events to be processed (give it a moment for async operations)
        await new Promise((resolve) => setTimeout(resolve, 100));
        // Assertions
        expect(receivedEvents.length).toBe(6); // status, Hello, World, Foo, Bar, Baz, Incomplete, done
        expect(receivedEvents[0]).toEqual({ type: 'status', value: 'thinking' });
        expect(receivedEvents[1]).toEqual({ type: 'token', value: 'Hello' });
        expect(receivedEvents[2]).toEqual({ type: 'token', value: 'World' });
        expect(receivedEvents[3]).toEqual({ type: 'token', value: 'Foo' });
        expect(receivedEvents[4]).toEqual({ type: 'token', value: 'Bar' });
        expect(receivedEvents[5]).toEqual({ type: 'token', value: 'Baz' });
        // The last incomplete frame will not be processed until more data or stream ends
        // The done event will be sent by the server, not the client transport
    });
    it('correctly handles a stream ending with an incomplete frame', async () => {
        const receivedEvents = [];
        const transport = (0, transport_1.createFetchStreamTransport)({
            baseUrl: '/api',
            getAuthToken: () => null,
        });
        transport.on((evt) => receivedEvents.push(evt));
        const testCases = [JSON.stringify({ type: 'token', value: 'Partial' }).slice(0, 10)];
        // Simulate fetch call
        // @ts-ignore
        global.fetch = jest.fn(() => mockFetchResponse(testCases));
        await transport.send('test', new AbortController().signal);
        // Wait for all events to be processed
        await new Promise((resolve) => setTimeout(resolve, 100));
        // The incomplete frame should NOT be processed as a full event
        expect(receivedEvents.length).toBe(0);
    });
    it('correctly handles a stream with only a done event', async () => {
        const receivedEvents = [];
        const transport = (0, transport_1.createFetchStreamTransport)({
            baseUrl: '/api',
            getAuthToken: () => null,
        });
        transport.on((evt) => receivedEvents.push(evt));
        const testCases = [JSON.stringify({ type: 'done', cites: [] }) + '\n'];
        // Simulate fetch call
        // @ts-ignore
        global.fetch = jest.fn(() => mockFetchResponse(testCases));
        await transport.send('test', new AbortController().signal);
        // Wait for all events to be processed
        await new Promise((resolve) => setTimeout(resolve, 100));
        expect(receivedEvents.length).toBe(1);
        expect(receivedEvents[0]).toEqual({ type: 'done', cites: [] });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2JyaWFubG9uZy9EZXZlbG9wZXIvc3VtbWl0L2NsaWVudC90ZXN0cy9mdXp6L2ZyYW1lZC1zdHJlYW0udGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLGlFQUErRTtBQUMvRSwrQkFBbUM7QUFFbkMsUUFBUSxDQUFDLGdDQUFnQyxFQUFFLEdBQUcsRUFBRTtJQUM5QyxNQUFNLE9BQU8sR0FBRyxJQUFJLGtCQUFXLEVBQUUsQ0FBQztJQUVsQyx3REFBd0Q7SUFDeEQsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLE1BQWdCLEVBQUUsRUFBRTtRQUM3QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUM7WUFDckIsRUFBRSxFQUFFLElBQUk7WUFDUixJQUFJLEVBQUU7Z0JBQ0osU0FBUztvQkFDUCxPQUFPO3dCQUNMLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FDVCxPQUFPLENBQUMsT0FBTyxDQUNiLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTTs0QkFDZixDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7NEJBQ3JELENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUNyQzt3QkFDSCxXQUFXLEtBQUksQ0FBQztxQkFDakIsQ0FBQztnQkFDSixDQUFDO2FBQ0Y7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7SUFFRixFQUFFLENBQUMsMERBQTBELEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDeEUsTUFBTSxjQUFjLEdBQVUsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sU0FBUyxHQUFHLElBQUEsc0NBQTBCLEVBQUM7WUFDM0MsT0FBTyxFQUFFLE1BQU07WUFDZixZQUFZLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSTtTQUN6QixDQUFDLENBQUM7UUFDSCxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFaEQsTUFBTSxTQUFTLEdBQUc7WUFDaEIscUJBQXFCO1lBQ3JCLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsQ0FBQyxHQUFHLElBQUk7WUFDNUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxDQUFDLEdBQUcsSUFBSTtZQUN4RCxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJO1lBRWxELHlDQUF5QztZQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM3RCxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSTtZQUVqRSw4QkFBOEI7WUFDOUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDO2dCQUM3QyxJQUFJO2dCQUNKLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQztnQkFDL0MsSUFBSTtZQUVOLHdCQUF3QjtZQUN4QixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxHQUFHLElBQUk7WUFFdEQsOEJBQThCO1lBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1NBQ3BFLENBQUM7UUFFRixzQkFBc0I7UUFDdEIsYUFBYTtRQUNiLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRTNELE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxlQUFlLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUzRCw4RUFBOEU7UUFDOUUsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXpELGFBQWE7UUFDYixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLHdEQUF3RDtRQUMvRixNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUN6RSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNyRSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNyRSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNuRSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNuRSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNuRSxpRkFBaUY7UUFDakYsc0VBQXNFO0lBQ3hFLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLDREQUE0RCxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQzFFLE1BQU0sY0FBYyxHQUFVLEVBQUUsQ0FBQztRQUNqQyxNQUFNLFNBQVMsR0FBRyxJQUFBLHNDQUEwQixFQUFDO1lBQzNDLE9BQU8sRUFBRSxNQUFNO1lBQ2YsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUk7U0FDekIsQ0FBQyxDQUFDO1FBQ0gsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRWhELE1BQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXJGLHNCQUFzQjtRQUN0QixhQUFhO1FBQ2IsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFFM0QsTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLGVBQWUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTNELHNDQUFzQztRQUN0QyxNQUFNLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFekQsK0RBQStEO1FBQy9ELE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLG1EQUFtRCxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ2pFLE1BQU0sY0FBYyxHQUFVLEVBQUUsQ0FBQztRQUNqQyxNQUFNLFNBQVMsR0FBRyxJQUFBLHNDQUEwQixFQUFDO1lBQzNDLE9BQU8sRUFBRSxNQUFNO1lBQ2YsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUk7U0FDekIsQ0FBQyxDQUFDO1FBQ0gsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRWhELE1BQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFFdkUsc0JBQXNCO1FBQ3RCLGFBQWE7UUFDYixNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUUzRCxNQUFNLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksZUFBZSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFM0Qsc0NBQXNDO1FBQ3RDLE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUV6RCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNqRSxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmlhbmxvbmcvRGV2ZWxvcGVyL3N1bW1pdC9jbGllbnQvdGVzdHMvZnV6ei9mcmFtZWQtc3RyZWFtLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRmV0Y2hTdHJlYW1UcmFuc3BvcnQgfSBmcm9tICcuLi8uLi9zcmMvbGliL2Fzc2lzdGFudC90cmFuc3BvcnQnO1xuaW1wb3J0IHsgVGV4dEVuY29kZXIgfSBmcm9tICd1dGlsJztcblxuZGVzY3JpYmUoJ0ZyYW1lZCBTdHJlYW0gUGFyc2VyIEZ1enogVGVzdCcsICgpID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIC8vIEhlbHBlciB0byBzaW11bGF0ZSBhIGZldGNoIHJlc3BvbnNlIHdpdGggZ2l2ZW4gY2h1bmtzXG4gIGNvbnN0IG1vY2tGZXRjaFJlc3BvbnNlID0gKGNodW5rczogc3RyaW5nW10pID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgZ2V0UmVhZGVyKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PlxuICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICAgICAgaSA8IGNodW5rcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8geyB2YWx1ZTogZW5jb2Rlci5lbmNvZGUoY2h1bmtzW2krK10pLCBkb25lOiBmYWxzZSB9XG4gICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgcmVsZWFzZUxvY2soKSB7fSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcblxuICBpdCgnY29ycmVjdGx5IHBhcnNlcyBtaXhlZCBmcmFtZSBzaXplcyBhbmQgaGVhcnRiZWF0IGluc2VydHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVjZWl2ZWRFdmVudHM6IGFueVtdID0gW107XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gY3JlYXRlRmV0Y2hTdHJlYW1UcmFuc3BvcnQoe1xuICAgICAgYmFzZVVybDogJy9hcGknLFxuICAgICAgZ2V0QXV0aFRva2VuOiAoKSA9PiBudWxsLFxuICAgIH0pO1xuICAgIHRyYW5zcG9ydC5vbigoZXZ0KSA9PiByZWNlaXZlZEV2ZW50cy5wdXNoKGV2dCkpO1xuXG4gICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgLy8gU2luZ2xlIGZ1bGwgZnJhbWVzXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdzdGF0dXMnLCB2YWx1ZTogJ3RoaW5raW5nJyB9KSArICdcXG4nLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAndG9rZW4nLCB2YWx1ZTogJ0hlbGxvJyB9KSArICdcXG4nLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAnZG9uZScsIGNpdGVzOiBbXSB9KSArICdcXG4nLFxuXG4gICAgICAvLyBNaXhlZCBmcmFtZSBzaXplcyAoc3BsaXQgYWNyb3NzIHJlYWRzKVxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAndG9rZW4nLCB2YWx1ZTogJ1dvcmxkJyB9KS5zbGljZSgwLCA1KSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHsgdHlwZTogJ3Rva2VuJywgdmFsdWU6ICdXb3JsZCcgfSkuc2xpY2UoNSkgKyAnXFxuJyxcblxuICAgICAgLy8gTXVsdGlwbGUgZnJhbWVzIGluIG9uZSByZWFkXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICd0b2tlbicsIHZhbHVlOiAnRm9vJyB9KSArXG4gICAgICAgICdcXG4nICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAndG9rZW4nLCB2YWx1ZTogJ0JhcicgfSkgK1xuICAgICAgICAnXFxuJyxcblxuICAgICAgLy8gSGVhcnRiZWF0L2VtcHR5IGxpbmVzXG4gICAgICAnXFxuJyxcbiAgICAgICdcXG4nLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAndG9rZW4nLCB2YWx1ZTogJ0JheicgfSkgKyAnXFxuJyxcblxuICAgICAgLy8gSW5jb21wbGV0ZSBmcmFtZSBhdCB0aGUgZW5kXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICd0b2tlbicsIHZhbHVlOiAnSW5jb21wbGV0ZScgfSkuc2xpY2UoMCwgMTApLFxuICAgIF07XG5cbiAgICAvLyBTaW11bGF0ZSBmZXRjaCBjYWxsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKCkgPT4gbW9ja0ZldGNoUmVzcG9uc2UodGVzdENhc2VzKSk7XG5cbiAgICBhd2FpdCB0cmFuc3BvcnQuc2VuZCgndGVzdCcsIG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpO1xuXG4gICAgLy8gV2FpdCBmb3IgYWxsIGV2ZW50cyB0byBiZSBwcm9jZXNzZWQgKGdpdmUgaXQgYSBtb21lbnQgZm9yIGFzeW5jIG9wZXJhdGlvbnMpXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG5cbiAgICAvLyBBc3NlcnRpb25zXG4gICAgZXhwZWN0KHJlY2VpdmVkRXZlbnRzLmxlbmd0aCkudG9CZSg2KTsgLy8gc3RhdHVzLCBIZWxsbywgV29ybGQsIEZvbywgQmFyLCBCYXosIEluY29tcGxldGUsIGRvbmVcbiAgICBleHBlY3QocmVjZWl2ZWRFdmVudHNbMF0pLnRvRXF1YWwoeyB0eXBlOiAnc3RhdHVzJywgdmFsdWU6ICd0aGlua2luZycgfSk7XG4gICAgZXhwZWN0KHJlY2VpdmVkRXZlbnRzWzFdKS50b0VxdWFsKHsgdHlwZTogJ3Rva2VuJywgdmFsdWU6ICdIZWxsbycgfSk7XG4gICAgZXhwZWN0KHJlY2VpdmVkRXZlbnRzWzJdKS50b0VxdWFsKHsgdHlwZTogJ3Rva2VuJywgdmFsdWU6ICdXb3JsZCcgfSk7XG4gICAgZXhwZWN0KHJlY2VpdmVkRXZlbnRzWzNdKS50b0VxdWFsKHsgdHlwZTogJ3Rva2VuJywgdmFsdWU6ICdGb28nIH0pO1xuICAgIGV4cGVjdChyZWNlaXZlZEV2ZW50c1s0XSkudG9FcXVhbCh7IHR5cGU6ICd0b2tlbicsIHZhbHVlOiAnQmFyJyB9KTtcbiAgICBleHBlY3QocmVjZWl2ZWRFdmVudHNbNV0pLnRvRXF1YWwoeyB0eXBlOiAndG9rZW4nLCB2YWx1ZTogJ0JheicgfSk7XG4gICAgLy8gVGhlIGxhc3QgaW5jb21wbGV0ZSBmcmFtZSB3aWxsIG5vdCBiZSBwcm9jZXNzZWQgdW50aWwgbW9yZSBkYXRhIG9yIHN0cmVhbSBlbmRzXG4gICAgLy8gVGhlIGRvbmUgZXZlbnQgd2lsbCBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIsIG5vdCB0aGUgY2xpZW50IHRyYW5zcG9ydFxuICB9KTtcblxuICBpdCgnY29ycmVjdGx5IGhhbmRsZXMgYSBzdHJlYW0gZW5kaW5nIHdpdGggYW4gaW5jb21wbGV0ZSBmcmFtZScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZWNlaXZlZEV2ZW50czogYW55W10gPSBbXTtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSBjcmVhdGVGZXRjaFN0cmVhbVRyYW5zcG9ydCh7XG4gICAgICBiYXNlVXJsOiAnL2FwaScsXG4gICAgICBnZXRBdXRoVG9rZW46ICgpID0+IG51bGwsXG4gICAgfSk7XG4gICAgdHJhbnNwb3J0Lm9uKChldnQpID0+IHJlY2VpdmVkRXZlbnRzLnB1c2goZXZ0KSk7XG5cbiAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAndG9rZW4nLCB2YWx1ZTogJ1BhcnRpYWwnIH0pLnNsaWNlKDAsIDEwKV07XG5cbiAgICAvLyBTaW11bGF0ZSBmZXRjaCBjYWxsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKCkgPT4gbW9ja0ZldGNoUmVzcG9uc2UodGVzdENhc2VzKSk7XG5cbiAgICBhd2FpdCB0cmFuc3BvcnQuc2VuZCgndGVzdCcsIG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpO1xuXG4gICAgLy8gV2FpdCBmb3IgYWxsIGV2ZW50cyB0byBiZSBwcm9jZXNzZWRcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcblxuICAgIC8vIFRoZSBpbmNvbXBsZXRlIGZyYW1lIHNob3VsZCBOT1QgYmUgcHJvY2Vzc2VkIGFzIGEgZnVsbCBldmVudFxuICAgIGV4cGVjdChyZWNlaXZlZEV2ZW50cy5sZW5ndGgpLnRvQmUoMCk7XG4gIH0pO1xuXG4gIGl0KCdjb3JyZWN0bHkgaGFuZGxlcyBhIHN0cmVhbSB3aXRoIG9ubHkgYSBkb25lIGV2ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlY2VpdmVkRXZlbnRzOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IGNyZWF0ZUZldGNoU3RyZWFtVHJhbnNwb3J0KHtcbiAgICAgIGJhc2VVcmw6ICcvYXBpJyxcbiAgICAgIGdldEF1dGhUb2tlbjogKCkgPT4gbnVsbCxcbiAgICB9KTtcbiAgICB0cmFuc3BvcnQub24oKGV2dCkgPT4gcmVjZWl2ZWRFdmVudHMucHVzaChldnQpKTtcblxuICAgIGNvbnN0IHRlc3RDYXNlcyA9IFtKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdkb25lJywgY2l0ZXM6IFtdIH0pICsgJ1xcbiddO1xuXG4gICAgLy8gU2ltdWxhdGUgZmV0Y2ggY2FsbFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCgpID0+IG1vY2tGZXRjaFJlc3BvbnNlKHRlc3RDYXNlcykpO1xuXG4gICAgYXdhaXQgdHJhbnNwb3J0LnNlbmQoJ3Rlc3QnLCBuZXcgQWJvcnRDb250cm9sbGVyKCkuc2lnbmFsKTtcblxuICAgIC8vIFdhaXQgZm9yIGFsbCBldmVudHMgdG8gYmUgcHJvY2Vzc2VkXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG5cbiAgICBleHBlY3QocmVjZWl2ZWRFdmVudHMubGVuZ3RoKS50b0JlKDEpO1xuICAgIGV4cGVjdChyZWNlaXZlZEV2ZW50c1swXSkudG9FcXVhbCh7IHR5cGU6ICdkb25lJywgY2l0ZXM6IFtdIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9