{"file":"/Users/brianlong/Developer/summit/client/tests/fuzz/framed-stream.test.ts","mappings":"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","names":[],"sources":["/Users/brianlong/Developer/summit/client/tests/fuzz/framed-stream.test.ts"],"sourcesContent":["import { createFetchStreamTransport } from '../../src/lib/assistant/transport';\nimport { TextEncoder } from 'util';\n\ndescribe('Framed Stream Parser Fuzz Test', () => {\n  const encoder = new TextEncoder();\n\n  // Helper to simulate a fetch response with given chunks\n  const mockFetchResponse = (chunks: string[]) => {\n    let i = 0;\n    return Promise.resolve({\n      ok: true,\n      body: {\n        getReader() {\n          return {\n            read: () =>\n              Promise.resolve(\n                i < chunks.length\n                  ? { value: encoder.encode(chunks[i++]), done: false }\n                  : { value: undefined, done: true },\n              ),\n            releaseLock() {},\n          };\n        },\n      },\n    });\n  };\n\n  it('correctly parses mixed frame sizes and heartbeat inserts', async () => {\n    const receivedEvents: any[] = [];\n    const transport = createFetchStreamTransport({\n      baseUrl: '/api',\n      getAuthToken: () => null,\n    });\n    transport.on((evt) => receivedEvents.push(evt));\n\n    const testCases = [\n      // Single full frames\n      JSON.stringify({ type: 'status', value: 'thinking' }) + '\\n',\n      JSON.stringify({ type: 'token', value: 'Hello' }) + '\\n',\n      JSON.stringify({ type: 'done', cites: [] }) + '\\n',\n\n      // Mixed frame sizes (split across reads)\n      JSON.stringify({ type: 'token', value: 'World' }).slice(0, 5),\n      JSON.stringify({ type: 'token', value: 'World' }).slice(5) + '\\n',\n\n      // Multiple frames in one read\n      JSON.stringify({ type: 'token', value: 'Foo' }) +\n        '\\n' +\n        JSON.stringify({ type: 'token', value: 'Bar' }) +\n        '\\n',\n\n      // Heartbeat/empty lines\n      '\\n',\n      '\\n',\n      JSON.stringify({ type: 'token', value: 'Baz' }) + '\\n',\n\n      // Incomplete frame at the end\n      JSON.stringify({ type: 'token', value: 'Incomplete' }).slice(0, 10),\n    ];\n\n    // Simulate fetch call\n    // @ts-ignore\n    global.fetch = jest.fn(() => mockFetchResponse(testCases));\n\n    await transport.send('test', new AbortController().signal);\n\n    // Wait for all events to be processed (give it a moment for async operations)\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    // Assertions\n    expect(receivedEvents.length).toBe(6); // status, Hello, World, Foo, Bar, Baz, Incomplete, done\n    expect(receivedEvents[0]).toEqual({ type: 'status', value: 'thinking' });\n    expect(receivedEvents[1]).toEqual({ type: 'token', value: 'Hello' });\n    expect(receivedEvents[2]).toEqual({ type: 'token', value: 'World' });\n    expect(receivedEvents[3]).toEqual({ type: 'token', value: 'Foo' });\n    expect(receivedEvents[4]).toEqual({ type: 'token', value: 'Bar' });\n    expect(receivedEvents[5]).toEqual({ type: 'token', value: 'Baz' });\n    // The last incomplete frame will not be processed until more data or stream ends\n    // The done event will be sent by the server, not the client transport\n  });\n\n  it('correctly handles a stream ending with an incomplete frame', async () => {\n    const receivedEvents: any[] = [];\n    const transport = createFetchStreamTransport({\n      baseUrl: '/api',\n      getAuthToken: () => null,\n    });\n    transport.on((evt) => receivedEvents.push(evt));\n\n    const testCases = [JSON.stringify({ type: 'token', value: 'Partial' }).slice(0, 10)];\n\n    // Simulate fetch call\n    // @ts-ignore\n    global.fetch = jest.fn(() => mockFetchResponse(testCases));\n\n    await transport.send('test', new AbortController().signal);\n\n    // Wait for all events to be processed\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    // The incomplete frame should NOT be processed as a full event\n    expect(receivedEvents.length).toBe(0);\n  });\n\n  it('correctly handles a stream with only a done event', async () => {\n    const receivedEvents: any[] = [];\n    const transport = createFetchStreamTransport({\n      baseUrl: '/api',\n      getAuthToken: () => null,\n    });\n    transport.on((evt) => receivedEvents.push(evt));\n\n    const testCases = [JSON.stringify({ type: 'done', cites: [] }) + '\\n'];\n\n    // Simulate fetch call\n    // @ts-ignore\n    global.fetch = jest.fn(() => mockFetchResponse(testCases));\n\n    await transport.send('test', new AbortController().signal);\n\n    // Wait for all events to be processed\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    expect(receivedEvents.length).toBe(1);\n    expect(receivedEvents[0]).toEqual({ type: 'done', cites: [] });\n  });\n});\n"],"version":3}