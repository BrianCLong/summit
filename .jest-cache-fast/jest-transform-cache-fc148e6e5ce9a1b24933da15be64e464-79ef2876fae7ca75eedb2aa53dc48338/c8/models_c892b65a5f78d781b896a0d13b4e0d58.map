{"file":"/Users/brianlong/Developer/summit/server/src/conductor/models.ts","mappings":";;AASA,sCASC;AAED,kBAaC;AAjCD,2BAA0B;AAE1B,MAAM,EAAE,GAAG,IAAI,SAAI,CAAC,EAAE,gBAAgB,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC,CAAC;AAEpE,KAAK,UAAU,YAAY,CAAC,IAAY;IACtC,0DAA0D;IAC1D,OAAO,KAAK,CAAC;AACf,CAAC;AAEM,KAAK,UAAU,aAAa,CAAC,KAAU,EAAE,KAAa;IAC3D,IAAI,CAAC,CAAC,MAAM,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAAE,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;IACxE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG,MAAM,EAAE,CAAC,KAAK,CAClC;;2GAEuG,EACvG,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAC1F,CAAC;IACF,OAAO,CAAC,CAAC;AACX,CAAC;AAEM,KAAK,UAAU,GAAG,CAAC,MAAc,EAAE,QAAgB,EAAE,CAAS;IACnE,MAAM,EAAE,IAAI,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,MAAM,EAAE,CAAC,KAAK,CACpC,uGAAuG,EACvG,CAAC,MAAM,EAAE,QAAQ,CAAC,CACnB,CAAC;IACF,IAAI,CAAC,GAAG;QAAE,OAAO,EAAE,CAAC;IACpB,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,EAAE,CAAC,KAAK,CAC7B;;yDAEqD,EACrD,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC,CAC/B,CAAC;IACF,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC,SAAS,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AACjG,CAAC","names":[],"sources":["/Users/brianlong/Developer/summit/server/src/conductor/models.ts"],"sourcesContent":["import { Pool } from 'pg';\n\nconst pg = new Pool({ connectionString: process.env.DATABASE_URL });\n\nasync function verifyCosign(_uri: string) {\n  // TODO: implement cosign verification of OCI/S3 reference\n  return false;\n}\n\nexport async function registerModel(input: any, actor: string) {\n  if (!(await verifyCosign(input.uri))) throw new Error('unsigned model');\n  const { rows: [m] } = await pg.query(\n    `INSERT INTO model_registry(name,version,type,uri,signature,metrics,created_by)\n     VALUES ($1,$2,$3,$4,$5,$6,$7)\n     RETURNING id, name, version, type, uri, metrics, created_by AS \"createdBy\", created_at AS \"createdAt\"`,\n    [input.name, input.version, input.type, input.uri, input.signature, input.metrics, actor],\n  );\n  return m;\n}\n\nexport async function knn(tenant: string, entityId: string, k: number) {\n  const { rows: [cur] } = await pg.query(\n    `SELECT vec, version FROM embeddings WHERE tenant=$1 AND entity_id=$2 ORDER BY updated_at DESC LIMIT 1`,\n    [tenant, entityId],\n  );\n  if (!cur) return [];\n  const { rows } = await pg.query(\n    `SELECT entity_id, 1 - (embeddings.vec <=> $1::vector) AS score, meta\n     FROM embeddings WHERE tenant=$2 AND entity_id <> $3\n     ORDER BY embeddings.vec <=> $1::vector ASC LIMIT $4`,\n    [cur.vec, tenant, entityId, k],\n  );\n  return rows.map((r: any) => ({ entityId: r.entity_id, score: Number(r.score), meta: r.meta }));\n}\n\n"],"version":3}