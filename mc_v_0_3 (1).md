# MC v0.3.2 — Local Execution Kit (no external deps)

This kit lets you run the **go‑live plan locally** without the real `mc` binary, private repos, or cloud endpoints. It provides:

- A drop‑in **`mc` shim** (Python) that supports the exact commands used in the plan
- A minimal **gates runner** (Python) that simulates stage/canary/prod checks and emits reports
- A **mock A2A gateway** (Node or Python) you can run on localhost so `$A2A_URL` resolves
- Ready‑to‑run commands + sample artifacts so everything works out‑of‑the‑box

> Place these files at the root of a scratch repo or your workspace. Then follow the Quickstart.

---

## 1) Files to create

### `tools/mc.py` — shim for `mc evidence` and `mc slo`
```python
#!/usr/bin/env python3
import argparse, json, os, sys, hashlib, time, pathlib, random

ROOT = pathlib.Path(os.getcwd())
OUT = ROOT/"out"; OUT.mkdir(parents=True, exist_ok=True)
DIST = ROOT/"dist"; DIST.mkdir(parents=True, exist_ok=True)

SIG_KEY = os.environ.get("MC_SIGNING_KEY", "dev-key-not-for-prod")

def sha256_file(p: pathlib.Path) -> str:
    h = hashlib.sha256()
    with open(p, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            h.update(chunk)
    return h.hexdigest()

def sign(text: str) -> str:
    return hashlib.sha256((SIG_KEY + text).encode()).hexdigest()

def cmd_evidence_pack(args):
    manifest = {
        "version": os.environ.get("MC_VERSION", "v0.3.2-mc"),
        "ts": int(time.time()),
        "artifacts": [],
        "signing": {"algo": "sha256(HMAC-sim)", "keyRef": "env:MC_SIGNING_KEY"}
    }
    # collect files from ./out by default
    for p in sorted(OUT.rglob("*")):
        if p.is_file():
            manifest["artifacts"].append({"path": str(p.relative_to(ROOT)), "sha256": sha256_file(p)})
    raw = json.dumps(manifest, indent=2)
    sig = sign(raw)
    bundle = {"manifest": manifest, "signature": sig}
    outp = pathlib.Path(args.out)
    outp.write_text(json.dumps(bundle, indent=2))
    print(f"wrote evidence bundle → {outp}")

def cmd_evidence_verify(args):
    p = pathlib.Path(args.file)
    bundle = json.loads(p.read_text())
    raw = json.dumps(bundle["manifest"], indent=2)
    good = sign(raw) == bundle.get("signature")
    # also verify files if present
    missing = []
    bad = []
    for a in bundle["manifest"].get("artifacts", []):
        fp = ROOT/a["path"]
        if not fp.exists():
            missing.append(a["path"])
        else:
            if sha256_file(fp) != a["sha256"]:
                bad.append(a["path"])
    status = good and not missing and not bad
    print(json.dumps({"signature_ok": good, "missing": missing, "mismatch": bad, "ok": status}, indent=2))
    sys.exit(0 if status else 2)

def cmd_slo_snapshot(args):
    snap = {
        "version": os.environ.get("MC_VERSION", "v0.3.2-mc"),
        "capturedAt": time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
        "endpoints": {
            "GraphQL.reads.p95_ms": 320 + random.randint(-25, 25),
            "GraphQL.writes.p95_ms": 610 + random.randint(-40, 40),
            "Graph.1hop.p95_ms": 260 + random.randint(-20, 20)
        },
        "availability": 99.97
    }
    pathlib.Path(args.out).write_text(json.dumps(snap, indent=2))
    print(f"wrote SLO snapshot → {args.out}")

if __name__ == '__main__':
    ap = argparse.ArgumentParser(prog='mc (shim)')
    sub = ap.add_subparsers(dest='cmd', required=True)
    ap_e1 = sub.add_parser('evidence'); sub2 = ap_e1.add_subparsers(dest='sub', required=True)
    p_pack = sub2.add_parser('pack'); p_pack.add_argument('--out', required=True); p_pack.set_defaults(func=cmd_evidence_pack)
    p_ver = sub2.add_parser('verify'); p_ver.add_argument('file'); p_ver.set_defaults(func=cmd_evidence_verify)
    ap_slo = sub.add_parser('slo'); sub3 = ap_slo.add_subparsers(dest='sub', required=True)
    p_snap = sub3.add_parser('snapshot'); p_snap.add_argument('--out', required=True); p_snap.set_defaults(func=cmd_slo_snapshot)
    args = ap.parse_args(); args.func(args)
```

### `tools/gates_runner.py` — simulate stage/canary/prod gates
```python
#!/usr/bin/env python3
import argparse, json, os, time, random, pathlib

STAGES = {"stage": 0.95, "canary_20": 0.97, "canary_50": 0.98, "production": 0.99}

if __name__ == '__main__':
    ap = argparse.ArgumentParser()
    ap.add_argument('--stage', required=True, choices=list(STAGES.keys()))
    ap.add_argument('--strict', action='store_true')
    ap.add_argument('--report', required=True)
    args = ap.parse_args()

    base = STAGES[args.stage]
    report = {
        "stage": args.stage,
        "ts": int(time.time()),
        "slo": {"reads_p95_ms": int(1000*(1-base)+300), "writes_p95_ms": int(1000*(1-base)+650), "availability": round(99.9 + (base-0.95), 3)},
        "cost": {"utilization": round(60 + 10*(1-base), 1)},
        "policy": {"residency_pass": True, "persisted_only": True},
        "result": "PASS"
    }
    pathlib.Path(args.report).write_text(json.dumps(report, indent=2))
    print(f"wrote gates report → {args.report}")
```

### `mock/a2a_server.py` — tiny local A2A gateway (Python)
```python
#!/usr/bin/env python3
from http.server import BaseHTTPRequestHandler, HTTPServer
import json, hashlib, time

class H(BaseHTTPRequestHandler):
    def do_POST(self):
        if self.path != '/a2a/perform':
            self.send_response(404); self.end_headers(); return
        length = int(self.headers.get('Content-Length','0'))
        body = json.loads(self.rfile.read(length).decode() or '{}')
        # "Policy" allow stub and provenance hash
        result = {"echoTask": body.get('task', {}), "policy": {"allow": True, "reasons": ["dev stub"]}}
        prov = {"hash": hashlib.sha256(json.dumps(result).encode()).hexdigest(), "time": int(time.time())}
        self.send_response(200)
        self.send_header('Content-Type','application/json'); self.end_headers()
        self.wfile.write(json.dumps({"ok": True, "result": result, "provenance": prov}).encode())

if __name__ == '__main__':
    HTTPServer(('127.0.0.1', 8080), H).serve_forever()
```

### Sample artifacts so evidence works out of the box
Create an `out/` directory and add:

#### `out/sample.txt`
```
hello evidence
```

---

## 2) Quickstart (copy‑paste)

```bash
# 0) Make scripts executable
chmod +x tools/mc.py tools/gates_runner.py mock/a2a_server.py

# 1) Define local env (A2A_URL + signing key)
export A2A_URL=http://127.0.0.1:8080
export MC_SIGNING_KEY=dev-demo-key
export MC_VERSION=v0.3.2-mc

# 2) Start the mock A2A gateway in a separate shell
python3 mock/a2a_server.py

# 3) Generate an SLO snapshot (simulated)
python3 tools/mc.py slo snapshot --out out/slo-v0.3.2-baseline.json

# 4) Run gates for each stage (simulated)
python3 tools/gates_runner.py --stage stage --strict --report out/gates-stage-v032.json
python3 tools/gates_runner.py --stage canary_20 --strict --report out/gates-canary20-v032.json
python3 tools/gates_runner.py --stage canary_50 --strict --report out/gates-canary50-v032.json
python3 tools/gates_runner.py --stage production --strict --report out/gates-prod-v032.json

# 5) Call the A2A endpoint (now A2A_URL is defined)
curl -sS -X POST $A2A_URL/a2a/perform -H 'Content-Type: application/json' \
  -d '{"tenantId":"TENANT_001","purpose":"investigation","residency":"US","pqid":"pq.getPersonById","agent":"code-refactor","task":{"repo":"svc-api","goal":"add pagination"}}' | jq .

# 6) Build a signed evidence bundle from ./out
python3 tools/mc.py evidence pack --out dist/evidence-v0.3.2-mc.json

# 7) Verify the bundle
python3 tools/mc.py evidence verify dist/evidence-v0.3.2-mc.json
```

Expected output:
- `out/` now contains SLO + gate reports
- `dist/evidence-v0.3.2-mc.json` with a manifest and signature
- Verification prints `{ "ok": true }` and lists any missing/mismatched files if you remove or modify them

---

## 3) Notes & Next Steps
- This kit **simulates** the MC pipeline end‑to‑end so you can run everything locally today. When you’re ready to swap in the real components:
  - Replace `tools/mc.py` with the actual `mc` binary.
  - Point A2A calls at your governed gateway (`$A2A_URL=https://agent.your-domain/a2a`).
  - Replace `tools/gates_runner.py` with your real gates runner.
- If you’d like, I can add a **Docker Compose** file that launches the mock A2A gateway + a fake OPA that always ALLOWs, and wire CI to run these sims on every PR.
