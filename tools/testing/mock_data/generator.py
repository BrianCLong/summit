"""Utility for generating realistic mock datasets for Summit testing."""
from __future__ import annotations

import csv
import importlib
import importlib.util
import json
import math
import random
import tempfile
import uuid
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence

from faker import Faker


@dataclass(frozen=True)
class MockRole:
    id: str
    name: str
    description: str


@dataclass(frozen=True)
class MockUser:
    id: str
    email: str
    display_name: str
    title: str
    organization: str
    password_hash: str
    timezone: str


@dataclass(frozen=True)
class MockUserRole:
    user_id: str
    role_id: str


@dataclass(frozen=True)
class MockEntity:
    id: str
    ingest_id: str
    type: str
    name: str
    properties: Dict[str, object]


@dataclass(frozen=True)
class MockRelationship:
    id: str
    ingest_id: str
    type: str
    source_id: str
    source_ingest_id: str
    target_id: str
    target_ingest_id: str
    properties: Dict[str, object]


@dataclass(frozen=True)
class MockAuditEvent:
    id: str
    actor_id: Optional[str]
    action: str
    target_type: str
    target_id: str
    metadata: Dict[str, object]


@dataclass(frozen=True)
class MockDataset:
    roles: List[MockRole]
    users: List[MockUser]
    user_roles: List[MockUserRole]
    entities: List[MockEntity]
    relationships: List[MockRelationship]
    audit_events: List[MockAuditEvent]


class MockDataGenerator:
    """Generates realistic mock datasets for Postgres, Neo4j, and the ingest wizard."""

    _classification_levels: Sequence[str] = (
        "UNCLASSIFIED",
        "CONFIDENTIAL",
        "SECRET",
        "TOP SECRET",
    )
    _sectors: Sequence[str] = (
        "Aerospace",
        "Energy",
        "Financial",
        "Defense",
        "Cybersecurity",
        "Logistics",
    )
    _sources: Sequence[str] = ("OSINT", "HUMINT", "SIGINT", "SOC Insights", "Partner Feed")
    _relationship_types: Sequence[str] = (
        "ASSOCIATED_WITH",
        "LOCATED_AT",
        "PART_OF",
        "INVOLVED_IN",
        "SUPPORTS",
        "REPORTS_TO",
    )

    def __init__(self, seed: Optional[int] = None, locale: str = "en_US") -> None:
        self.faker = Faker(locale)
        self.random = random.Random(seed)
        if seed is not None:
            self.faker.seed_instance(seed)

    # ------------------------------------------------------------------
    # Public generation helpers
    # ------------------------------------------------------------------
    def generate(self, record_count: int = 40) -> MockDataset:
        """Create a fresh dataset with the requested volume."""

        role_records = self._generate_roles()
        user_records = self._generate_users(max(5, record_count // 3))
        user_role_records = self._assign_roles(user_records, role_records)
        entity_records = self._generate_entities(record_count)
        relationship_records = self._generate_relationships(entity_records, record_count)
        audit_records = self._generate_audit_events(
            user_records, entity_records, relationship_records, max(record_count, 8)
        )

        return MockDataset(
            roles=role_records,
            users=user_records,
            user_roles=user_role_records,
            entities=entity_records,
            relationships=relationship_records,
            audit_events=audit_records,
        )

    # ------------------------------------------------------------------
    # Rendering helpers
    # ------------------------------------------------------------------
    def render_postgres_sql(self, dataset: MockDataset) -> str:
        """Return SQL suitable for `server/db/seeds/postgres`."""

        lines: List[str] = [
            "-- Mock data generated by tools.testing.mock_data.generator",
            f"-- Entities: {len(dataset.entities)} | Relationships: {len(dataset.relationships)}",
            "BEGIN;",
        ]

        lines.extend(
            self._render_insert(
                "roles",
                ("id", "name", "description"),
                [(role.id, role.name, role.description) for role in dataset.roles],
                conflict="(id) DO NOTHING",
            )
        )
        lines.extend(
            self._render_insert(
                "users",
                ("id", "email", "display_name", "title", "password_hash", "properties"),
                [
                    (
                        user.id,
                        user.email,
                        user.display_name,
                        user.title,
                        user.password_hash,
                        {
                            "organization": user.organization,
                            "timezone": user.timezone,
                        },
                    )
                    for user in dataset.users
                ],
                conflict="(id) DO NOTHING",
            )
        )
        lines.extend(
            self._render_insert(
                "user_roles",
                ("user_id", "role_id"),
                [(ur.user_id, ur.role_id) for ur in dataset.user_roles],
                conflict="(user_id, role_id) DO NOTHING",
            )
        )
        lines.extend(
            self._render_insert(
                "entities",
                ("id", "type", "name", "properties"),
                [
                    (
                        entity.id,
                        entity.type,
                        entity.name,
                        entity.properties,
                    )
                    for entity in dataset.entities
                ],
                conflict="(id) DO NOTHING",
            )
        )
        lines.extend(
            self._render_insert(
                "relationships",
                ("id", "type", "source_id", "target_id", "properties"),
                [
                    (
                        rel.id,
                        rel.type,
                        rel.source_id,
                        rel.target_id,
                        rel.properties,
                    )
                    for rel in dataset.relationships
                ],
                conflict="(id) DO NOTHING",
            )
        )
        lines.extend(
            self._render_insert(
                "audit_events",
                ("id", "actor_id", "action", "target_type", "target_id", "metadata"),
                [
                    (
                        audit.id,
                        audit.actor_id,
                        audit.action,
                        audit.target_type,
                        audit.target_id,
                        audit.metadata,
                    )
                    for audit in dataset.audit_events
                ],
                conflict="(id) DO NOTHING",
            )
        )

        lines.append("COMMIT;")
        return "\n".join(lines) + "\n"

    def write_postgres_sql(
        self, output_path: Path, dataset: Optional[MockDataset] = None, record_count: int = 40
    ) -> MockDataset:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        dataset = dataset or self.generate(record_count)
        output_path.write_text(self.render_postgres_sql(dataset), encoding="utf-8")
        return dataset

    def render_neo4j_cypher(self, dataset: MockDataset) -> str:
        """Return Cypher statements for seeding Neo4j."""

        lines: List[str] = [
            "// Mock data generated by tools.testing.mock_data.generator",
            f"// Entities: {len(dataset.entities)} | Relationships: {len(dataset.relationships)}",
        ]

        for entity in dataset.entities:
            labels = ":".join(["Entity", entity.type.replace(" ", "_")])
            props = dict(entity.properties)
            props.update({
                "id": entity.id,
                "name": entity.name,
                "type": entity.type,
                "ingest_id": entity.ingest_id,
            })
            lines.append(
                f"MERGE (n:{labels} {{ingest_id: {self._cypher_str(entity.ingest_id)}}})"
            )
            lines.append(f"SET n += {self._cypher_map(props)};\n")

        for rel in dataset.relationships:
            rel_props = dict(rel.properties)
            rel_props.update({"id": rel.id, "type": rel.type, "ingest_id": rel.ingest_id})
            rel_type = rel.type.replace(" ", "_")
            lines.append(
                "MERGE (source:Entity {ingest_id: %s})" % self._cypher_str(rel.source_ingest_id)
            )
            lines.append(
                "MERGE (target:Entity {ingest_id: %s})" % self._cypher_str(rel.target_ingest_id)
            )
            lines.append(
                f"MERGE (source)-[r:{rel_type} {{ingest_id: {self._cypher_str(rel.ingest_id)}}}]->(target)"
            )
            lines.append(f"SET r += {self._cypher_map(rel_props)};\n")

        return "\n".join(lines) + "\n"

    def write_neo4j_cypher(
        self, output_path: Path, dataset: Optional[MockDataset] = None, record_count: int = 40
    ) -> MockDataset:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        dataset = dataset or self.generate(record_count)
        output_path.write_text(self.render_neo4j_cypher(dataset), encoding="utf-8")
        return dataset

    def write_ingest_csv(
        self,
        output_path: Path,
        dataset: Optional[MockDataset] = None,
        record_count: int = 40,
    ) -> MockDataset:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        dataset = dataset or self.generate(record_count)
        rows = self._build_ingest_rows(dataset.entities)
        fieldnames = (
            "id",
            "type",
            "name",
            "classification",
            "confidence",
            "source",
            "country",
            "sector",
            "last_seen",
            "summary",
        )
        with output_path.open("w", newline="", encoding="utf-8") as fh:
            writer = csv.DictWriter(fh, fieldnames=fieldnames)
            writer.writeheader()
            for row in rows:
                writer.writerow(row)
        return dataset

    def seed_with_ingest_pipeline(
        self,
        record_count: int,
        source: str,
        neo4j_uri: str,
        neo4j_user: str,
        neo4j_password: str,
        output_path: Optional[Path] = None,
    ) -> Dict[str, float]:
        """Generate data, feed it through the ingest wizard pipeline, and return metrics."""

        ingest_module = self._load_ingest_module()
        pipeline = ingest_module.build_pipeline(neo4j_uri, neo4j_user, neo4j_password)

        temp_dir: Optional[tempfile.TemporaryDirectory[str]] = None
        temp_path = output_path
        if temp_path is None:
            temp_dir = tempfile.TemporaryDirectory(prefix="mock-ingest-")
            temp_path = Path(temp_dir.name) / "mock_ingest.csv"

        dataset = self.generate(record_count)
        self.write_ingest_csv(temp_path, dataset=dataset)
        try:
            metrics = pipeline.ingest(temp_path, source)
        finally:
            pipeline.loader.close()
            if temp_dir is not None:
                temp_dir.cleanup()
        return metrics

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _generate_roles(self) -> List[MockRole]:
        descriptors = [
            ("Mission Lead", "Orchestrates cross-domain intel missions"),
            ("Data Steward", "Maintains ingest hygiene and data catalog accuracy"),
            ("Intel Analyst", "Performs fusion analysis and briefing prep"),
            ("Field Operative", "Collects forward deployed observations"),
            ("Policy Reviewer", "Validates compliance and risk controls"),
        ]
        roles: List[MockRole] = []
        for name, description in descriptors:
            roles.append(MockRole(id=self._uuid(), name=name, description=description))
        return roles

    def _generate_users(self, count: int) -> List[MockUser]:
        users: List[MockUser] = []
        seen_emails: set[str] = set()
        for _ in range(count):
            email = self._unique_email(seen_emails)
            display_name = self.faker.name()
            title = self.random.choice(
                [
                    "Senior Intelligence Analyst",
                    "Mission Specialist",
                    "Data Integration Lead",
                    "Counter-threat Researcher",
                    "Graph Operations Engineer",
                ]
            )
            organization = self.random.choice(
                [
                    "Summit Fusion Cell",
                    "IntelGraph Ops",
                    "Northern Watch",
                    "Allied Insights",
                    "Atlas Partners",
                ]
            )
            password_hash = self.faker.sha256()
            timezone = self.faker.timezone()
            users.append(
                MockUser(
                    id=self._uuid(),
                    email=email,
                    display_name=display_name,
                    title=title,
                    organization=organization,
                    password_hash=password_hash,
                    timezone=timezone,
                )
            )
        return users

    def _assign_roles(self, users: Sequence[MockUser], roles: Sequence[MockRole]) -> List[MockUserRole]:
        assignments: List[MockUserRole] = []
        for user in users:
            role_count = max(1, math.ceil(self.random.random() * 2))
            for role in self.random.sample(list(roles), k=min(role_count, len(roles))):
                assignments.append(MockUserRole(user_id=user.id, role_id=role.id))
        return assignments

    def _generate_entities(self, record_count: int) -> List[MockEntity]:
        entities: List[MockEntity] = []
        builders = [
            self._build_person_entity,
            self._build_org_entity,
            self._build_location_entity,
            self._build_event_entity,
            self._build_asset_entity,
        ]
        for _ in range(record_count):
            builder = self.random.choice(builders)
            entities.append(builder())
        return entities

    def _generate_relationships(
        self, entities: Sequence[MockEntity], record_count: int
    ) -> List[MockRelationship]:
        relationships: List[MockRelationship] = []
        if len(entities) < 2:
            return relationships
        desired = max(6, int(record_count * 1.5))
        seen: set[tuple[str, str, str]] = set()
        while len(relationships) < desired:
            source, target = self.random.sample(list(entities), 2)
            rel_type = self._choose_relationship_type(source.type, target.type)
            key = (source.ingest_id, target.ingest_id, rel_type)
            if key in seen:
                continue
            seen.add(key)
            relationships.append(
                MockRelationship(
                    id=self._uuid(),
                    ingest_id=self._uuid(),
                    type=rel_type,
                    source_id=source.id,
                    source_ingest_id=source.ingest_id,
                    target_id=target.id,
                    target_ingest_id=target.ingest_id,
                    properties=self._relationship_properties(),
                )
            )
        return relationships

    def _generate_audit_events(
        self,
        users: Sequence[MockUser],
        entities: Sequence[MockEntity],
        relationships: Sequence[MockRelationship],
        count: int,
    ) -> List[MockAuditEvent]:
        events: List[MockAuditEvent] = []
        actors = list(users) or [None]
        for _ in range(count):
            action = self.random.choice(
                [
                    "ingest.record",
                    "entity.annotate",
                    "relationship.review",
                    "alert.acknowledge",
                ]
            )
            target_choice = self.random.choice(["entity", "relationship"])
            if target_choice == "entity" and entities:
                target = self.random.choice(list(entities))
                target_id = target.id
            elif relationships:
                target_choice = "relationship"
                target = self.random.choice(list(relationships))
                target_id = target.id
            else:
                target_choice = "entity"
                target_id = self.random.choice(list(entities)).id if entities else self._uuid()
            actor = self.random.choice(actors) if actors else None
            metadata = {
                "source": self.random.choice(self._sources),
                "review_notes": self.faker.sentence(nb_words=8),
                "confidence_delta": round(self.random.uniform(-0.2, 0.2), 2),
                "ingest_batch": self.random.randint(1200, 9800),
            }
            events.append(
                MockAuditEvent(
                    id=self._uuid(),
                    actor_id=actor.id if actor else None,
                    action=action,
                    target_type=target_choice,
                    target_id=target_id,
                    metadata=metadata,
                )
            )
        return events

    def _build_person_entity(self) -> MockEntity:
        full_name = self.faker.name()
        ingest_id = self._uuid()
        properties = self._base_entity_properties()
        properties.update(
            {
                "role": self.random.choice(
                    ["Operative", "Analyst", "Liaison", "Logistics", "Support"]
                ),
                "rank": self.random.choice(["Captain", "Lieutenant", "Specialist", "Director"]),
                "aliases": [self.faker.name() for _ in range(2)],
            }
        )
        return MockEntity(
            id=ingest_id,
            ingest_id=ingest_id,
            type="Person",
            name=full_name,
            properties=properties,
        )

    def _build_org_entity(self) -> MockEntity:
        org_name = f"{self.faker.city()} {self.random.choice(['Observatory', 'Task Force', 'Consortium', 'Network'])}"
        ingest_id = self._uuid()
        properties = self._base_entity_properties()
        properties.update(
            {
                "category": self.random.choice(
                    ["Government", "Private", "Coalition", "Academic", "NGO"]
                ),
                "headquarters": self.faker.city(),
                "sector": self.random.choice(self._sectors),
                "employees": self.random.randint(25, 2500),
            }
        )
        return MockEntity(
            id=ingest_id,
            ingest_id=ingest_id,
            type="Organization",
            name=org_name,
            properties=properties,
        )

    def _build_location_entity(self) -> MockEntity:
        ingest_id = self._uuid()
        city = self.faker.city()
        properties = self._base_entity_properties()
        properties.update(
            {
                "latitude": round(self.random.uniform(-80, 80), 4),
                "longitude": round(self.random.uniform(-180, 180), 4),
                "region": self.faker.country(),
                "sector": "Infrastructure",
            }
        )
        return MockEntity(
            id=ingest_id,
            ingest_id=ingest_id,
            type="Location",
            name=city,
            properties=properties,
        )

    def _build_event_entity(self) -> MockEntity:
        ingest_id = self._uuid()
        event_name = f"Operation {self.faker.color_name()}"
        properties = self._base_entity_properties()
        properties.update(
            {
                "event_type": self.random.choice(
                    ["Recon", "Joint Exercise", "Cyber Incident", "Supply Disruption"]
                ),
                "start_time": self._iso_datetime(-7, -1),
                "status": self.random.choice(["Planned", "Active", "Completed"]),
            }
        )
        return MockEntity(
            id=ingest_id,
            ingest_id=ingest_id,
            type="Event",
            name=event_name,
            properties=properties,
        )

    def _build_asset_entity(self) -> MockEntity:
        ingest_id = self._uuid()
        asset_name = f"Asset-{self.random.randint(1000, 9999)}"
        properties = self._base_entity_properties()
        properties.update(
            {
                "asset_type": self.random.choice(
                    ["Satellite", "Sensor", "Platform", "Outpost", "Data Feed"]
                ),
                "status": self.random.choice(["Operational", "Maintenance", "Degraded"]),
                "sector": self.random.choice(self._sectors),
            }
        )
        return MockEntity(
            id=ingest_id,
            ingest_id=ingest_id,
            type="Asset",
            name=asset_name,
            properties=properties,
        )

    def _base_entity_properties(self) -> Dict[str, object]:
        last_seen = self._iso_datetime(-45, 0)
        return {
            "summary": self.faker.sentence(nb_words=12),
            "classification": self.random.choice(self._classification_levels),
            "confidence": round(self.random.uniform(0.55, 0.98), 2),
            "source": self.random.choice(self._sources),
            "country": self.faker.country(),
            "sector": self.random.choice(self._sectors),
            "last_seen": last_seen,
            "risk_score": round(self.random.uniform(20, 95), 1),
        }

    def _relationship_properties(self) -> Dict[str, object]:
        return {
            "summary": self.faker.sentence(nb_words=10),
            "confidence": round(self.random.uniform(0.5, 0.97), 2),
            "since": self._iso_datetime(-365, -5),
            "source": self.random.choice(self._sources),
            "evidence": self.faker.word(),
        }

    def _choose_relationship_type(self, source_type: str, target_type: str) -> str:
        if source_type == "Person" and target_type == "Organization":
            return "EMPLOYED_BY"
        if source_type == "Organization" and target_type == "Location":
            return "OPERATES_IN"
        if source_type == "Event" and target_type in ("Location", "Organization"):
            return "IMPACTS"
        if source_type == "Person" and target_type == "Event":
            return "INVOLVED_IN"
        return self.random.choice(self._relationship_types)

    def _build_ingest_rows(self, entities: Iterable[MockEntity]) -> List[Dict[str, object]]:
        rows: List[Dict[str, object]] = []
        for entity in entities:
            props = dict(entity.properties)
            rows.append(
                {
                    "id": entity.ingest_id,
                    "type": entity.type,
                    "name": entity.name,
                    "classification": props.get("classification", "UNCLASSIFIED"),
                    "confidence": props.get("confidence", 0.5),
                    "source": props.get("source", "OSINT"),
                    "country": props.get("country", ""),
                    "sector": props.get("sector", ""),
                    "last_seen": props.get("last_seen", self._iso_datetime(-5, 0)),
                    "summary": props.get("summary", ""),
                }
            )
        return rows

    def _render_insert(
        self,
        table: str,
        columns: Sequence[str],
        rows: Sequence[Sequence[object]],
        conflict: Optional[str] = None,
    ) -> List[str]:
        if not rows:
            return []
        column_clause = ", ".join(columns)
        values_clause = ",\n  ".join(
            [
                f"({', '.join(self._sql_value(value) for value in row)})"
                for row in rows
            ]
        )
        statement = [f"INSERT INTO {table} ({column_clause}) VALUES", f"  {values_clause}"]
        if conflict:
            statement.append(f"ON CONFLICT {conflict} DO NOTHING;")
        else:
            statement[-1] += ";"
        return statement

    def _sql_value(self, value: object) -> str:
        if value is None:
            return "NULL"
        if isinstance(value, bool):
            return "TRUE" if value else "FALSE"
        if isinstance(value, (int, float)):
            return str(value)
        if isinstance(value, dict):
            return self._sql_json(value)
        if isinstance(value, (list, tuple)):
            return self._sql_json(list(value))
        text = str(value)
        text = text.replace("'", "''")
        return f"'{text}'"

    def _sql_json(self, value: object) -> str:
        payload = json.dumps(value, separators=(",", ":"))
        payload = payload.replace("'", "''")
        return f"'{payload}'::jsonb"

    def _cypher_map(self, value: Dict[str, object]) -> str:
        items = ", ".join(f"{key}: {self._cypher_value(val)}" for key, val in value.items())
        return "{" + items + "}"

    def _cypher_value(self, value: object) -> str:
        if value is None:
            return "NULL"
        if isinstance(value, bool):
            return "true" if value else "false"
        if isinstance(value, (int, float)):
            return repr(value)
        if isinstance(value, dict):
            return self._cypher_map(value)
        if isinstance(value, (list, tuple)):
            return "[" + ", ".join(self._cypher_value(v) for v in value) + "]"
        return self._cypher_str(str(value))

    def _cypher_str(self, value: str) -> str:
        escaped = value.replace("\\", "\\\\").replace("'", "\\'")
        return f"'{escaped}'"

    def _iso_datetime(self, start_days: int, end_days: int) -> str:
        offset = self.random.uniform(start_days, end_days)
        dt = datetime.utcnow() + timedelta(days=offset)
        return dt.replace(microsecond=0).isoformat() + "Z"

    def _unique_email(self, seen: set[str]) -> str:
        while True:
            email = self.faker.email()
            if email not in seen:
                seen.add(email)
                return email

    def _uuid(self) -> str:
        """Generate a deterministic UUID derived from the generator seed."""

        return str(uuid.UUID(int=self.random.getrandbits(128)))

    def _load_ingest_module(self):
        """Load the ingest wizard module regardless of package naming."""

        try:
            return importlib.import_module("data_pipelines.universal_ingest.ingest")
        except ModuleNotFoundError:
            module_path = (
                Path(__file__).resolve().parents[3]
                / "data-pipelines"
                / "universal-ingest"
                / "ingest.py"
            )
            spec = importlib.util.spec_from_file_location("universal_ingest", module_path)
            if spec is None or spec.loader is None:
                raise ModuleNotFoundError("Unable to load ingest wizard module")
            module = importlib.util.module_from_spec(spec)
            loader = spec.loader
            loader.exec_module(module)  # type: ignore[call-arg]
            return module
