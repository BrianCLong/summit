/**
 * Pull Request automation using GitHub API
 */

import { execSync } from 'child_process';
import { GitHubIssue } from './types.js';

const GITHUB_API = 'https://api.github.com';
const REPO_OWNER = 'BrianCLong';
const REPO_NAME = 'summit';

interface CreatePROptions {
  branchName: string;
  issue: GitHubIssue;
  changes: string[];
  verificationCommand?: string;
  baseBranch?: string;
}

/**
 * Create a pull request for an issue fix
 */
export async function createPullRequest(options: CreatePROptions): Promise<string> {
  const { branchName, issue, changes, verificationCommand, baseBranch = 'main' } = options;

  // Push branch to remote
  console.log(`   üì§ Pushing branch to remote...`);
  try {
    execSync(`git push -u origin ${branchName}`, { stdio: 'pipe' });
  } catch (error) {
    // Branch might already exist
    execSync(`git push origin ${branchName}`, { stdio: 'pipe' });
  }

  // Create PR via GitHub API
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    throw new Error('GITHUB_TOKEN not set - cannot create PR');
  }

  const title = `Fix #${issue.number}: ${issue.title}`;
  const body = generatePRBody(issue, changes, verificationCommand);

  const response = await fetch(`${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/pulls`, {
    method: 'POST',
    headers: {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      title,
      body,
      head: branchName,
      base: baseBranch,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to create PR: ${response.status} ${error}`);
  }

  const pr = await response.json();
  console.log(`   ‚úÖ Pull request created: ${pr.html_url}`);

  // Add labels to PR
  try {
    await addLabelsToPR(pr.number, ['automated-fix', 'issue-sweeper']);
  } catch (error) {
    console.warn(`   ‚ö†Ô∏è  Failed to add labels to PR:`, error);
  }

  return pr.html_url;
}

/**
 * Generate PR body with fix details
 */
function generatePRBody(issue: GitHubIssue, changes: string[], verificationCommand?: string): string {
  let body = `## ü§ñ Automated Fix for Issue #${issue.number}\n\n`;
  body += `This PR automatically resolves issue #${issue.number}.\n\n`;

  body += `### Original Issue\n\n`;
  body += `**Title:** ${issue.title}\n`;
  body += `**Link:** ${issue.html_url}\n\n`;

  body += `### Changes Made\n\n`;
  body += changes.map((change) => `- ${change}`).join('\n');
  body += `\n\n`;

  if (verificationCommand) {
    body += `### Verification\n\n`;
    body += `To verify this fix locally, run:\n\n`;
    body += `\`\`\`bash\n${verificationCommand}\n\`\`\`\n\n`;
  }

  body += `### Testing Checklist\n\n`;
  body += `- [ ] TypeScript compilation passes (\`pnpm typecheck\`)\n`;
  body += `- [ ] Linting passes (\`pnpm lint\`)\n`;
  body += `- [ ] Tests pass (\`pnpm test:quick\`)\n`;
  body += `- [ ] Build succeeds (\`pnpm build\`)\n\n`;

  body += `### Issue Resolution\n\n`;
  body += `Closes #${issue.number}\n\n`;

  body += `---\n`;
  body += `*This PR was automatically generated by the [issue-sweeper](tools/issue-sweeper/) system.*\n`;

  return body;
}

/**
 * Add labels to a PR
 */
async function addLabelsToPR(prNumber: number, labels: string[]): Promise<void> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    return;
  }

  await fetch(`${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/issues/${prNumber}/labels`, {
    method: 'POST',
    headers: {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ labels }),
  });
}

/**
 * Check if PR already exists for an issue
 */
export async function findExistingPR(issueNumber: number): Promise<string | null> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    return null;
  }

  try {
    // Search for PRs mentioning this issue
    const query = `repo:${REPO_OWNER}/${REPO_NAME}+type:pr+${issueNumber}+in:title`;
    const response = await fetch(
      `${GITHUB_API}/search/issues?q=${encodeURIComponent(query)}`,
      {
        headers: {
          Authorization: `token ${token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    if (data.items && data.items.length > 0) {
      return data.items[0].html_url;
    }

    return null;
  } catch (error) {
    console.warn(`   ‚ö†Ô∏è  Failed to search for existing PR:`, error);
    return null;
  }
}

/**
 * Link PR to issue with a comment
 */
export async function linkPRToIssue(issueNumber: number, prUrl: string): Promise<void> {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    return;
  }

  const comment = `## üîó Automated Fix Available\n\nA pull request has been created to fix this issue: ${prUrl}\n\nThe fix will be merged after CI validation passes.\n\n---\n*Automated by issue-sweeper*`;

  await fetch(`${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/issues/${issueNumber}/comments`, {
    method: 'POST',
    headers: {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ body: comment }),
  });

  console.log(`   üí¨ Linked PR to issue #${issueNumber}`);
}

/**
 * Get current branch name
 */
export function getCurrentBranch(): string {
  return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf-8' }).trim();
}

/**
 * Switch back to main branch
 */
export function switchToMainBranch(mainBranch: string = 'main'): void {
  try {
    execSync(`git checkout ${mainBranch}`, { stdio: 'ignore' });
  } catch {
    // Branch might not exist, try master
    try {
      execSync('git checkout master', { stdio: 'ignore' });
    } catch {
      console.warn(`   ‚ö†Ô∏è  Could not switch to ${mainBranch} or master`);
    }
  }
}

/**
 * Delete local branch
 */
export function deleteLocalBranch(branchName: string): void {
  try {
    execSync(`git branch -D ${branchName}`, { stdio: 'ignore' });
    console.log(`   üóëÔ∏è  Deleted local branch: ${branchName}`);
  } catch (error) {
    console.warn(`   ‚ö†Ô∏è  Failed to delete branch ${branchName}:`, error);
  }
}
