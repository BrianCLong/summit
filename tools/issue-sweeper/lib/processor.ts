/**
 * Core issue processing logic
 */

import { GitHubIssue, LedgerEntry, ProcessingResult, SolvedStatus } from './types.js';
import { GitHubClient } from './github.js';
import { classifyIssue, extractKeywords } from './classifier.js';
import { searchForEvidence } from './evidence.js';

/**
 * Process a single issue through the decision pipeline
 */
export async function processIssue(
  issue: GitHubIssue,
  githubClient: GitHubClient
): Promise<ProcessingResult> {
  console.log(`\nðŸ“‹ Processing issue #${issue.number}: ${issue.title}`);

  // Step 1: Classify the issue
  const classification = classifyIssue(issue);
  console.log(`   Classification: ${classification}`);

  // Step 2: Search for evidence of resolution
  const { isSolved, evidence } = await searchForEvidence(issue, githubClient);

  let solved_status: SolvedStatus;
  const actions: string[] = [];

  if (isSolved) {
    solved_status = 'already_solved';
    console.log(`   âœ… Already solved: ${evidence.notes}`);

    // Add comment to issue with evidence
    try {
      const comment = buildEvidenceComment(issue, evidence);
      await githubClient.createComment(issue.number, comment);
      actions.push('commented_with_evidence');
      console.log(`   ðŸ’¬ Added evidence comment`);
    } catch (error) {
      console.warn(`   âš ï¸  Failed to add comment: ${error}`);
    }

    // Close if still open
    if (issue.state === 'open') {
      try {
        await githubClient.closeIssue(issue.number);
        actions.push('closed');
        console.log(`   ðŸ”’ Closed issue`);
      } catch (error) {
        console.warn(`   âš ï¸  Failed to close issue: ${error}`);
      }
    }
  } else {
    // Determine if we should attempt to fix or block
    if (classification === 'question') {
      solved_status = 'blocked';
      evidence.notes = 'Requires clarification from reporter.';
      console.log(`   â¸ï¸  Blocked: Question requires clarification`);
    } else if (classification === 'security') {
      solved_status = 'blocked';
      evidence.notes = 'Security issue requires careful review and responsible disclosure.';
      console.log(`   ðŸ” Blocked: Security issue requires manual review`);
    } else {
      // For now, mark as not_solved - actual fixing logic would go here
      solved_status = 'not_solved';
      evidence.notes = 'Identified as actionable but not yet fixed in this run.';
      console.log(`   ðŸ“ Not solved: Requires implementation`);
    }
  }

  return {
    issue,
    classification,
    solved_status,
    evidence,
    actions,
  };
}

/**
 * Build an evidence comment for an already-solved issue
 */
function buildEvidenceComment(issue: GitHubIssue, evidence: any): string {
  let comment = `## âœ… Issue Resolution Evidence\n\n`;
  comment += `This issue appears to have been resolved.\n\n`;

  if (evidence.prs && evidence.prs.length > 0) {
    comment += `### Related PRs\n\n`;
    comment += evidence.prs.map((pr: string) => `- ${pr}`).join('\n');
    comment += `\n\n`;
  }

  if (evidence.commits && evidence.commits.length > 0) {
    comment += `### Related Commits\n\n`;
    comment += '```\n';
    comment += evidence.commits.join('\n');
    comment += '\n```\n\n';
  }

  if (evidence.notes) {
    comment += `### Notes\n\n${evidence.notes}\n\n`;
  }

  comment += `---\n`;
  comment += `*This comment was automatically generated by the issue sweeper.*\n`;

  return comment;
}

/**
 * Convert a ProcessingResult to a LedgerEntry
 */
export function resultToLedgerEntry(result: ProcessingResult): LedgerEntry {
  return {
    issue_number: result.issue.number,
    title: result.issue.title,
    state: result.issue.state,
    classification: result.classification,
    solved_status: result.solved_status,
    evidence: result.evidence,
    actions_taken: result.actions,
    processed_at: new Date().toISOString(),
  };
}
