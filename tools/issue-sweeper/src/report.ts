/**
 * Report generation for issue sweeper runs
 */

import { writeFile, appendFile } from 'fs/promises';
import { existsSync } from 'fs';
import type { LedgerEntry, RunState, BatchResult } from './types.js';

export class Reporter {
  private reportFile: string;
  private logger: any;

  constructor(reportFile: string, logger?: any) {
    this.reportFile = reportFile;
    this.logger = logger || console;
  }

  /**
   * Initialize report file with header
   */
  async initialize(runId: string, repo: string): Promise<void> {
    const header = `# Issue Sweeper Report

**Repository:** ${repo}
**Run ID:** ${runId}
**Started:** ${new Date().toISOString()}

---

`;

    if (!existsSync(this.reportFile)) {
      await writeFile(this.reportFile, header, 'utf-8');
      this.logger.info('Initialized report file');
    }
  }

  /**
   * Append batch results to report
   */
  async appendBatch(
    batchNumber: number,
    issueRange: { start: number; end: number },
    result: BatchResult,
    entries: LedgerEntry[]
  ): Promise<void> {
    const timestamp = new Date().toISOString();

    const section = `
## Batch ${batchNumber} - ${timestamp}

**Issue Range:** #${issueRange.start} to #${issueRange.end}
**Issues Processed:** ${result.issuesProcessed}

### Results Summary

| Status | Count |
|--------|-------|
| Already Solved | ${result.alreadySolved} |
| Not Solved | ${result.notSolved} |
| Blocked | ${result.blocked} |
| Duplicate | ${result.duplicate} |
| Invalid | ${result.invalid} |
| Errors | ${result.errors} |

### Issue Details

${this.generateIssueTable(entries)}

---

`;

    await appendFile(this.reportFile, section, 'utf-8');
    this.logger.info(`Appended batch ${batchNumber} to report`);
  }

  /**
   * Generate final summary
   */
  async generateSummary(state: RunState, allEntries: LedgerEntry[]): Promise<void> {
    const stats = this.calculateStats(allEntries);

    const summary = `
## Final Summary

**Run Completed:** ${new Date().toISOString()}
**Total Issues Processed:** ${state.processed_count}
**Total Errors:** ${state.error_count}
**Duration:** ${this.calculateDuration(state.run_started_at)}

### Overall Statistics

| Status | Count | Percentage |
|--------|-------|------------|
| Already Solved | ${stats.alreadySolved} | ${this.percentage(stats.alreadySolved, stats.total)}% |
| Not Solved | ${stats.notSolved} | ${this.percentage(stats.notSolved, stats.total)}% |
| Blocked | ${stats.blocked} | ${this.percentage(stats.blocked, stats.total)}% |
| Duplicate | ${stats.duplicate} | ${this.percentage(stats.duplicate, stats.total)}% |
| Invalid | ${stats.invalid} | ${this.percentage(stats.invalid, stats.total)}% |

### By Classification

${this.generateClassificationTable(allEntries)}

### Top Labels

${this.generateTopLabels(allEntries)}

${state.failures.length > 0 ? this.generateFailuresSection(state) : ''}

${state.open_prs.length > 0 ? this.generatePRsSection(state) : ''}

---
*Report generated by Issue Sweeper v1.0*
`;

    await appendFile(this.reportFile, summary, 'utf-8');
    this.logger.info('Generated final summary');
  }

  /**
   * Generate markdown table of issues
   */
  private generateIssueTable(entries: LedgerEntry[]): string {
    if (entries.length === 0) {
      return '*No issues in this batch*';
    }

    const header = '| Issue | Title | Status | Classification | Evidence |\n|-------|-------|--------|----------------|----------|';

    const rows = entries
      .map((entry) => {
        const evidenceSummary = this.summarizeEvidence(entry);
        return `| [#${entry.issue_number}](${entry.url}) | ${this.truncate(entry.title, 50)} | ${entry.solved_status} | ${entry.classification} | ${evidenceSummary} |`;
      })
      .join('\n');

    return `${header}\n${rows}`;
  }

  /**
   * Generate classification breakdown table
   */
  private generateClassificationTable(entries: LedgerEntry[]): string {
    const counts: Record<string, number> = {};

    for (const entry of entries) {
      counts[entry.classification] = (counts[entry.classification] || 0) + 1;
    }

    const header = '| Classification | Count | Percentage |\n|----------------|-------|------------|';

    const total = entries.length;
    const rows = Object.entries(counts)
      .sort(([, a], [, b]) => b - a)
      .map(
        ([classification, count]) =>
          `| ${classification} | ${count} | ${this.percentage(count, total)}% |`
      )
      .join('\n');

    return `${header}\n${rows}`;
  }

  /**
   * Generate top labels list
   */
  private generateTopLabels(entries: LedgerEntry[], limit = 10): string {
    const labelCounts: Record<string, number> = {};

    for (const entry of entries) {
      for (const label of entry.labels) {
        labelCounts[label] = (labelCounts[label] || 0) + 1;
      }
    }

    const sorted = Object.entries(labelCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, limit);

    if (sorted.length === 0) {
      return '*No labels found*';
    }

    return sorted.map(([label, count]) => `- **${label}**: ${count} issues`).join('\n');
  }

  /**
   * Generate failures section
   */
  private generateFailuresSection(state: RunState): string {
    const failures = state.failures.slice(-20); // Show last 20

    return `
### Recent Failures

${failures
  .map(
    (f) =>
      `- **Issue #${f.issue_number}** (${f.step}): ${f.error}\n  *${new Date(f.timestamp).toISOString()}*`
  )
  .join('\n')}
`;
  }

  /**
   * Generate PRs section
   */
  private generatePRsSection(state: RunState): string {
    return `
### Pull Requests Opened

${state.open_prs
  .map((pr) => `- [PR #${pr.pr_number}](${pr.pr_url}) for issue #${pr.issue_number} (branch: \`${pr.branch}\`)`)
  .join('\n')}
`;
  }

  /**
   * Calculate statistics from entries
   */
  private calculateStats(entries: LedgerEntry[]): {
    total: number;
    alreadySolved: number;
    notSolved: number;
    blocked: number;
    duplicate: number;
    invalid: number;
  } {
    const stats = {
      total: entries.length,
      alreadySolved: 0,
      notSolved: 0,
      blocked: 0,
      duplicate: 0,
      invalid: 0,
    };

    for (const entry of entries) {
      switch (entry.solved_status) {
        case 'already_solved':
          stats.alreadySolved++;
          break;
        case 'not_solved':
          stats.notSolved++;
          break;
        case 'blocked':
          stats.blocked++;
          break;
        case 'duplicate':
          stats.duplicate++;
          break;
        case 'invalid':
          stats.invalid++;
          break;
      }
    }

    return stats;
  }

  /**
   * Summarize evidence for display
   */
  private summarizeEvidence(entry: LedgerEntry): string {
    const parts: string[] = [];

    if (entry.evidence.prs.length > 0) {
      const merged = entry.evidence.prs.filter((pr) => pr.mergedAt).length;
      parts.push(`${entry.evidence.prs.length} PR${entry.evidence.prs.length > 1 ? 's' : ''} (${merged} merged)`);
    }

    if (entry.evidence.commits.length > 0) {
      parts.push(`${entry.evidence.commits.length} commit${entry.evidence.commits.length > 1 ? 's' : ''}`);
    }

    return parts.length > 0 ? parts.join(', ') : 'none';
  }

  /**
   * Calculate duration from start time
   */
  private calculateDuration(startTime: string): string {
    const start = new Date(startTime);
    const end = new Date();
    const durationMs = end.getTime() - start.getTime();

    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }

  /**
   * Calculate percentage
   */
  private percentage(value: number, total: number): string {
    if (total === 0) return '0.0';
    return ((value / total) * 100).toFixed(1);
  }

  /**
   * Truncate string to max length
   */
  private truncate(str: string, maxLen: number): string {
    if (str.length <= maxLen) return str;
    return str.substring(0, maxLen - 3) + '...';
  }
}
