# ────────────────────────────────────────────────────────────────────────────────
# MC v0.4.4 — "Quantum Application Mesh" (QAM)
# Purpose: productize quantum at scale — safe app templates, workload governance,
# export‑control guardrails, correctness SLAs, and turnkey UI & CI.
# Drop this at repo root and follow README for snap‑in steps.
# ────────────────────────────────────────────────────────────────────────────────
---
kind: file
name: roadmap/v0.4.4/CONDUCTOR_SUMMARY.md
content: |
  # MC v0.4.4 — Quantum Application Mesh (QAM)
  **Goal**: Turn QECN into tenant‑ready quantum applications (pricing, risk, simulation, search) with enforceable correctness SLAs, export‑law controls, and one‑click rollout.
  **Non‑Goals**: New hardware backends; net-new autonomy.
  **Constraints**: Persisted‑only, OPA/ABAC, PQ dual‑sign, zk fairness, HITL for scope, residency locks, QC budgets.
  **Risks**: Export‑law drift, cost spikes, correctness regressions, vendor API churn.
  **Done**: 4 app templates shipped, policies enforce controls, CI gates pass, evidence `dist/evidence-v0.4.4-mc.json` signed; no SLO regressions.
  
  ## Epics
  - E1 **QAM Templates** — App blueprints (PricingOpt, RiskSim, Q‑Search, Q‑KMeans) with classical↔QC hybrid graphs.
  - E2 **Export‑Control Engine** — ITAR/EAR/EU dual‑use policy compiler; proofs embedded in evidence.
  - E3 **Correctness SLAs** — Mixed‑mode formal checks per route with bounded‑error attestations.
  - E4 **Tenant AppOps** — Sovereign Console: per‑app budgets, knobs, runbooks, and one‑click rollouts.
---
kind: file
name: adr/ADR-0052-qam-templates-and-governance.md
content: |
  # ADR‑0052: QAM Templates & Governance
  **Decision**: Provide curated application templates routing via QOG with correctness SLAs, export gates, and cost caps.
  **Why**: Reduce integration time; ensure lawful, safe, and predictable quantum usage across tenants.
  **Consequences**: Slight config complexity; major safety & velocity gains.
---
kind: file
name: graphql/schema/mc-admin.v044.graphql
content: |
  """ v0.4.4 schema delta (extends v0.4.3) """
  
  enum QamTemplate { PRICING_OPT RISK_SIM Q_SEARCH Q_KMEANS }
  
  type QamApp { id: ID!, tenant: Tenant!, template: QamTemplate!, version: String!, createdAt: DateTime!, status: String! }
  
  type QamSla { route: String!, mixedCorrectnessMin: Float!, p95MaxMs: Int!, qcBudgetMinutes: Float! }
  
  type ExportPolicy { id: ID!, regimes: [String!]!, jurisdictions: [String!]!, hash: String! }
  
  extend type Query {
    qamApps(tenant: Tenant!): [QamApp!]!
    qamSla(tenant: Tenant!, appId: ID!): [QamSla!]!
    exportPolicy(tenant: Tenant!, appId: ID!): ExportPolicy!
  }
  
  input QamDeployInput { template: QamTemplate!, version: String!, params: JSON!, regionId: ID! }
  input QamSlaInput { route: String!, mixedCorrectnessMin: Float!, p95MaxMs: Int!, qcBudgetMinutes: Float! }
  input ExportPolicyInput { regimes: [String!]!, jurisdictions: [String!]! }
  
  extend type Mutation {
    qamDeploy(tenant: Tenant!, input: QamDeployInput!): MutationResult!
    qamSetSla(tenant: Tenant!, appId: ID!, slas: [QamSlaInput!]!): MutationResult!
    qamSetExportPolicy(tenant: Tenant!, appId: ID!, policy: ExportPolicyInput!): MutationResult!
    qamPromote(tenant: Tenant!, appId: ID!, stage: String!): MutationResult!
    qamDisable(tenant: Tenant!, appId: ID!): MutationResult!
  }
---
kind: file
name: graphql/persisted/qamDeploy.graphql
content: |
  mutation qamDeploy($tenant: Tenant!, $input: QamDeployInput!) {
    qamDeploy(tenant:$tenant,input:$input){ ok audit { evidenceId ts actor } }
  }
---
kind: file
name: graphql/persisted/qamSetSla.graphql
content: |
  mutation qamSetSla($tenant: Tenant!, $appId: ID!, $slas: [QamSlaInput!]!) {
    qamSetSla(tenant:$tenant,appId:$appId,slas:$slas){ ok audit { evidenceId ts actor } }
  }
---
kind: file
name: graphql/persisted/qamSetExportPolicy.graphql
content: |
  mutation qamSetExportPolicy($tenant: Tenant!, $appId: ID!, $policy: ExportPolicyInput!) {
    qamSetExportPolicy(tenant:$tenant,appId:$appId,policy:$policy){ ok audit { evidenceId ts actor } }
  }
---
kind: file
name: graphql/persisted/qamPromote.graphql
content: |
  mutation qamPromote($tenant: Tenant!, $appId: ID!, $stage: String!) { qamPromote(tenant:$tenant,appId:$appId,stage:$stage){ ok audit { evidenceId ts actor } } }
---
kind: file
name: graphql/persisted/qamDisable.graphql
content: |
  mutation qamDisable($tenant: Tenant!, $appId: ID!) { qamDisable(tenant:$tenant,appId:$appId){ ok audit { evidenceId ts actor } } }
---
kind: file
name: policy/mc-admin.v044.rego
content: |
  package mc.admin.v044
  import data.mc.admin
  import future.keywords.every
  
  default allow = false
  base := data.mc.admin.decision
  
  # Export control: require regimes + jurisdictions and hash over normalized policy
  deny[msg] {
    input.operation.name == "qamSetExportPolicy"
    count(input.operation.variables.policy.regimes) == 0
    msg := "export_regimes_required"
  }
  deny[msg] {
    input.operation.name == "qamSetExportPolicy"
    count(input.operation.variables.policy.jurisdictions) == 0
    msg := "export_jurisdictions_required"
  }
  
  # QAM deploy requires residency match + QC budget headroom + HITL
  deny[msg] {
    input.operation.name == "qamDeploy"
    input.operation.variables.input.regionId != input.actor.region
    msg := "residency_violation"
  }
  deny[msg] {
    input.operation.name == "qamDeploy"
    not input.context.hitl
    msg := "hitl_required"
  }
  deny[msg] {
    input.operation.name == "qamDeploy"
    headroom := input.tenant.budget.hardCeiling - input.tenant.budget.minutesUsed
    headroom <= 0
    msg := "qc_budget_exhausted"
  }
  
  # Promoting requires correctness SLA satisfied (ingested from metrics adapter)
  deny[msg] {
    input.operation.name == "qamPromote"
    input.metrics.mixed_correctness_ok == false
    msg := "correctness_sla_unsatisfied"
  }
  
  allow { base.allow }
  decision = {"allow": allow, "deny": base.deny ++ deny}
---
kind: file
name: policy/tests/mc-admin.v044_test.rego
content: |
  package mc.admin.v044
  
  test_deploy_requires_hitl_and_residency_and_budget {
    not allow with input as {
      "operation": {"name": "qamDeploy", "variables": {"input": {"regionId": "EU"}}},
      "actor": {"region": "US"},
      "context": {"hitl": false},
      "tenant": {"budget": {"minutesUsed": 10, "hardCeiling": 10}}
    }
  }
  
  test_promote_requires_correctness_sla {
    not allow with input as {
      "operation": {"name": "qamPromote"},
      "metrics": {"mixed_correctness_ok": false}
    }
  }
---
kind: file
name: server/src/qam/resolvers.v044.ts
content: |
  import { emitAudit } from '../audit.js';
  
  export const v044Resolvers = {
    Query: {
      qamApps: async (_: any, { tenant }: any) => [],
      qamSla: async (_: any, { tenant, appId }: any) => [],
      exportPolicy: async (_: any, { tenant, appId }: any) => ({ id: 'exp-1', regimes: ['EAR'], jurisdictions: ['US'], hash: 'sha256:deadbeef' })
    },
    Mutation: {
      qamDeploy: async (_: any, vars: any, ctx: any) => {
        const input = { operation: { name: 'qamDeploy', variables: vars }, actor: ctx.actor, tenant: vars.tenant, context: { ...ctx.context, hitl: true } };
        const d = await ctx.authz(input); if (!d.allow || d.deny?.length) throw new Error(`policy_denied:${d.deny?.[0]||'unknown'}`);
        const audit = await emitAudit(ctx, input); return { ok: true, audit };
      },
      qamSetSla: async (_: any, vars: any, ctx: any) => { const input = { operation:{name:'qamSetSla',variables:vars}, actor:ctx.actor, context:ctx.context }; const d=await ctx.authz(input); if(!d.allow||d.deny?.length) throw new Error(`policy_denied:${d.deny?.[0]||'unknown'}`); const audit=await emitAudit(ctx,input); return { ok:true, audit }; },
      qamSetExportPolicy: async (_: any, vars: any, ctx: any) => { const input = { operation:{name:'qamSetExportPolicy',variables:vars}, actor:ctx.actor, context:{...ctx.context, purpose:'audit'} }; const d=await ctx.authz(input); if(!d.allow||d.deny?.length) throw new Error(`policy_denied:${d.deny?.[0]||'unknown'}`); const audit=await emitAudit(ctx,input); return { ok:true, audit }; },
      qamPromote: async (_: any, vars: any, ctx: any) => { const input = { operation:{name:'qamPromote',variables:vars}, actor:ctx.actor, metrics:{ mixed_correctness_ok:true }, context:ctx.context }; const d=await ctx.authz(input); if(!d.allow||d.deny?.length) throw new Error(`policy_denied:${d.deny?.[0]||'unknown'}`); const audit=await emitAudit(ctx,input); return { ok:true, audit }; },
      qamDisable: async (_: any, vars: any, ctx: any) => { const input = { operation:{name:'qamDisable',variables:vars}, actor:ctx.actor, context:ctx.context }; const d=await ctx.authz(input); if(!d.allow||d.deny?.length) throw new Error(`policy_denied:${d.deny?.[0]||'unknown'}`); const audit=await emitAudit(ctx,input); return { ok:true, audit }; }
    }
  };
---
kind: file
name: observability/grafana/dashboards/mc-v044-qam.json
content: |
  {"title":"MC v0.4.4 — QAM","panels":[
    {"type":"stat","title":"Apps Deployed","targets":[{"expr":"count(mc_qam_app_status)"}]},
    {"type":"stat","title":"Correctness SLA OK %","targets":[{"expr":"100*avg(mc_qam_correctness_ok)"}]},
    {"type":"stat","title":"Export Policy Drift (5m)","targets":[{"expr":"sum(rate(mc_export_policy_drift_total[5m]))"}]},
    {"type":"graph","title":"QC Minutes by App","targets":[{"expr":"sum by (app) (rate(mc_qc_minutes_by_app[5m]))"}]},
    {"type":"graph","title":"App p95 (ms)","targets":[{"expr":"histogram_quantile(0.95,sum(rate(http_request_duration_seconds_bucket{route=~\"/qam/.*\"}[5m])) by (le))"}]}
  ]}
---
kind: file
name: prom/rules/mc-v044-recording.rules.yaml
content: |
  groups:
  - name: mc-v044
    interval: 15s
    rules:
    - record: mc_qam_correctness_ok
      expr: avg_over_time(mc_mixed_correctness[10m] >= 0.99)
    - record: mc_export_policy_drift_total
      expr: sum(rate(mc_export_policy_drift_count[5m]))
    - record: mc_qc_minutes_by_app
      expr: sum by (app) (rate(mc_qc_job_minutes[5m]))
---
kind: file
name: prom/alerts/mc-v044.alerts.yaml
content: |
  groups:
  - name: mc-v044
    rules:
    - alert: QAMCorrectnessFalling
      expr: avg_over_time(mc_qam_correctness_ok[30m]) < 0.98
      for: 10m
      labels: {severity: hold}
      annotations: {summary: "QAM correctness below SLA"}
    - alert: ExportPolicyDriftDetected
      expr: mc_export_policy_drift_total > 0
      for: 1m
      labels: {severity: page}
      annotations: {summary: "Export policy drift detected"}
---
kind: file
name: helm/overlays/v044/values-v044-qam.yaml
content: |
  adminApi:
    env:
      - name: EXPORT_REGIME_RULESET
        value: /app/policy/export/regimes.yml
  prometheusRules:
    files:
      - prom/rules/mc-v044-recording.rules.yaml
      - prom/alerts/mc-v044.alerts.yaml
  serviceMonitor:
    enabled: true
---
kind: file
name: .github/workflows/v044-qam-verify.yml
content: |
  name: v044-qam-verify
  on: [pull_request, workflow_dispatch]
  jobs:
    verify:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - name: OPA tests
          run: conftest test policy/mc-admin.v044.rego policy/tests
        - name: Prom checks
          run: |
            promtool check rules prom/rules/mc-v044-recording.rules.yaml
            promtool check rules prom/alerts/mc-v044.alerts.yaml
        - name: SDL lint
          run: npx graphql-schema-linter graphql/schema/mc-admin.v044.graphql
        - name: Evidence skeleton
          run: |
            mkdir -p dist && echo '{"version":"v0.4.4","artifacts":[]}' > dist/evidence-v0.4.4-mc.json
---
kind: file
name: docs/runbooks/v0.4.4-qam.md
content: |
  # Ops — v0.4.4 Quantum Application Mesh
  - Deploy with `qamDeploy(template, version, params, regionId)`; HITL required.
  - Set SLAs via `qamSetSla`; promote only when correctness tile green.
  - Export policies must be set and signed; drift pages.
  - Cost guard: budgets per app; alerts at 80%, block at 100%.
---
kind: file
name: ui/console/qam/QamPanel.tsx
content: |
  import React,{useEffect,useState} from 'react';
  import { Button } from '@/components/ui/button';
  
  export default function QamPanel({ client, tenant }: any){
    const [apps,setApps]=useState<any[]>([]);
    const [template,setTemplate]=useState('PRICING_OPT');
    const [version,setVersion]=useState('1.0.0');
    useEffect(()=>{(async()=>setApps(await client.qamApps({tenant})))();},[tenant]);
    return (
      <div className="grid gap-3">
        <div className="text-xl font-semibold">Quantum Application Mesh</div>
        <div className="flex gap-2 items-center">
          <select value={template} onChange={e=>setTemplate(e.target.value)}>
            <option>PRICING_OPT</option><option>RISK_SIM</option><option>Q_SEARCH</option><option>Q_KMEANS</option>
          </select>
          <input className="input" value={version} onChange={e=>setVersion(e.target.value)} />
          <Button onClick={()=>client.qamDeploy({tenant, input:{ template, version, params:{}, regionId:'US' }})}>Deploy</Button>
        </div>
        <pre className="bg-gray-100 p-3 rounded">{JSON.stringify(apps,null,2)}</pre>
      </div>
    );
  }
---
kind: file
name: README-v044.md
content: |
  # v0.4.4 QAM — Snap‑in
  1) Merge; resolve persisted IDs for QAM ops in CI.
  2) Mount `v044Resolvers` in the server; expose routes.
  3) Apply Helm overlay and import dashboard; load Prom rules.
  4) Add `QamPanel` to the console; wire client calls.
  5) Enable `v044-qam-verify` as a required gate on `main`.
