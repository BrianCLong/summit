"""Celery NLP-related tasks."""

from typing import Dict, Any
from datetime import datetime

import requests

from ..celery_app import celery_app
from ..monitoring import track_task_processing, track_error


def _post_callback(callback_url: str, payload: Dict[str, Any]) -> None:
    """POST ``payload`` to ``callback_url`` if provided.

    Errors are swallowed but recorded via :func:`track_error` to ensure the
    calling task always completes successfully.
    """
    if not callback_url:
        return
    try:  # pragma: no cover - network failures shouldn't crash tests
        requests.post(callback_url, json=payload, timeout=5)
    except Exception:  # pragma: no cover - defensive
        track_error("nlp_tasks", "CallbackError")


@celery_app.task(bind=True)
@track_task_processing
def task_entity_linking(self, payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Perform entity linking on text.

    Args:
        payload: {
            'text': str,
            'job_id': str,
            'callback_url': str
        }
    """
    job_id = payload.get("job_id", "unknown")
    text = payload.get("text", "")
    callback_url = payload.get("callback_url")

    try:
        # Placeholder for actual entity linking logic
        # In a real scenario, this would involve:
        # 1. Named Entity Recognition (NER) to identify potential entities
        # 2. Entity Disambiguation/Linking to connect them to a knowledge base

        linked_entities = []
        # Simulate NER and Disambiguation
        if "Apple" in text:
            # Simulate disambiguation: Apple Inc. vs Apple (fruit)
            if "company" in text.lower() or "tech" in text.lower():
                linked_entities.append(
                    {
                        "text": "Apple",
                        "label": "ORGANIZATION",
                        "start_char": text.find("Apple"),
                        "end_char": text.find("Apple") + len("Apple"),
                        "entity_id": "Q312",  # Example Wikidata ID for Apple Inc.
                    }
                )
            else:
                linked_entities.append(
                    {
                        "text": "apple",
                        "label": "FRUIT",
                        "start_char": text.find("Apple"),
                        "end_char": text.find("Apple") + len("Apple"),
                        "entity_id": "Q89",  # Example Wikidata ID for Apple (fruit)
                    }
                )
        if "Neo4j" in text:
            linked_entities.append(
                {
                    "text": "Neo4j",
                    "label": "DATABASE",
                    "start_char": text.find("Neo4j"),
                    "end_char": text.find("Neo4j") + len("Neo4j"),
                    "entity_id": "Q1065908",  # Example Wikidata ID for Neo4j
                }
            )
        if "IntelGraph" in text:
            linked_entities.append(
                {
                    "text": "IntelGraph",
                    "label": "ORGANIZATION",
                    "start_char": text.find("IntelGraph"),
                    "end_char": text.find("IntelGraph") + len("IntelGraph"),
                    "entity_id": "intelgraph-org-id",  # Internal ID
                }
            )

        result = {
            "job_id": job_id,
            "kind": "entity_linking",
            "entities": linked_entities,
            "status": "completed",
            "completed_at": datetime.utcnow().isoformat(),
        }

        _post_callback(callback_url, result)

        return result

    except Exception as e:
        track_error("nlp_tasks", "EntityLinkingError")
        return {
            "job_id": job_id,
            "kind": "entity_linking",
            "error": str(e),
            "status": "failed",
            "completed_at": datetime.utcnow().isoformat(),
        }


@celery_app.task(bind=True)
@track_task_processing
def task_relationship_extraction(self, payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Perform relationship extraction on text given identified entities.

    Args:
        payload: {
            'text': str,
            'entities': List[LinkedEntity],
            'job_id': str,
            'callback_url': str
        }
    """
    job_id = payload.get("job_id", "unknown")
    text = payload.get("text", "")
    entities = payload.get("entities", [])
    callback_url = payload.get("callback_url")

    try:
        # Placeholder for actual relationship extraction logic
        # This would involve:
        # 1. Identifying potential relations between entities in the text.
        # 2. Classifying the type of relationship.
        # 3. Assigning a confidence score.

        extracted_relationships = []

        # Example: If "IntelGraph" and "Neo4j" are both in the text, and linked
        # we might infer a "USES" relationship.
        intelgraph_entity = next(
            (e for e in entities if e["text"] == "IntelGraph"), None
        )
        neo4j_entity = next((e for e in entities if e["text"] == "Neo4j"), None)

        if intelgraph_entity and neo4j_entity and "uses" in text.lower():
            extracted_relationships.append(
                {
                    "source_entity_id": intelgraph_entity["entity_id"],
                    "target_entity_id": neo4j_entity["entity_id"],
                    "type": "USES",
                    "confidence": 0.95,
                    "text_span": "IntelGraph uses Neo4j",  # Example span
                }
            )

        result = {
            "job_id": job_id,
            "kind": "relationship_extraction",
            "relationships": extracted_relationships,
            "status": "completed",
            "completed_at": datetime.utcnow().isoformat(),
        }

        _post_callback(callback_url, result)

        return result

    except Exception as e:
        track_error("nlp_tasks", "RelationshipExtractionError")
        return {
            "job_id": job_id,
            "kind": "relationship_extraction",
            "error": str(e),
            "status": "failed",
            "completed_at": datetime.utcnow().isoformat(),
        }
