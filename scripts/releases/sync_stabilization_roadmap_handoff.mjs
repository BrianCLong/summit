import { mkdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import yaml from 'js-yaml';

function parseArgs(argv) {
  const args = {};
  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    if (!arg.startsWith('--')) {
      continue;
    }
    const [key, rawValue] = arg.slice(2).split('=');
    if (rawValue !== undefined) {
      args[key] = rawValue;
    } else {
      args[key] = argv[i + 1];
      i += 1;
    }
  }
  return args;
}

function renderDraft({ candidate, retrospective, outputPath, retrospectivePath }) {
  const lines = [];
  lines.push(`# Stabilization Roadmap Candidate: ${candidate.title}`);
  lines.push('');
  lines.push(`<!-- stabilization-roadmap-slug: ${candidate.slug} -->`);
  lines.push('');
  lines.push('## Problem statement');
  lines.push(
    `Metric trigger: ${candidate.reason} Window ${retrospective.window.start} → ${retrospective.window.end}.`,
  );
  lines.push('');
  lines.push('## Evidence citations');
  lines.push(`- Retrospective: ${retrospectivePath}`);
  retrospective.sources.forEach((source) => {
    lines.push(`- ${source.week_ending}: ${source.scorecard}, ${source.escalation}, ${source.diff}`);
  });
  lines.push('');
  lines.push('## Proposed scope');
  lines.push('Systemic stabilization fix (no feature expansion).');
  lines.push('');
  lines.push('## Acceptance criteria');
  lines.push(
    `- Reduce ${candidate.slug} trigger below policy threshold for two consecutive weeks.`,
  );
  lines.push('');
  lines.push('## Risks/dependencies');
  lines.push('- Deferred pending dependency mapping by release captain.');
  lines.push('');
  lines.push('## Owner routing');
  lines.push('- needs-triage');
  lines.push('');
  lines.push(`Generated by: ${path.basename(outputPath)}`);

  return lines.join('\n');
}

function renderDigest({ candidates, retrospective }) {
  const lines = [];
  lines.push(`# Stabilization Roadmap Handoff Digest (${retrospective.window.start} → ${retrospective.window.end})`);
  lines.push('');
  lines.push('## Candidate summary');
  if (!candidates.length) {
    lines.push('- Deferred pending candidate triggers.');
    return lines.join('\n');
  }
  candidates.forEach((candidate) => {
    lines.push(`- **${candidate.slug}** (${candidate.title}): ${candidate.reason}`);
  });
  lines.push('');
  lines.push('## Next actions');
  lines.push('- Review drafts for policy alignment and approvals.');
  lines.push('- Switch policy mode to apply when governance approves issue creation.');

  return lines.join('\n');
}

async function findIssueBySlug({ repo, token, slug }) {
  const query = encodeURIComponent(
    `repo:${repo} type:issue "stabilization-roadmap-slug: ${slug}"`,
  );
  const response = await fetch(`https://api.github.com/search/issues?q=${query}`, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: 'application/vnd.github+json',
    },
  });
  if (!response.ok) {
    throw new Error(`Failed to search issues: ${response.status}`);
  }
  const payload = await response.json();
  return payload.items?.[0] || null;
}

async function upsertIssue({ repo, token, candidate, body, labels }) {
  const existing = await findIssueBySlug({ repo, token, slug: candidate.slug });
  if (existing) {
    await fetch(`https://api.github.com/repos/${repo}/issues/${existing.number}`, {
      method: 'PATCH',
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github+json',
      },
      body: JSON.stringify({ body, labels }),
    });
    return { action: 'updated', number: existing.number };
  }

  const response = await fetch(`https://api.github.com/repos/${repo}/issues`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: 'application/vnd.github+json',
    },
    body: JSON.stringify({ title: candidate.title, body, labels }),
  });
  if (!response.ok) {
    throw new Error(`Failed to create issue: ${response.status}`);
  }
  const created = await response.json();
  return { action: 'created', number: created.number };
}

export async function syncStabilizationRoadmapHandoff({
  candidatesPath,
  retrospectivePath,
  policyPath,
  outDir,
}) {
  const candidatesRaw = await readFile(candidatesPath, 'utf8');
  const candidatesDoc = JSON.parse(candidatesRaw);
  const retrospectiveRaw = await readFile(retrospectivePath, 'utf8');
  const retrospective = JSON.parse(retrospectiveRaw);
  const policyRaw = await readFile(policyPath, 'utf8');
  const policyDoc = yaml.load(policyRaw);
  const policy = policyDoc.stabilization_roadmap_handoff || {};

  const draftsDir = path.join(outDir, 'drafts');
  await mkdir(draftsDir, { recursive: true });

  const draftPaths = [];
  for (const candidate of candidatesDoc.candidates || []) {
    const draftPath = path.join(draftsDir, `ROADMAP_${candidate.slug}.md`);
    const draftBody = renderDraft({
      candidate,
      retrospective,
      outputPath: draftPath,
      retrospectivePath,
    });
    await writeFile(draftPath, draftBody);
    draftPaths.push(draftPath);
  }

  const digestPath = path.join(outDir, 'digest.md');
  const digestBody = renderDigest({
    candidates: candidatesDoc.candidates || [],
    retrospective,
  });
  await writeFile(digestPath, digestBody);

  if (policy.mode === 'apply') {
    const repo = process.env.GITHUB_REPOSITORY;
    const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
    if (!repo || !token) {
      throw new Error('Apply mode requires GITHUB_REPOSITORY and GITHUB_TOKEN.');
    }
    const baseLabels = policy.labels?.base || [];
    const triageLabels = policy.labels?.triage || [];

    for (const candidate of candidatesDoc.candidates || []) {
      const labels = [
        ...baseLabels,
        ...triageLabels,
        ...(candidate.area_label ? [candidate.area_label] : []),
      ];
      const draftPath = path.join(draftsDir, `ROADMAP_${candidate.slug}.md`);
      const body = await readFile(draftPath, 'utf8');
      await upsertIssue({ repo, token, candidate, body, labels });
    }
  }

  return { draftPaths, digestPath };
}

const __filename = fileURLToPath(import.meta.url);
if (process.argv[1] === __filename) {
  const args = parseArgs(process.argv.slice(2));
  const candidatesPath =
    args.candidates || 'artifacts/stabilization/roadmap-handoff/candidates.json';
  const retrospectivePath =
    args.retrospective || 'artifacts/stabilization/retrospective/retro_latest.json';
  const policyPath = args.policy || 'release-policy.yml';
  const outDir = args['out-dir'] || 'artifacts/stabilization/roadmap-handoff';

  await syncStabilizationRoadmapHandoff({
    candidatesPath,
    retrospectivePath,
    policyPath,
    outDir,
  });
}
