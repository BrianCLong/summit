#!/usr/bin/env node

import { program } from 'commander';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = path.resolve(__dirname, '..', '..');

const SCRIPT_VERSION = '1.0.0';

/**
 * Generates a Markdown table row for a control.
 * @param {object} control - The control object from the catalog.
 * @param {object} bundleIndex - The parsed bundle-index.json content.
 * @returns {string} A Markdown table row.
 */
function generateControlRow(control, bundleIndex) {
  const evidenceLinks = [];
  const verificationSteps = [];

  control.evidence.forEach(ev => {
    let evidencePath = 'N/A';
    let verification = 'Manual review required.';

    const [sourceType, sourceValue] = ev.source.split(':');

    switch (sourceType) {
      case 'bundle':
        evidencePath = bundleIndex.pointers[sourceValue] || `Missing pointer for '${sourceValue}'`;
        verification = `Inspect the artifact at \`${evidencePath}\`.`;
        break;
      case 'repo':
      case 'docs':
        evidencePath = sourceValue;
        verification = `View the file at \`${evidencePath}\` in the repository.`;
        break;
      case 'ci':
        evidencePath = `CI Job: ${sourceValue}`;
        verification = `Verify the status of the '${sourceValue}' job in the CI/CD pipeline for the target commit.`;
        break;
      default:
        evidencePath = 'Unknown source type.';
    }
    evidenceLinks.push(`**${ev.name}**: [\`${evidencePath}\`](${evidencePath})<br>_Note: ${ev.notes}_`);
    verificationSteps.push(verification);
  });

  const evidenceString = evidenceLinks.join('<br><br>');
  const verificationString = verificationSteps.join('<br><br>');
  const exceptions = 'None'; // Placeholder for future implementation

  return `| ${control.id} | ${control.area} | ${control.statement} | ${evidenceString} | ${verificationString} | ${exceptions} |`;
}

/**
 * Main function to generate the compliance snapshot.
 * @param {string} target - The release target (e.g., git SHA or tag).
 * @param {string} bundleIndexPath - Path to the bundle-index.json file.
 * @param {string} outputPath - Path to write the output Markdown file.
 */
function generateSnapshot(target, bundleIndexPath, outputPath) {
  const catalogPath = path.resolve(REPO_ROOT, 'docs/releases/compliance/CONTROLS_CATALOG.yml');

  if (!fs.existsSync(catalogPath)) {
    console.error(`Error: Controls catalog not found at ${catalogPath}`);
    process.exit(1);
  }
  if (!fs.existsSync(bundleIndexPath)) {
    console.error(`Error: Bundle index not found at ${bundleIndexPath}`);
    process.exit(1);
  }

  const catalog = yaml.load(fs.readFileSync(catalogPath, 'utf8'));
  const bundleIndex = JSON.parse(fs.readFileSync(bundleIndexPath, 'utf8'));
  const generatedAt = new Date().toISOString();

  let markdown = `
# Compliance Snapshot for ${target}

---

## A) Scope and Disclaimers

**THIS IS NOT A CERTIFICATION OR ATTESTATION OF COMPLIANCE.**

This document is an auto-generated snapshot that maps internal controls to objective evidence produced by the CI/CD pipeline and other project artifacts. It is intended for internal review and to facilitate evidence gathering for formal audits. The presence of a control in this document does not imply it has been formally assessed or validated by a third party.

---

## B) System and Release Identity

| Item                  | Value                               |
| --------------------- | ----------------------------------- |
| **Release Target**    | \`${target}\`                       |
| **Release Channel**   | \`${bundleIndex.channel}\`          |
| **Generated At**      | \`${generatedAt}\`                  |
| **Generator Version** | \`v${SCRIPT_VERSION}\`               |
| **Bundle Index SHA**  | \`${bundleIndex.files.find(f => f.path.endsWith('bundle-index.json'))?.sha256 || 'N/A'}\` |

---

## C) Controls → Evidence Map

| Control ID | Control Area | Control Statement | Evidence | How to Verify | Exceptions/Waivers |
|------------|--------------|-------------------|----------|---------------|--------------------|
`;

  for (const control of catalog.controls) {
    markdown += `${generateControlRow(control, bundleIndex)}\n`;
  }

  markdown += `
---

## D) Open Risks / Exceptions Summary

*This section is a placeholder for a future implementation that will dynamically pull in data from waiver and security exception reports.*

- **Waivers**: No active waivers for this release.
- **Security Exceptions**: No active security exceptions for this release.

---

## E) Regeneration Instructions

This document was generated by the \`generate_compliance_snapshot.mjs\` script. To regenerate it, run the following command from the repository root, pointing to a valid release evidence bundle:

\`\`\`bash
scripts/releases/generate_compliance_snapshot.mjs --target <git-sha-or-tag> --bundle-index <path/to/bundle-index.json> --output <path/to/output.md>
\`\`\`
`;

  fs.writeFileSync(outputPath, markdown.trim());
  console.log(`✅ Compliance snapshot successfully generated at: ${outputPath}`);
}

program
  .name('generate-compliance-snapshot')
  .description('Generates a compliance snapshot from a release evidence bundle.')
  .version(SCRIPT_VERSION)
  .requiredOption('--target <string>', 'The release target (e.g., git SHA or tag)')
  .requiredOption('--bundle-index <path>', 'Path to the bundle-index.json file')
  .requiredOption('--output <path>', 'Path to write the output Markdown file')
  .action((options) => {
    generateSnapshot(options.target, options.bundleIndex, options.output);
  });

program.parse(process.argv);
