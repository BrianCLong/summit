#!/usr/bin/env node
/**
 * GraphQL API Compatibility Check (N-2)
 *
 * Compares current introspection against baselines (N-1, N-2) if present.
 * Fails on breaking removals (types, fields, enum values).
 *
 * Inputs:
 *  - Current: server/src/generated/introspection.json (generated by codegen)
 *  - Baselines: docs/generated/compat/baseline.N-1.json, baseline.N-2.json (optional)
 */
import fs from 'fs';
import path from 'path';

const ROOT = process.cwd();
const currentPath = path.join(ROOT, 'server/src/generated/introspection.json');
const baselinesDir = path.join(ROOT, 'docs/generated/compat');
const baselineFiles = [
  path.join(baselinesDir, 'baseline.N-1.json'),
  path.join(baselinesDir, 'baseline.N-2.json'),
];

function loadJson(p) {
  return JSON.parse(fs.readFileSync(p, 'utf8'));
}

function indexByName(arr = []) {
  const map = new Map();
  for (const v of arr || []) {
    if (v && v.name) map.set(v.name, v);
  }
  return map;
}

function getTypeMap(introspection) {
  const types =
    introspection?.data?.__schema?.types ||
    introspection?.__schema?.types ||
    [];
  return indexByName(types);
}

function unwrapType(t) {
  // Strip NON_NULL and LIST wrappers
  while (t && (t.kind === 'NON_NULL' || t.kind === 'LIST')) t = t.ofType;
  return t;
}

function fieldMap(type) {
  return indexByName(type?.fields || []);
}

function enumValueSet(type) {
  return new Set((type?.enumValues || []).map((v) => v.name));
}

function compareBaseline(baseline, current) {
  const out = { breaking: [], warnings: [] };
  const bTypes = getTypeMap(baseline);
  const cTypes = getTypeMap(current);

  for (const [typeName, bType] of bTypes.entries()) {
    if (typeName.startsWith('__')) continue;
    const cType = cTypes.get(typeName);
    if (!cType) {
      out.breaking.push(`Type removed: ${typeName}`);
      continue;
    }

    if (bType.kind === 'OBJECT' || bType.kind === 'INTERFACE') {
      const bFields = fieldMap(bType);
      const cFields = fieldMap(cType);
      for (const [fieldName, bField] of bFields.entries()) {
        const cField = cFields.get(fieldName);
        if (!cField) {
          out.breaking.push(`Field removed: ${typeName}.${fieldName}`);
          continue;
        }
        // Optional: check base named type compatibility (ignore nullability/lists for simplicity)
        const bNamed = unwrapType(bField.type);
        const cNamed = unwrapType(cField.type);
        if (bNamed?.name && cNamed?.name && bNamed.name !== cNamed.name) {
          out.breaking.push(
            `Field type changed: ${typeName}.${fieldName} ${bNamed.name} -> ${cNamed.name}`,
          );
        }
      }
    }

    if (bType.kind === 'ENUM') {
      const bVals = enumValueSet(bType);
      const cVals = enumValueSet(cType);
      for (const v of bVals) {
        if (!cVals.has(v))
          out.breaking.push(`Enum value removed: ${typeName}.${v}`);
      }
    }
  }

  return out;
}

function main() {
  if (!fs.existsSync(currentPath)) {
    console.log(
      `[compat] Current introspection not found at ${currentPath}. Run: cd server && npm run codegen`,
    );
    process.exit(0);
  }
  const current = loadJson(currentPath);
  const missing = baselineFiles.filter((p) => !fs.existsSync(p));
  if (missing.length > 0) {
    console.log(
      `[compat] Baselines missing (${missing.map((p) => path.basename(p)).join(', ')}). Skipping compatibility check.`,
    );
    console.log(
      `[compat] To enable N-2 checks, add baseline files under docs/generated/compat/`,
    );
    process.exit(0);
  }

  const reports = [];
  let breakingCount = 0;
  for (const bPath of baselineFiles) {
    const baseline = loadJson(bPath);
    const res = compareBaseline(baseline, current);
    breakingCount += res.breaking.length;
    reports.push({ baseline: path.basename(bPath), ...res });
  }

  // Emit report
  const reportMd = [
    '# API Compatibility Report (N-2)',
    '',
    ...reports.flatMap((r) => [
      `## ${r.baseline}`,
      r.breaking.length ? `- Breaking: ${r.breaking.length}` : '- Breaking: 0',
      r.breaking.length ? r.breaking.map((x) => `  - ${x}`).join('\n') : '',
      r.warnings.length ? `- Warnings: ${r.warnings.length}` : '- Warnings: 0',
      '',
    ]),
  ].join('\n');

  const outDir = baselinesDir;
  fs.mkdirSync(outDir, { recursive: true });
  fs.writeFileSync(path.join(outDir, 'report.md'), reportMd);

  if (breakingCount > 0) {
    console.error(
      `[compat] Breaking changes detected. See docs/generated/compat/report.md`,
    );
    process.exit(1);
  }
  console.log('[compat] No breaking changes detected.');
}

main();
