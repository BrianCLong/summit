#!/usr/bin/env node

/**
 * Badge JSON Generator
 *
 * Generates JSON files for dynamic badge endpoints based on maintainability metrics.
 * Used by GitHub Actions to create shields.io compatible badge data.
 *
 * Usage:
 *   node scripts/generate-badge-json.cjs
 *
 * Requires:
 *   - maintainability-report.json (generated by maintainability-report.cjs)
 *
 * Outputs:
 *   - badges/maintainability-score.json
 *   - badges/large-files.json
 *   - badges/technical-debt.json
 *   - badges/duplication.json
 */

const fs = require('fs');
const path = require('path');

// Configuration
const INPUT_FILE = 'maintainability-report.json';
const OUTPUT_DIR = 'badges';

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Load metrics data
let metrics;
try {
  metrics = JSON.parse(fs.readFileSync(INPUT_FILE, 'utf8'));
} catch (error) {
  console.error(`Error reading ${INPUT_FILE}:`, error.message);
  console.error('Run "pnpm run metrics:report:json" first to generate metrics data.');
  process.exit(1);
}

/**
 * Calculate overall maintainability score (0-100)
 */
function calculateMaintainabilityScore(metrics) {
  let score = 100;

  // Deduct points for large files (max -30 points)
  const largeFileRatio = metrics.fileSize.largeFiles.length / metrics.fileSize.total;
  score -= Math.min(largeFileRatio * 100, 30);

  // Deduct points for technical debt (max -20 points)
  const debtPerFile = metrics.debt.total / metrics.fileSize.total;
  score -= Math.min(debtPerFile * 200, 20);

  // Deduct points for duplication (max -25 points)
  if (metrics.duplication.available) {
    score -= Math.min(metrics.duplication.percentage * 5, 25);
  }

  // Deduct points for extreme files (max -25 points)
  const extremeFileRatio = metrics.fileSize.bySize.extreme / metrics.fileSize.total;
  score -= Math.min(extremeFileRatio * 250, 25);

  return Math.max(0, Math.round(score));
}

/**
 * Get color based on value and thresholds
 */
function getColor(value, thresholds) {
  if (value >= thresholds.excellent) return 'brightgreen';
  if (value >= thresholds.good) return 'green';
  if (value >= thresholds.acceptable) return 'yellowgreen';
  if (value >= thresholds.needsWork) return 'yellow';
  if (value >= thresholds.poor) return 'orange';
  return 'red';
}

/**
 * Get inverted color (for metrics where lower is better)
 */
function getInvertedColor(value, thresholds) {
  if (value <= thresholds.excellent) return 'brightgreen';
  if (value <= thresholds.good) return 'green';
  if (value <= thresholds.acceptable) return 'yellowgreen';
  if (value <= thresholds.needsWork) return 'yellow';
  if (value <= thresholds.poor) return 'orange';
  return 'red';
}

/**
 * Create badge JSON
 */
function createBadge(label, message, color) {
  return {
    schemaVersion: 1,
    label,
    message,
    color,
  };
}

// Generate badges
const badges = {};

// 1. Overall Maintainability Score
const score = calculateMaintainabilityScore(metrics);
const scoreGrade =
  score >= 90 ? 'A' : score >= 80 ? 'B' : score >= 70 ? 'C' : score >= 60 ? 'D' : 'F';

badges.maintainabilityScore = createBadge(
  'maintainability',
  `${scoreGrade} (${score}/100)`,
  getColor(score, {
    excellent: 90,
    good: 80,
    acceptable: 70,
    needsWork: 60,
    poor: 50,
  })
);

// 2. Large Files
const largeFilePercent = (
  (metrics.fileSize.largeFiles.length / metrics.fileSize.total) *
  100
).toFixed(1);

badges.largeFiles = createBadge(
  'files >500 lines',
  `${metrics.fileSize.largeFiles.length} (${largeFilePercent}%)`,
  getInvertedColor(parseFloat(largeFilePercent), {
    excellent: 5,
    good: 10,
    acceptable: 15,
    needsWork: 20,
    poor: 30,
  })
);

// 3. Technical Debt
const debtPerFile = (metrics.debt.total / metrics.fileSize.total).toFixed(2);

badges.technicalDebt = createBadge(
  'technical debt',
  `${metrics.debt.total} TODOs (${debtPerFile}/file)`,
  getInvertedColor(parseFloat(debtPerFile), {
    excellent: 0.05,
    good: 0.1,
    acceptable: 0.15,
    needsWork: 0.2,
    poor: 0.3,
  })
);

// 4. Code Duplication
if (metrics.duplication.available) {
  badges.duplication = createBadge(
    'duplication',
    `${metrics.duplication.percentage.toFixed(1)}%`,
    getInvertedColor(metrics.duplication.percentage, {
      excellent: 3,
      good: 5,
      acceptable: 7,
      needsWork: 10,
      poor: 15,
    })
  );
} else {
  badges.duplication = createBadge('duplication', 'N/A', 'lightgrey');
}

// 5. Total Files
badges.totalFiles = createBadge('total files', metrics.fileSize.total.toString(), 'blue');

// 6. Lines of Code
if (metrics.loc && metrics.loc.available) {
  const locFormatted = metrics.loc.total.toLocaleString();
  badges.linesOfCode = createBadge('lines of code', locFormatted, 'blue');
}

// 7. Extreme Files (>1500 lines)
const extremeCount = metrics.fileSize.bySize.extreme;
badges.extremeFiles = createBadge(
  'files >1500 lines',
  extremeCount.toString(),
  extremeCount === 0 ? 'brightgreen' : extremeCount < 10 ? 'yellow' : 'red'
);

// Write badge files
Object.entries(badges).forEach(([name, badge]) => {
  const outputFile = path.join(OUTPUT_DIR, `${name}.json`);
  fs.writeFileSync(outputFile, JSON.stringify(badge, null, 2), 'utf8');
  console.log(`✓ Generated ${outputFile}`);
});

// Create summary file with all badges
const summary = {
  generatedAt: new Date().toISOString(),
  metrics: {
    score,
    scoreGrade,
    totalFiles: metrics.fileSize.total,
    largeFiles: metrics.fileSize.largeFiles.length,
    extremeFiles: metrics.fileSize.bySize.extreme,
    technicalDebt: metrics.debt.total,
    duplication: metrics.duplication.available ? metrics.duplication.percentage : null,
    linesOfCode: metrics.loc?.total || null,
  },
  badges,
};

fs.writeFileSync(
  path.join(OUTPUT_DIR, 'summary.json'),
  JSON.stringify(summary, null, 2),
  'utf8'
);
console.log(`✓ Generated ${path.join(OUTPUT_DIR, 'summary.json')}`);

// Create README with badge markdown
const badgeReadme = `# Maintainability Badges

Generated: ${new Date().toISOString()}

## Shields.io Compatible Badges

### Maintainability Score
\`\`\`markdown
![Maintainability](https://img.shields.io/badge/${encodeURIComponent(badges.maintainabilityScore.label)}-${encodeURIComponent(badges.maintainabilityScore.message)}-${badges.maintainabilityScore.color})
\`\`\`

### Large Files
\`\`\`markdown
![Large Files](https://img.shields.io/badge/${encodeURIComponent(badges.largeFiles.label)}-${encodeURIComponent(badges.largeFiles.message)}-${badges.largeFiles.color})
\`\`\`

### Technical Debt
\`\`\`markdown
![Technical Debt](https://img.shields.io/badge/${encodeURIComponent(badges.technicalDebt.label)}-${encodeURIComponent(badges.technicalDebt.message)}-${badges.technicalDebt.color})
\`\`\`

### Code Duplication
\`\`\`markdown
![Duplication](https://img.shields.io/badge/${encodeURIComponent(badges.duplication.label)}-${encodeURIComponent(badges.duplication.message)}-${badges.duplication.color})
\`\`\`

## Current Values

- **Maintainability Score:** ${scoreGrade} (${score}/100)
- **Total Files:** ${metrics.fileSize.total}
- **Large Files (>500 lines):** ${metrics.fileSize.largeFiles.length} (${largeFilePercent}%)
- **Extreme Files (>1500 lines):** ${metrics.fileSize.bySize.extreme}
- **Technical Debt Markers:** ${metrics.debt.total}
${metrics.duplication.available ? `- **Code Duplication:** ${metrics.duplication.percentage.toFixed(1)}%` : ''}
${metrics.loc?.available ? `- **Lines of Code:** ${metrics.loc.total.toLocaleString()}` : ''}

## Rendered Badges

![Maintainability](https://img.shields.io/badge/${encodeURIComponent(badges.maintainabilityScore.label)}-${encodeURIComponent(badges.maintainabilityScore.message)}-${badges.maintainabilityScore.color})
![Large Files](https://img.shields.io/badge/${encodeURIComponent(badges.largeFiles.label)}-${encodeURIComponent(badges.largeFiles.message)}-${badges.largeFiles.color})
![Technical Debt](https://img.shields.io/badge/${encodeURIComponent(badges.technicalDebt.label)}-${encodeURIComponent(badges.technicalDebt.message)}-${badges.technicalDebt.color})
![Duplication](https://img.shields.io/badge/${encodeURIComponent(badges.duplication.label)}-${encodeURIComponent(badges.duplication.message)}-${badges.duplication.color})

---

*Generated by generate-badge-json.cjs*
`;

fs.writeFileSync(path.join(OUTPUT_DIR, 'README.md'), badgeReadme, 'utf8');
console.log(`✓ Generated ${path.join(OUTPUT_DIR, 'README.md')}`);

console.log('\n✅ All badge files generated successfully!');
console.log(`\nMaintainability Score: ${scoreGrade} (${score}/100)`);
