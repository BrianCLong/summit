import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const REPO_ROOT = path.resolve(__dirname, '../../');
const INDEX_YAML_PATH = path.join(REPO_ROOT, 'docs/governance/INDEX.yml');
const INDEX_MD_PATH = path.join(REPO_ROOT, 'docs/governance/INDEX.md');
const CI_CORE_PATH = path.join(REPO_ROOT, '.github/workflows/ci-core.yml');

// Helper to resolve paths relative to repo root
const resolvePath = (p) => path.join(REPO_ROOT, p);

function loadIndex() {
  if (!fs.existsSync(INDEX_YAML_PATH)) {
    throw new Error(`INDEX.yml not found at ${INDEX_YAML_PATH}`);
  }
  const content = fs.readFileSync(INDEX_YAML_PATH, 'utf8');
  return yaml.load(content);
}

function getCiJobNames() {
  if (!fs.existsSync(CI_CORE_PATH)) {
    console.warn(`Warning: CI workflow not found at ${CI_CORE_PATH}. Skipping validation against active jobs.`);
    return null;
  }
  try {
    const content = fs.readFileSync(CI_CORE_PATH, 'utf8');
    const workflow = yaml.load(content);
    if (!workflow || !workflow.jobs) return [];

    return Object.values(workflow.jobs)
      .map(job => job.name)
      .filter(Boolean);
  } catch (e) {
    console.warn(`Warning: Failed to parse CI workflow: ${e.message}`);
    return null;
  }
}

function generateMarkdown(index) {
  let md = `# ${index.title}\n\n`;
  md += `${index.description}\n\n`;

  if (!index.sections || index.sections.length === 0) {
    md += `*No sections defined.*\n`;
    return md;
  }

  for (const section of index.sections) {
    md += `## ${section.title}\n\n`;
    if (section.description) {
      md += `${section.description}\n\n`;
    }

    if (section.gates && section.gates.length > 0) {
      md += `| Gate | Status | Owner | Enforcement |\n`;
      md += `| :--- | :--- | :--- | :--- |\n`;

      for (const gate of section.gates) {
        md += `| **${gate.name}** | ${gate.status || 'Active'} | ${gate.owner || 'Unknown'} | ${gate.enforcement || 'Blocking'} |\n`;
      }
      md += `\n`;
    } else {
      md += `*No gates defined in this section.*\n\n`;
    }
  }

  // Deterministic footer
  md += `\n---\n*Generated by scripts/ci/verify_governance_docs.mjs. Do not edit manually.*\n`;

  return md;
}

function validate(index, availableGates = null) {
  const errors = [];

  if (!index.version || index.version !== 2) {
    errors.push('INDEX.yml must have version: 2');
  }

  if (index.sections) {
      index.sections.forEach((section, sIdx) => {
          if (!section.title) errors.push(`Section ${sIdx} missing title`);
          if (section.gates) {
              section.gates.forEach((gate, gIdx) => {
                  if (!gate.name) errors.push(`Section ${section.title} Gate ${gIdx} missing name`);

                  // Validation against real CI jobs
                  if (availableGates && gate.status === 'Active') {
                      if (!availableGates.includes(gate.name)) {
                           // Try to fuzzy match or just warn? Requirement is "enforcement".
                           // But we should be careful about false positives.
                           // For now, exact match on "name" which corresponds to job "name".
                           errors.push(`Active gate '${gate.name}' not found in CI Core jobs.`);
                      }
                  }
              });
          }
      });
  }

  return errors;
}

async function main() {
  const isFix = process.argv.includes('--fix');

  try {
    const index = loadIndex();
    const availableGates = getCiJobNames();

    // Validation
    const validationErrors = validate(index, availableGates);
    if (validationErrors.length > 0) {
        console.error('Validation Errors:');
        validationErrors.forEach(e => console.error(`- ${e}`));
        process.exit(1);
    }

    const generatedMd = generateMarkdown(index);

    if (isFix) {
      fs.writeFileSync(INDEX_MD_PATH, generatedMd, 'utf8');
      console.log(`Successfully generated ${INDEX_MD_PATH}`);
    } else {
      // Check for drift
      if (!fs.existsSync(INDEX_MD_PATH)) {
        console.error(`Error: ${INDEX_MD_PATH} does not exist. Run with --fix to generate.`);
        process.exit(1);
      }

      const currentMd = fs.readFileSync(INDEX_MD_PATH, 'utf8');
      if (currentMd !== generatedMd) {
        console.error(`Error: ${INDEX_MD_PATH} is out of sync with INDEX.yml.`);
        console.error(`Run 'pnpm ci:docs-governance:fix' to update.`);
        process.exit(1);
      }
      console.log('Docs integrity check passed.');
    }

  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { generateMarkdown, validate, loadIndex, getCiJobNames };
