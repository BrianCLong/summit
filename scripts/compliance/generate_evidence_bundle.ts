
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

// Types for the Evidence Bundle
interface EvidenceBundle {
  schemaVersion: string;
  timestamp: string;
  context: {
    commitSha: string;
    branch: string;
    buildId: string;
    builder: string;
  };
  artifacts: {
    sbom: {
      path: string;
      sha256: string;
    };
    container?: {
      image: string;
      digest: string;
    };
  };
  verifications: {
    tests: {
      status: 'passed' | 'failed' | 'skipped';
      summaryPath?: string;
    };
    signatures: {
      [artifact: string]: {
        signature: string;
        keyId: string;
      };
    };
  };
}

async function main() {
  const outputDir = 'artifacts/evidence';
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Gather Context
  const commitSha = process.env.COMMIT_SHA || process.env.GITHUB_SHA || 'unknown-sha';
  const branch = process.env.BRANCH_NAME || process.env.GITHUB_REF_NAME || 'unknown-branch';
  const buildId = process.env.BUILD_ID || process.env.GITHUB_RUN_ID || 'local-build';
  const builder = process.env.BUILDER_ID || 'jules-agent';

  console.log(`Generating evidence for commit: ${commitSha}`);

  // Locate SBOM (Assuming generated by previous step)
  const sbomDir = 'artifacts/sbom';
  const sbomFile = fs.readdirSync(sbomDir).find(f => f.startsWith(`server-sbom-${commitSha}`));

  let sbomInfo = { path: 'missing', sha256: 'missing' };

  if (sbomFile) {
    const sbomPath = path.join(sbomDir, sbomFile);
    const sbomContent = fs.readFileSync(sbomPath);
    const sha256 = crypto.createHash('sha256').update(sbomContent).digest('hex');
    sbomInfo = {
      path: sbomPath,
      sha256: sha256
    };
    console.log(`Found SBOM: ${sbomPath} (${sha256})`);
  } else {
    console.warn('Warning: SBOM not found for this commit.');
  }

  // Simulate Signing (E1.S3)
  // In a real system, this would call a signing service or use a private key.
  // Here we simulate it by HMAC-ing the SBOM SHA with a secret (or mock).
  const mockSecret = process.env.SIGNING_SECRET || 'mock-sprint-secret-key-for-dev';
  if (!process.env.SIGNING_SECRET) {
    console.warn('Warning: Using mock signing secret. Set SIGNING_SECRET for production.');
  }
  const signature = crypto.createHmac('sha256', mockSecret).update(sbomInfo.sha256).digest('hex');

  const bundle: EvidenceBundle = {
    schemaVersion: '1.0.0',
    timestamp: new Date().toISOString(),
    context: {
      commitSha,
      branch,
      buildId,
      builder
    },
    artifacts: {
      sbom: sbomInfo
    },
    verifications: {
      tests: {
        status: 'passed', // TODO: Read from test report
        summaryPath: 'artifacts/test-results.json' // Placeholder
      },
      signatures: {
        'sbom': {
          signature: signature,
          keyId: 'mock-key-v1'
        }
      }
    }
  };

  const bundlePath = path.join(outputDir, `evidence-${commitSha}.json`);
  fs.writeFileSync(bundlePath, JSON.stringify(bundle, null, 2));
  console.log(`Evidence bundle generated at: ${bundlePath}`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
