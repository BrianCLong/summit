name: Release Cut

on:
  workflow_dispatch:
    inputs:
      sha:
        description: 'Commit SHA to release'
        required: true
      channel:
        description: 'Release Channel'
        required: true
        type: choice
        options:
          - rc
          - ga
      apply:
        description: 'Apply release (requires approval)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      eligible: ${{ steps.check.outputs.eligible }}
      sha: ${{ steps.vars.outputs.sha }}
      channel: ${{ steps.vars.outputs.channel }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Run Eligibility Check
        id: check
        continue-on-error: true # Continue to upload plan even if failed
        run: |
          echo "Running eligibility checks..."
          # Using the existing verification test as the eligibility gate
          # Using vitest explicitly since the test file uses global 'describe'
          if npx vitest run scripts/verify-evidence-bundle.test.ts --globals; then
            echo "eligible=true" >> $GITHUB_OUTPUT
            echo "ELIGIBLE_BOOL=true" >> $GITHUB_ENV
          else
            echo "eligible=false" >> $GITHUB_OUTPUT
            echo "ELIGIBLE_BOOL=false" >> $GITHUB_ENV
            # We don't exit here yet, we want to generate the plan first
          fi

      - name: Set Vars
        id: vars
        run: |
          echo "sha=${{ inputs.sha }}" >> $GITHUB_OUTPUT
          echo "channel=${{ inputs.channel }}" >> $GITHUB_OUTPUT

          # Prepare Plan Artifact
          mkdir -p artifacts/release-cut

          # Machine readable plan
          echo "{" > artifacts/release-cut/plan.json
          echo "  \"sha\": \"${{ inputs.sha }}\"," >> artifacts/release-cut/plan.json
          echo "  \"channel\": \"${{ inputs.channel }}\"," >> artifacts/release-cut/plan.json
          echo "  \"eligible\": ${{ env.ELIGIBLE_BOOL }}" >> artifacts/release-cut/plan.json
          echo "}" >> artifacts/release-cut/plan.json

          # Human readable plan
          echo "# Release Plan" > artifacts/release-cut/plan.md
          echo "- **SHA**: ${{ inputs.sha }}" >> artifacts/release-cut/plan.md
          echo "- **Channel**: ${{ inputs.channel }}" >> artifacts/release-cut/plan.md
          echo "- **Eligible**: ${{ env.ELIGIBLE_BOOL }}" >> artifacts/release-cut/plan.md

          cat artifacts/release-cut/plan.md >> $GITHUB_STEP_SUMMARY

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: release-plan
          path: artifacts/release-cut

      - name: Check Eligibility Status
        if: ${{ env.ELIGIBLE_BOOL != 'true' }}
        run: |
          echo "Eligibility checks failed."
          exit 1

  apply:
    needs: plan
    runs-on: ubuntu-latest
    environment: release-approval
    if: ${{ inputs.apply == true && needs.plan.outputs.eligible == 'true' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha }}
          fetch-depth: 0 # Need tags

      - name: Download Plan
        uses: actions/download-artifact@v4
        with:
          name: release-plan
          path: artifacts/release-cut

      - name: Verify Plan
        run: |
          # Read plan and verify inputs match
          # This ensures we are executing exactly what was planned
          # Using grep on JSON file for simple verification without jq dependency (though jq is usually available)
          grep "\"sha\": \"${{ inputs.sha }}\"" artifacts/release-cut/plan.json || { echo "SHA mismatch"; exit 1; }
          grep "\"channel\": \"${{ inputs.channel }}\"" artifacts/release-cut/plan.json || { echo "Channel mismatch"; exit 1; }
          grep "\"eligible\": true" artifacts/release-cut/plan.json || { echo "Plan marked as ineligible"; exit 1; }

      - name: Re-run Eligibility Check (Guardrail)
        run: |
          echo "Re-running eligibility checks to ensure no new blocking conditions..."
          # Re-run the same check as plan phase
          if ! npx vitest run scripts/verify-evidence-bundle.test.ts --globals; then
            echo "Eligibility check failed during apply phase!"
            exit 1
          fi

      - name: Determine Tag
        run: |
          # Determine Tag
          VERSION=$(node -p "require('./package.json').version")
          if [ "${{ inputs.channel }}" == "rc" ]; then
             # For RC, we might append a timestamp or build number, but standard practice varies.
             # Assuming standard RC naming or just the version if the version itself is RC in package.json
             # If package.json version is 1.0.0, RC tag might be v1.0.0-rc or similar.
             # Let's assume the package.json version IS the target version.
             TAG="v$VERSION-rc"
             # Check if we should use existing prerelease conventions?
             # For safety, let's just tag v$VERSION if channel is GA, and v$VERSION-rc if channel is RC.
             # But if package.json already has -rc, we don't duplicate.
             if [[ "$VERSION" == *"-rc"* ]]; then
                TAG="v$VERSION"
             else
                TAG="v$VERSION-rc.$(date +%Y%m%d%H%M%S)"
             fi
          else
             TAG="ga/v$VERSION"
          fi

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists!"
            exit 1
          fi

          echo "TAG=$TAG" >> $GITHUB_ENV

      - name: Create Release Refs
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Creating tag $TAG for SHA ${{ inputs.sha }}"
          git tag -a $TAG -m "Release $TAG"
          git push origin $TAG

      - name: Audit Log
        run: |
          echo "# Release Audit Log" > artifacts/release-cut/result.md
          echo "" >> artifacts/release-cut/result.md
          echo "- **Actor**: ${{ github.actor }}" >> artifacts/release-cut/result.md
          echo "- **Timestamp**: $(date -u)" >> artifacts/release-cut/result.md
          echo "- **SHA**: ${{ inputs.sha }}" >> artifacts/release-cut/result.md
          echo "- **Ref Created**: $TAG" >> artifacts/release-cut/result.md
          echo "- **Channel**: ${{ inputs.channel }}" >> artifacts/release-cut/result.md

          cat artifacts/release-cut/result.md >> $GITHUB_STEP_SUMMARY

      - name: Upload Audit
        uses: actions/upload-artifact@v4
        with:
          name: release-audit
          path: artifacts/release-cut/result.md
