name: post-deploy-verification

on:
  workflow_run:
    workflows:
      - Deploy Dev (AWS)
      - Deploy to Staging
      - Deploy to Production
      - Manual Deploy
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  resolve-target:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    outputs:
      target: ${{ steps.target.outputs.target }}
      ui_url: ${{ steps.endpoints.outputs.ui_url }}
      api_url: ${{ steps.endpoints.outputs.api_url }}
      gql_url: ${{ steps.endpoints.outputs.gql_url }}
    env:
      PROD_UI_URL: ${{ secrets.PROD_UI_URL }}
      PROD_API_URL: ${{ secrets.PROD_API_URL }}
      STAGE_UI_URL: ${{ secrets.STAGE_UI_URL }}
      STAGE_API_URL: ${{ secrets.STAGE_API_URL }}
      DEV_UI_URL: ${{ secrets.DEV_UI_URL }}
      DEV_API_URL: ${{ secrets.DEV_API_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve deployment target
        id: target
        run: |
          workflow="${{ github.event.workflow_run.name }}"
          target="dev"
          if [ "$workflow" = "Deploy to Production" ]; then
            target="prod"
          elif [ "$workflow" = "Deploy to Staging" ]; then
            target="staging"
          elif [ "$workflow" = "Manual Deploy" ] && [ -n "${{ github.event.workflow_run.inputs.environment }}" ]; then
            target="${{ github.event.workflow_run.inputs.environment }}"
          fi
          echo "target=$target" >> $GITHUB_OUTPUT

      - name: Map endpoints
        id: endpoints
        run: |
          target="${{ steps.target.outputs.target }}"
          case "$target" in
            prod|production)
              ui="$PROD_UI_URL"; api="$PROD_API_URL";;
            staging)
              ui="$STAGE_UI_URL"; api="$STAGE_API_URL";;
            *)
              ui="${DEV_UI_URL:-$STAGE_UI_URL}"; api="${DEV_API_URL:-$STAGE_API_URL}";;
          esac
          if [ -z "$ui" ] || [ -z "$api" ]; then
            echo "Missing endpoint configuration for target $target" >&2
            exit 1
          fi
          echo "ui_url=$ui" >> $GITHUB_OUTPUT
          echo "api_url=$api" >> $GITHUB_OUTPUT
          echo "gql_url=${api%/}/graphql" >> $GITHUB_OUTPUT

  smoke-tests:
    needs: resolve-target
    uses: ./.github/workflows/k6.smoke.yml
    secrets: inherit
    with:
      ui_url: ${{ needs.resolve-target.outputs.ui_url }}
      api_url: ${{ needs.resolve-target.outputs.api_url }}
      artifact_name: post-deploy-k6-${{ needs.resolve-target.outputs.target }}-${{ github.run_id }}
      strict: false

  synthetic-journey:
    needs: resolve-target
    uses: ./.github/workflows/synthetic-journeys.yml
    secrets: inherit
    with:
      api_url: ${{ needs.resolve-target.outputs.api_url }}
      environment: ${{ needs.resolve-target.outputs.target }}
      artifact_name: synthetic-results-${{ needs.resolve-target.outputs.target }}-${{ github.run_id }}

  load-probe:
    needs: resolve-target
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      status: ${{ steps.load_outcome.outputs.status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup k6
        uses: grafana/setup-k6-action@v1

      - name: Run load probe
        id: load
        continue-on-error: true
        env:
          COS_GQL_URL: ${{ needs.resolve-target.outputs.gql_url }}
        run: k6 run tests/load/graphql_read_p95.js

      - name: Capture load outcome
        id: load_outcome
        run: echo "status=${{ steps.load.outcome }}" >> "$GITHUB_OUTPUT"

  report:
    needs: [resolve-target, smoke-tests, synthetic-journey, load-probe]
    if: always()
    runs-on: ubuntu-latest
    env:
      TARGET_ENV: ${{ needs.resolve-target.outputs.target }}
      UI_URL: ${{ needs.resolve-target.outputs.ui_url }}
      API_URL: ${{ needs.resolve-target.outputs.api_url }}
      GQL_URL: ${{ needs.resolve-target.outputs.gql_url }}
      SMOKE_OUTCOME: ${{ needs.smoke-tests.outputs.status || needs.smoke-tests.result }}
      LOAD_OUTCOME: ${{ needs.load-probe.outputs.status || needs.load-probe.result }}
      SYNTH_OUTCOME: ${{ needs.synthetic-journey.outputs.status || needs.synthetic-journey.result }}
      SMOKE_ARTIFACT: post-deploy-k6-${{ needs.resolve-target.outputs.target }}-${{ github.run_id }}
      SYNTH_ARTIFACT: synthetic-results-${{ needs.resolve-target.outputs.target }}-${{ github.run_id }}
      WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
      WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
      WORKFLOW_URL: ${{ github.event.workflow_run.html_url }}
      WORKFLOW_EVENT: ${{ github.event.workflow_run.event }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Download synthetic artifacts
        if: needs.synthetic-journey.outputs.artifact_name
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.synthetic-journey.outputs.artifact_name }}
          path: synthetic-artifacts

      - name: Summarize outcomes
        id: summary
        run: |
          smoke="${SMOKE_OUTCOME:-unknown}"
          load="${LOAD_OUTCOME:-unknown}"
          synthetic="${SYNTH_OUTCOME:-unknown}"
          status="success"
          if [ "$smoke" != "success" ] || [ "$load" != "success" ] || [ "$synthetic" != "success" ]; then
            status="failure"
          fi
          echo "smoke=$smoke" >> $GITHUB_OUTPUT
          echo "load=$load" >> $GITHUB_OUTPUT
          echo "synthetic=$synthetic" >> $GITHUB_OUTPUT
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Build deploy verification report
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const readJson = (filePath) => {
            try {
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (_) {
              return null;
            }
          };

          const syntheticResults = readJson(path.join('synthetic-artifacts', 'synthetic-results.json'));
          const syntheticLatency = readJson(path.join('synthetic-artifacts', 'synthetic-latency-histogram.json'));

          const report = {
            target: process.env.TARGET_ENV,
            endpoints: {
              ui: process.env.UI_URL,
              api: process.env.API_URL,
              graphql: process.env.GQL_URL,
            },
            outcomes: {
              smoke: process.env.SMOKE_OUTCOME,
              load: process.env.LOAD_OUTCOME,
              synthetic: process.env.SYNTH_OUTCOME,
            },
            synthetic: {
              results: syntheticResults,
              latency: syntheticLatency,
            },
            workflow_run: {
              id: process.env.WORKFLOW_RUN_ID,
              name: process.env.WORKFLOW_NAME,
              url: process.env.WORKFLOW_URL,
              event: process.env.WORKFLOW_EVENT,
            },
            generated_at: new Date().toISOString(),
          };

          fs.writeFileSync('deploy_verification.json', JSON.stringify(report, null, 2));
          NODE

      - name: Upload deploy verification artifact
        uses: actions/upload-artifact@v4
        with:
          name: deploy-verification-${{ needs.resolve-target.outputs.target }}-${{ github.run_id }}
          path: |
            deploy_verification.json
            synthetic-artifacts/synthetic-results.json
            synthetic-artifacts/synthetic-latency-histogram.json
          if-no-files-found: warn
          retention-days: 14

      - name: Locate release for deployment tag
        id: release_tag
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const headSha = '${{ github.event.workflow_run.head_sha }}';
            const { owner, repo } = context.repo;

            const tags = await github.paginate(github.rest.git.listMatchingRefs, {
              owner,
              repo,
              ref: 'tags/',
            });

            let match;
            for (const tag of tags) {
              if (tag.object?.type === 'commit' && tag.object.sha === headSha) {
                match = tag;
                break;
              }
              if (tag.object?.type === 'tag') {
                const annotated = await github.rest.git.getTag({ owner, repo, tag_sha: tag.object.sha });
                if (annotated.data.object?.sha === headSha) {
                  match = tag;
                  break;
                }
              }
            }

            if (!match) {
              core.info('No tag found for head SHA; skipping release attachment.');
              return;
            }

            const tagName = match.ref.replace('refs/tags/', '');
            let release;
            try {
              release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
            } catch (error) {
              core.info(`No release exists for tag ${tagName}; skipping attachment.`);
              return;
            }

            core.setOutput('tag', tagName);
            core.setOutput('upload_url', release.data.upload_url);

      - name: Attach verification to release
        if: steps.release_tag.outputs.upload_url
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.release_tag.outputs.upload_url }}
          asset_path: ./deploy_verification.json
          asset_name: deploy_verification.json
          asset_content_type: application/json

      - name: Comment results on PR
        if: github.event.workflow_run.event == 'pull_request' && github.event.workflow_run.pull_requests[0]
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.workflow_run.pull_requests[0];
            if (!pr) {
              core.info('No PR associated with deployment run.');
              return;
            }
            const smoke = '${{ steps.summary.outputs.smoke }}';
            const load = '${{ steps.summary.outputs.load }}';
            const synthetic = '${{ steps.summary.outputs.synthetic }}';
            const target = '${{ needs.resolve-target.outputs.target }}';
            const icon = (value) => (value === 'success' ? '✅' : '❌');
            const runUrl = context.payload.workflow_run.html_url;
            const body = [
              `Post-deploy verification for **${target}**`,
              `- Smoke: ${icon(smoke)} (${smoke})`,
              `- Load: ${icon(load)} (${load})`,
              `- Synthetic: ${icon(synthetic)} (${synthetic})`,
              `- Run: ${runUrl}`,
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body,
            });

      - name: Fail if checks failed
        if: steps.summary.outputs.status == 'failure'
        run: |
          echo "Post-deploy verification failed (smoke/load/synthetic)." >&2
          exit 1
