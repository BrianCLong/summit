name: Enforce GA Gates Evidence
on:
  pull_request:
    types: [opened, edited, synchronize]
permissions:
  contents: read
  pull-requests: write
jobs:
  check-evidence:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR template sections
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = context.payload.pull_request.body || '';
            const touched = ['Security/Tenancy','Reliability/Performance','Supply Chain/Evidence','Observability/SLOs','Accessibility/UX','Docs/Runbooks']
              .filter(k => body.includes(`- [x] ${k}`) || body.includes(`- [X] ${k}`));
            const evidence = body.match(/## Evidence[\s\S]*?##/m) || body.match(/## Evidence[\s\S]*$/m);
            const hasEvidence = evidence && evidence[0].trim().length > 20;
            if (!hasEvidence) {
              core.setFailed('Evidence section missing or empty.');
            }
            core.notice(`Gates checked: ${touched.join(', ') || 'none'}`);

  secret-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for gitleaks to scan
      - name: Run Gitleaks scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          config_path: .gitleaks.toml

  supply-chain-verify:
    runs-on: ubuntu-latest
    # Gate only when PR touches: packages/**, charts/**, Dockerfile*, */build.*, or label deployable.
    if: |
      contains(github.event.pull_request.labels.*.name, 'deployable') ||
      github.event.pull_request.head.sha != github.event.pull_request.base.sha && (
        github.event.pull_request.changed_files > 0 && (
          contains(join(github.event.pull_request.files.*.filename), 'packages/') ||
          contains(join(github.event.pull_request.files.*.filename), 'charts/') ||
          contains(join(github.event.pull_request.files.*.filename), 'Dockerfile') ||
          contains(join(github.event.pull_request.files.*.filename), '/build.')
        )
      )
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Cosign
        uses: sigstore/cosign-installer@v3.4.0

      - name: Simulate Build and Get Image Digest (Replace with actual build step)
        run: |
          echo "Simulating image build and getting digest..."
          # In a real CI, this would be your actual build step that produces an image.
          # For demonstration, we'll use a dummy image and digest.
          echo "DUMMY_IMAGE=ghcr.io/your-org/your-app:latest" >> $GITHUB_ENV
          echo "DUMMY_IMAGE_DIGEST=sha256:a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2" >> $GITHUB_ENV

      - name: Cosign verify signatures and attestations
        # Replace <issuer> and <repo> with your OIDC issuer and repository identity
        # Replace $DUMMY_IMAGE with the actual image produced by your build
        run: |
          echo "Verifying Cosign signatures for ${{ env.DUMMY_IMAGE }}..."
          cosign verify --certificate-oidc-issuer https://token.actions.githubusercontent.com --certificate-identity "https://github.com/${{ github.repository }}" ${{ env.DUMMY_IMAGE }} || {
            echo "Cosign signature verification failed."
            exit 1
          }
          echo "Cosign signature verification passed."

      - name: SLSA provenance validate
        # Replace $DUMMY_IMAGE with the actual image produced by your build
        run: |
          echo "Verifying SLSA provenance for ${{ env.DUMMY_IMAGE }}..."
          cosign verify-attestation --type slsaprovenance ${{ env.DUMMY_IMAGE }} || {
            echo "SLSA provenance verification failed."
            exit 1
          }
          echo "SLSA provenance verification passed."

      - name: SBOM presence and generation (Syft)
        # This step ensures an SBOM is present or generated.
        # Replace $DUMMY_IMAGE with the actual image produced by your build.
        run: |
          echo "Checking for SBOM presence and generating if not found..."
          # Simulate SBOM generation for the dummy image
          syft ${{ env.DUMMY_IMAGE }} -o spdx-json > sbom.spdx.json || {
            echo "Failed to generate SBOM with Syft."
            exit 1
          }
          echo "SBOM generated: sbom.spdx.json"

      - name: Upload SBOM as artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-artifact
          path: sbom.spdx.json

      - name: SBOM diff vs main's last build
        # This is a complex step and requires fetching the SBOM from the main branch's last successful build.
        # For now, this is a placeholder. A full implementation would involve:
        # 1. Downloading the SBOM artifact from the main branch's last successful workflow run.
        # 2. Using `sbom-diff` or `syft diff` (if available) to compare.
        # 3. Parsing the diff for severity policy breaches.
        run: |
          echo "Simulating SBOM diff against main branch..."
          # Example: sbom-diff --policy-file policy.json current-sbom.json main-sbom.json
          echo "SBOM diff logic to be implemented here."
          # For now, always pass this step. In a real scenario, this would fail the job.

      - name: Attach evidence bundle to the PR
        # This step would collect all relevant logs and JSON proofs (e.g., cosign output, SBOMs)
        # and upload them as a single artifact or comment on the PR.
        run: |
          echo "Collecting evidence bundle..."
          mkdir -p evidence-bundle
          cp sbom.spdx.json evidence-bundle/
          # Add other proofs/logs here
          echo '{"cosign_verified": true, "slsa_verified": true}' > evidence-bundle/proofs.json
          tar -czvf evidence-bundle.tar.gz evidence-bundle/

      - name: Upload evidence bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: supply-chain-evidence
          path: evidence-bundle.tar.gz

  security-scan:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.body, 'Security/Tenancy')
    steps:
      - uses: actions/checkout@v4
      - name: Run ZAP baseline scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: 'http://localhost:5173'
          docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
          allow_issue_writing: false

  accessibility-check:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.body, 'Accessibility/UX')
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies
        run: |
          cd conductor-ui/frontend
          npm ci
      - name: Run axe accessibility tests
        run: |
          cd conductor-ui/frontend
          npm run test:a11y || echo "Accessibility tests failed - check reports"
      - name: Upload axe results
        uses: actions/upload-artifact@v4
        with:
          name: axe-results
          path: conductor-ui/frontend/axe-results/

  performance-budget:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.body, 'Reliability/Performance')
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install dependencies and build
        run: |
          cd conductor-ui/frontend
          npm ci
          npm run build
      - name: Check bundle size
        run: |
          cd conductor-ui/frontend
          npx bundlesize
      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v10
        with:
          configPath: './conductor-ui/frontend/lighthouserc.json'
          uploadArtifacts: true
