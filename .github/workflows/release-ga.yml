name: GA Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      bypass_evidence:
        description: 'Bypass GO evidence check (Emergency only)'
        type: boolean
        required: false
        default: false
      bypass_reason:
        description: 'Reason for bypassing evidence'
        type: string
        required: false

permissions:
  contents: write
  packages: write
  id-token: write # For OIDC/Cosign if needed

jobs:
  test-and-verify:
    name: Verification Gates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check GO Evidence
        id: check-evidence
        uses: actions/github-script@v7
        env:
          TAG_REF: ${{ github.ref }}
          TAG_SHA: ${{ github.sha }}
          BYPASS: ${{ inputs.bypass_evidence }}
          BYPASS_REASON: ${{ inputs.bypass_reason }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const bypass = process.env.BYPASS === 'true';
            const bypassReason = process.env.BYPASS_REASON;

            if (bypass) {
              if (!bypassReason) {
                core.setFailed('Bypass requested but no reason provided.');
                return;
              }
              core.warning(`Evidence check BYPASSED. Reason: ${bypassReason}`);
              core.setOutput('bypassed', true);

              // Write dummy result for downstream
              const result = { ok: true, bypassed: true, reason: bypassReason, checkedAt: new Date().toISOString() };
              const distDir = path.join(process.cwd(), 'dist', 'release');
              fs.mkdirSync(distDir, { recursive: true });
              fs.writeFileSync(path.join(distDir, 'evidence-check.json'), JSON.stringify(result));

              await core.summary
                .addHeading('Release Evidence Check')
                .addRaw('⚠️ **BYPASSED**')
                .addTable([
                  ['Status', 'BYPASSED'],
                  ['Reason', bypassReason]
                ])
                .write();
              return;
            }

            // Extract tag name from ref (refs/tags/v1.2.3 -> v1.2.3)
            const ref = process.env.TAG_REF;
            if (!ref.startsWith('refs/tags/')) {
               core.setFailed('Workflow triggered without a tag, and bypass not set.');
               return;
            }
            const tag = ref.replace('refs/tags/', '');
            const evidencePath = `release-evidence/${tag}.json`;

            // We need to check if file exists on MAIN branch.
            // Since we checked out with fetch-depth 0, we can look at origin/main or just assume
            // we are looking for the file in the current workspace if the user committed it?
            // The runbook says: "Commit Evidence to main... Then Push Tag".
            // But checking out the TAG will result in a detached HEAD at the tag's commit.
            // The evidence file might be on 'main' but not yet merged into the release tag (if tag is on a release branch or older commit).
            // Actually, Option A says "file exists on main".
            // So we need to fetch main and look at the file there.

            try {
              // Fetch main branch to access the evidence file
              await exec.exec('git', ['fetch', 'origin', 'main']);

              // Read file from main branch
              let fileContent = '';
              const options = {};
              options.listeners = {
                stdout: (data) => {
                  fileContent += data.toString();
                }
              };
              try {
                await exec.exec('git', ['show', `origin/main:${evidencePath}`], options);
              } catch (e) {
                core.setFailed(`Evidence file not found on main at ${evidencePath}. Run Maestro pre-tag dry-run.`);
                return;
              }

              const evidence = JSON.parse(fileContent);
              const now = new Date();
              const generatedAt = new Date(evidence.generatedAt);
              const expiresAt = evidence.expiresAt ? new Date(evidence.expiresAt) : null;

              // Checks
              if (evidence.decision !== 'GO') throw new Error(`Decision is ${evidence.decision}, expected GO`);
              if (evidence.tag !== tag) throw new Error(`Tag mismatch: ${evidence.tag} vs ${tag}`);
              if (evidence.sha !== process.env.TAG_SHA) throw new Error(`SHA mismatch: ${evidence.sha} vs ${process.env.TAG_SHA}`);

              if (expiresAt && now > expiresAt) throw new Error(`Evidence expired at ${expiresAt}`);
              if (!expiresAt && (now - generatedAt) > 24 * 60 * 60 * 1000) throw new Error(`Evidence too old (generated ${generatedAt})`);

              console.log('Evidence check PASSED');

              const result = { ok: true, path: evidencePath, checkedAt: now.toISOString(), bypassed: false };
              const distDir = path.join(process.cwd(), 'dist', 'release');
              fs.mkdirSync(distDir, { recursive: true });
              fs.writeFileSync(path.join(distDir, 'evidence-check.json'), JSON.stringify(result));

               await core.summary
                .addHeading('Release Evidence Check')
                .addRaw('✅ **PASSED**')
                .addTable([
                  ['Status', 'GO'],
                  ['Tag', tag],
                  ['Generated', generatedAt.toISOString()]
                ])
                .write();

            } catch (error) {
              core.setFailed(`Evidence check failed: ${error.message}`);
              await core.summary
                .addHeading('Release Evidence Check')
                .addRaw('❌ **FAILED**')
                .addRaw(`Error: ${error.message}`)
                .write();
            }

      - uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Run Server Tests
        run: pnpm test:server
        continue-on-error: false

      - name: Run Policy Checks
        run: ./scripts/policy-test.sh
        continue-on-error: false

      - name: Verify Documentation Completeness
        run: ./scripts/check_traceability.cjs
        continue-on-error: false

  build-server:
    name: Build Server
    needs: test-and-verify
    uses: ./.github/workflows/_reusable-slsa-build.yml
    with:
      image_name: server
      dockerfile: server/Dockerfile
      context: .
      push: true
      sign: true
      sbom: true
      slsa_provenance: true
    secrets: inherit

  build-client:
    name: Build Client
    needs: test-and-verify
    uses: ./.github/workflows/_reusable-slsa-build.yml
    with:
      image_name: client
      dockerfile: client/Dockerfile
      context: .
      push: true
      sign: true
      sbom: true
      slsa_provenance: true
    secrets: inherit

  release:
    name: Create Release
    needs: [build-server, build-client]
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Server Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-server-${{ github.run_id }}
          path: evidence/server

      - name: Download Client Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-client-${{ github.run_id }}
          path: evidence/client

      - name: Create Evidence Bundle
        run: |
          mkdir -p release-assets
          tar -czf release-assets/evidence.tar.gz evidence/

      - name: Generate Release Notes
        id: notes
        run: |
          echo "notes=GA Release ${{ github.ref_name }} (SLSA L3 Compliant)" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: release-assets/evidence.tar.gz
          body: ${{ steps.notes.outputs.notes }}
          draft: false
          prerelease: false
          generate_release_notes: true
