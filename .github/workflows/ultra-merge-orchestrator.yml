name: üöÄ Ultra Merge Orchestrator

on:
  schedule:
    - cron: '*/30 * * * *'  # Run every 30 minutes
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      batch_size:
        description: 'Number of PRs to process'
        required: false
        default: '20'
      aggressive_mode:
        description: 'Enable aggressive merge mode'
        required: false
        default: 'true'

permissions:
  contents: write
  pull-requests: write
  checks: write
  statuses: write

jobs:
  orchestrate:
    name: Ultra Merge Orchestration
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "Ultra Merge Bot"
          git config user.email "merge-bot@summit.dev"

      - name: Analyze PR backlog
        id: analyze
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "=== PR BACKLOG ANALYSIS ==="

          # Get all open PRs with detailed status
          gh pr list --limit 200 --json number,title,headRefName,mergeable,statusCheckRollup \
            --jq '.[] | {number, title, branch: .headRefName, mergeable,
                         checks: (.statusCheckRollup | length),
                         passing: ([.statusCheckRollup[]? | select(.conclusion == "SUCCESS" or .conclusion == "SKIPPED")] | length),
                         failing: ([.statusCheckRollup[]? | select(.conclusion == "FAILURE")] | length)}' \
            > pr_analysis.json

          total=$(jq length pr_analysis.json)
          mergeable=$(jq '[.[] | select(.mergeable == "MERGEABLE")] | length' pr_analysis.json)
          ready=$(jq '[.[] | select(.mergeable == "MERGEABLE" and .failing == 0 and .checks > 0)] | length' pr_analysis.json)

          echo "total_prs=$total" >> $GITHUB_OUTPUT
          echo "mergeable_prs=$mergeable" >> $GITHUB_OUTPUT
          echo "ready_prs=$ready" >> $GITHUB_OUTPUT

          echo "Total PRs: $total"
          echo "Mergeable: $mergeable"
          echo "Ready to merge: $ready"

      - name: Smart PR update (workflow fixes)
        env:
          GH_TOKEN: ${{ github.token }}
          BATCH_SIZE: ${{ inputs.batch_size || '20' }}
        run: |
          echo "=== SMART PR UPDATE ==="

          # Get PRs that need workflow updates (prioritize by age)
          gh pr list --limit 200 --json number,headRefName,createdAt,mergeable \
            --jq '.[] | select(.mergeable == "MERGEABLE") | "\(.number):\(.headRefName):\(.createdAt)"' \
            | sort -t: -k3 | head -n "$BATCH_SIZE" > update_queue.txt

          WORKFLOW_CONTENT=$(base64 < .github/workflows/_reusable-ci-fast.yml)
          HUSKY_CONTENT=$(base64 < .husky/_/h)

          updated=0
          while IFS=: read -r pr_num branch_name created_at; do
            echo "Processing PR #$pr_num ($branch_name)..."

            # Update workflow file
            sha=$(gh api "repos/${{ github.repository }}/contents/.github/workflows/_reusable-ci-fast.yml?ref=$branch_name" \
              --jq '.sha' 2>/dev/null || echo "")

            if [ -n "$sha" ]; then
              if gh api -X PUT "repos/${{ github.repository }}/contents/.github/workflows/_reusable-ci-fast.yml" \
                -f message="chore(ci): ultra-merge auto-update [skip ci]" \
                -f content="$WORKFLOW_CONTENT" \
                -f sha="$sha" \
                -f branch="$branch_name" >/dev/null 2>&1; then

                echo "‚úÖ Updated PR #$pr_num"
                updated=$((updated + 1))
              fi
            fi

            sleep 1
          done < update_queue.txt

          echo "Updated $updated PRs this run"
          echo "updated_count=$updated" >> $GITHUB_OUTPUT

      - name: Intelligent merge execution
        env:
          GH_TOKEN: ${{ github.token }}
          AGGRESSIVE: ${{ inputs.aggressive_mode || 'true' }}
        run: |
          echo "=== INTELLIGENT MERGE EXECUTION ==="

          # Find PRs ready to merge (all checks passed)
          gh pr list --limit 200 --json number,title,mergeable,statusCheckRollup \
            --jq '.[] | select(.mergeable == "MERGEABLE") |
                  select(all(.statusCheckRollup[]?; .conclusion == "SUCCESS" or .conclusion == "SKIPPED" or .conclusion == "NEUTRAL")) |
                  .number' > ready_to_merge.txt

          if [ ! -s ready_to_merge.txt ]; then
            echo "No PRs ready to merge yet"
            exit 0
          fi

          ready_count=$(wc -l < ready_to_merge.txt)
          echo "Found $ready_count PRs ready to merge"

          merged=0
          failed=0

          while read -r pr_num; do
            echo "Merging PR #$pr_num..."

            if gh pr merge "$pr_num" --squash --auto --delete-branch 2>&1; then
              echo "‚úÖ Merged PR #$pr_num"
              merged=$((merged + 1))
              sleep 5  # Rate limit protection
            else
              echo "‚ùå Failed to merge PR #$pr_num"
              failed=$((failed + 1))
            fi

            # Stop if too many failures
            if [ $failed -ge 3 ]; then
              echo "Too many failures, stopping merge process"
              break
            fi

          done < ready_to_merge.txt

          echo "Merged: $merged PRs"
          echo "Failed: $failed PRs"
          echo "merged_count=$merged" >> $GITHUB_OUTPUT

      - name: Health check and metrics
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "=== MERGE TRAIN HEALTH CHECK ==="

          # Current state
          open_prs=$(gh pr list --limit 500 | wc -l)

          echo "üìä Current Metrics:"
          echo "- Open PRs: $open_prs"
          echo "- PRs analyzed: ${{ steps.analyze.outputs.total_prs }}"
          echo "- Ready to merge: ${{ steps.analyze.outputs.ready_prs }}"
          echo "- Merged this run: ${{ steps.merge.outputs.merged_count || 0 }}"

          # Calculate velocity
          echo "üöÄ Merge Train Velocity:"
          merged_today=$(gh pr list --state merged --search "merged:>=$(date -u +%Y-%m-%d)" --limit 500 | wc -l || echo 0)
          echo "- Merged today: $merged_today"

          # Estimate completion
          if [ $open_prs -gt 0 ] && [ ${merged_today:-0} -gt 0 ]; then
            days_to_complete=$(echo "scale=1; $open_prs / $merged_today" | bc)
            echo "- Est. days to clear backlog: $days_to_complete"
          fi

      - name: Self-healing checks
        if: always()
        run: |
          echo "=== SELF-HEALING CHECKS ==="

          # Check for common issues and auto-fix
          echo "Checking for stuck PRs..."

          # PRs with failing checks for >24 hours get auto-updated
          gh pr list --limit 50 --json number,headRefName,updatedAt,statusCheckRollup \
            --jq '.[] | select((.statusCheckRollup | length) > 0) |
                  select(any(.statusCheckRollup[]?; .conclusion == "FAILURE")) |
                  select(.updatedAt < (now - 86400 | todate)) |
                  .number' > stuck_prs.txt || true

          if [ -s stuck_prs.txt ]; then
            stuck_count=$(wc -l < stuck_prs.txt)
            echo "Found $stuck_count stuck PRs (will retry in next run)"
          else
            echo "No stuck PRs detected"
          fi

      - name: Generate status report
        if: always()
        run: |
          cat > /tmp/merge_train_run.md << EOF
          # Merge Train Run Report

          **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Run ID:** ${{ github.run_id }}

          ## Metrics
          - Total Open PRs: ${{ steps.analyze.outputs.total_prs }}
          - Mergeable PRs: ${{ steps.analyze.outputs.mergeable_prs }}
          - Ready to Merge: ${{ steps.analyze.outputs.ready_prs }}
          - PRs Merged: ${{ steps.merge.outputs.merged_count || 0 }}
          - PRs Updated: ${{ steps.update.outputs.updated_count || 0 }}

          ## Status
          ‚úÖ Orchestrator ran successfully
          üîÑ Next run in 30 minutes

          EOF

          cat /tmp/merge_train_run.md
