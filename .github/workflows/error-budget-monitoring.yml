name: Error Budget Monitoring

on:
  # Disabled scheduled trigger until production environment is configured
  # schedule:
  #   # Every 15 minutes during business hours
  #   - cron: '*/15 8-18 * * 1-5'
  workflow_dispatch:
  workflow_call:
    outputs:
      slo_breached:
        description: Whether any monitored SLOs were violated
        value: ${{ jobs.error-budget-check.outputs.slo_breached }}
      breach_summary:
        description: Short summary describing which objectives failed
        value: ${{ jobs.error-budget-check.outputs.breach_summary }}

permissions:
  contents: read
  actions: read
  deployments: write
  issues: write

env:
  ENABLE_SLO_AUTOMATION: ${{ secrets.SLO_AUTOMATION_ENABLED || 'false' }}
  GRAFANA_URL: ${{ secrets.GRAFANA_URL }}
  GRAFANA_API_TOKEN: ${{ secrets.GRAFANA_API_TOKEN || '' }}
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}

concurrency:
  group: error-budget-monitoring-${{ github.ref }}
  cancel-in-progress: false

jobs:
  error-budget-check:
    runs-on: ubuntu-latest
    outputs:
      slo_breached: ${{ steps.outputs.outputs.slo_breached }}
      breach_summary: ${{ steps.outputs.outputs.breach_summary }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine if SLO evaluation should run
        id: guard
        run: |
          set -euo pipefail

          if [ "$ENABLE_SLO_AUTOMATION" != "true" ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "reason=Automation disabled for this ref" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "$GRAFANA_URL" ] || [ -z "$GRAFANA_API_TOKEN" ]; then
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "reason=Grafana credentials missing" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "enabled=true" >> "$GITHUB_OUTPUT"
          echo "reason=" >> "$GITHUB_OUTPUT"

      - name: Evaluate SLO health
        id: evaluate
        if: steps.guard.outputs.enabled == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          python <<'PY'
import json
import os
import sys
import urllib.parse
import urllib.request
import time

grafana_url = os.environ["GRAFANA_URL"].rstrip("/")
grafana_token = os.environ["GRAFANA_API_TOKEN"].strip()
github_token = os.environ.get("GITHUB_TOKEN", "")
repo = os.environ.get("GITHUB_REPOSITORY", "")

checks = [
    {
        "id": "graphql-p95",
        "name": "GraphQL p95 latency",
        "units": "s",
        "threshold": 1.5,
        "comparison": "lt",
        "source": "prometheus",
        "query": "histogram_quantile(0.95, sum(rate(graphql_request_duration_seconds_bucket[5m])) by (le))",
        "description": "95th percentile GraphQL latency should stay under 1.5s",
    },
    {
        "id": "graphql-error-rate",
        "name": "GraphQL error rate",
        "units": "%",
        "threshold": 0.5,
        "comparison": "lt",
        "source": "prometheus",
        "query": "sum(rate(graphql_requests_total{status=~\"5..\"}[5m])) / sum(rate(graphql_requests_total[5m])) * 100",
        "description": "5xx responses should remain below 0.5%",
    },
    {
        "id": "ingest-e2e",
        "name": "Ingest E2E (10k docs)",
        "units": "s",
        "threshold": 300,
        "comparison": "lt",
        "source": "prometheus",
        "query": "histogram_quantile(0.95, sum(rate(ingest_batch_duration_seconds_bucket{batch=\"10k\"}[5m])) by (le))",
        "description": "Ingest pipeline should complete 10k docs within 5 minutes",
    },
    {
        "id": "dlq-rate",
        "name": "DLQ rate",
        "units": "%",
        "threshold": 0.1,
        "comparison": "lt",
        "source": "prometheus",
        "query": "sum(rate(ingest_dlq_events_total[5m])) / sum(rate(ingest_events_total[5m])) * 100",
        "description": "Dead letter queue events should remain below 0.1%",
    },
    {
        "id": "worker-failure-rate",
        "name": "Worker failure rate",
        "units": "%",
        "threshold": 1.0,
        "comparison": "lt",
        "source": "prometheus",
        "query": "sum(rate(worker_task_failures_total[5m])) / sum(rate(worker_tasks_total[5m])) * 100",
        "description": "Worker task failures should remain below 1%",
    },
    {
        "id": "ci-pass-rate",
        "name": "CI pass rate (last 20 runs)",
        "units": "%",
        "threshold": 95,
        "comparison": "gt",
        "source": "github",
        "description": "CI success rate across the last 20 runs should be above 95%",
    },
]


def prom_query(query: str) -> float:
    payload = urllib.parse.urlencode({"query": query}).encode()
    request = urllib.request.Request(
        f"{grafana_url}/api/prom/api/v1/query",
        data=payload,
        method="POST",
        headers={
            "Authorization": f"Bearer {grafana_token}",
            "Content-Type": "application/x-www-form-urlencoded",
            "Accept": "application/json",
        },
    )

    last_error: Exception | None = None
    for attempt in range(3):
        try:
            with urllib.request.urlopen(request, timeout=30) as response:
                body = json.load(response)
            if body.get("status") != "success":
                raise RuntimeError(f"Prometheus query failed: {body}")
            result = body.get("data", {}).get("result")
            if not result:
                raise RuntimeError("Prometheus query returned no data for SLO check")
            return float(result[0]["value"][1])
        except Exception as exc:  # noqa: BLE001
            last_error = exc
            time.sleep(2 ** attempt)

    raise RuntimeError(f"Prometheus query failed after retries: {last_error}")


def github_ci_pass_rate() -> float:
    if not github_token or not repo:
        raise RuntimeError("GITHUB_TOKEN or repository context missing for CI SLO")
    url = f"https://api.github.com/repos/{repo}/actions/runs?per_page=20&status=completed"
    request = urllib.request.Request(
        url,
        headers={
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github+json",
        },
    )
    last_error: Exception | None = None
    for attempt in range(3):
        try:
            with urllib.request.urlopen(request, timeout=30) as response:
                body = json.load(response)
            runs = body.get("workflow_runs", [])
            if not runs:
                raise RuntimeError("No workflow runs available to calculate CI pass rate")
            successes = sum(1 for run in runs if run.get("conclusion") == "success")
            return round(successes / len(runs) * 100, 2)
        except Exception as exc:  # noqa: BLE001
            last_error = exc
            time.sleep(2 ** attempt)

    raise RuntimeError(f"CI pass rate query failed after retries: {last_error}")


def breached(value: float, threshold: float, comparison: str) -> bool:
    if comparison == "lt":
        return value > threshold
    if comparison == "gt":
        return value < threshold
    raise ValueError(f"Unsupported comparison operator: {comparison}")


results = []

for check in checks:
    if check["source"] == "prometheus":
        value = prom_query(check["query"])
    elif check["source"] == "github":
        value = github_ci_pass_rate()
    else:
        raise ValueError(f"Unsupported SLO source: {check['source']}")

    is_breach = breached(value, check["threshold"], check["comparison"])
    status = "âŒ BREACHED" if is_breach else "âœ… OK"
    comparator = "<" if check["comparison"] == "lt" else ">"
    reason = f"Target {comparator}= {check['threshold']}{check['units']}"

    results.append(
        {
            "id": check["id"],
            "name": check["name"],
            "value": value,
            "units": check["units"],
            "threshold": check["threshold"],
            "comparison": check["comparison"],
            "breached": is_breach,
            "status": status,
            "reason": reason,
            "description": check["description"],
        }
    )

with open("slo-results.json", "w", encoding="utf-8") as f:
    json.dump(results, f, indent=2)

breaches = [r for r in results if r["breached"]]
summary = " | ".join(
    f"{b['name']}: {b['value']}{b['units']} ({b['reason']})" for b in breaches
) or "none"

with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
    fh.write(f"slo_breached={'true' if breaches else 'false'}\n")
    fh.write(f"breach_summary={summary}\n")

with open(os.environ.get("GITHUB_STEP_SUMMARY", "/dev/null"), "a", encoding="utf-8") as summary_file:
    summary_file.write("| Objective | Value | Threshold | Status |\n")
    summary_file.write("|-----------|-------|-----------|--------|\n")
    for result in results:
        threshold = f"{result['comparison']} {result['threshold']}{result['units']}"
        summary_file.write(
            f"| {result['name']} | {result['value']}{result['units']} | {threshold} | {result['status']} |\n"
        )

if breaches:
    breach_list = "\n".join(f"- {b['name']}: {b['value']}{b['units']}" for b in breaches)
    with open(os.environ.get("GITHUB_STEP_SUMMARY", "/dev/null"), "a", encoding="utf-8") as summary_file:
        summary_file.write("\nðŸš¨ SLO Breaches Detected\n")
        summary_file.write(f"{breach_list}\n")
else:
    with open(os.environ.get("GITHUB_STEP_SUMMARY", "/dev/null"), "a", encoding="utf-8") as summary_file:
        summary_file.write("\nâœ… All monitored SLOs are within budget\n")
PY

      - name: Emit outputs when evaluation is skipped
        if: steps.guard.outputs.enabled != 'true'
        id: skipped
        run: |
          echo "[]" > slo-results.json
          echo "slo_breached=false" >> "$GITHUB_OUTPUT"
          echo "breach_summary=${{ steps.guard.outputs.reason }}" >> "$GITHUB_OUTPUT"
          printf "\nSLO evaluation skipped: %s\n" "${{ steps.guard.outputs.reason }}" >> "$GITHUB_STEP_SUMMARY"

      - name: Generate Error Budget Report
        id: report
        if: steps.guard.outputs.enabled == 'true'
        run: |
          python <<'PY'
import json
import os
from datetime import datetime, timezone

with open("slo-results.json", "r", encoding="utf-8") as f:
    results = json.load(f)

timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

lines = [
    "# ðŸ“Š Error Budget Status Report",
    "",
    f"**Timestamp:** {timestamp}",
    "",
    "## Service Level Objectives (SLOs)",
    "",
    "| Metric | Current | Budget | Status |",
    "|--------|---------|---------|--------|",
]

for result in results:
    comparator = "<=" if result["comparison"] == "lt" else ">="
    budget = f"{comparator} {result['threshold']}{result['units']}"
    lines.append(
        f"| {result['name']} | {result['value']}{result['units']} | {budget} | {result['status']} |"
    )

lines.extend([
    "",
    "## Actions Required",
])

breaches = [r for r in results if r["breached"]]
if breaches:
    for breach in breaches:
        lines.append(f"- ðŸš¨ {breach['name']}: {breach['description']} ({breach['reason']})")
else:
    lines.append("- âœ… No action required; all SLOs are healthy.")

report = "\n".join(lines)
with open("error-budget-report.md", "w", encoding="utf-8") as f:
    f.write(report)

alert_needed = "true" if breaches else "false"
with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
    fh.write(f"alert-needed={alert_needed}\n")
PY

      - name: Create or Update Issue
        if: steps.guard.outputs.enabled == 'true' && steps.report.outputs.alert-needed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('error-budget-report.md', 'utf8');

            // Look for existing error budget issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['error-budget', 'slo-violation'],
              state: 'open'
            });

            if (issues.data.length > 0) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `## Updated Error Budget Report\n\n${report}`
              });
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'ðŸš¨ Error Budget Violation Detected',
                body: report,
                labels: ['error-budget', 'slo-violation', 'P0']
              });
            }

      - name: Notify Slack
        if: steps.guard.outputs.enabled == 'true' && steps.report.outputs.alert-needed == 'true' && env.SLACK_WEBHOOK != ''
        run: |
          set -euo pipefail

          FIELDS=$(jq -c '[.[] | select(.breached) | {title: .name, value: (.value|tostring + .units + " (" + .reason + ")"), short: true}]' slo-results.json)

          curl -X POST "${{ env.SLACK_WEBHOOK }}" \
            -H 'Content-type: application/json' \
            --data "{\n              \"text\": \"ðŸš¨ Error budget violation detected\",\n              \"attachments\": [\n                {\n                  \"color\": \"danger\",\n                  \"title\": \"SLO breach triggered rollback\",\n                  \"text\": \"See incident issue for details.\",\n                  \"fields\": ${FIELDS}\n                }\n              ]\n            }"

      - name: Upload Report Artifact
        if: steps.guard.outputs.enabled == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: error-budget-report-${{ github.run_number }}
          path: error-budget-report.md
          retention-days: 30

      - name: Expose workflow outputs
        id: outputs
        if: always()
        run: |
          set -euo pipefail

          if [ -f slo-results.json ] && [ "${{ steps.guard.outputs.enabled }}" == "true" ]; then
            BREACH_COUNT=$(jq '[.[] | select(.breached)] | length' slo-results.json)
            SUMMARY="$(jq -r '[.[] | select(.breached) | "\(.name): \(.value)\(.units) (Target \(.comparison)= \(.threshold)\(.units))"] | join(" | ")' slo-results.json)"
            if [ "$BREACH_COUNT" -gt 0 ]; then
              SLO_BREACHED=true
              BREACH_SUMMARY=${SUMMARY:-"See report for details"}
            else
              SLO_BREACHED=false
              BREACH_SUMMARY="none"
            fi
          else
            SLO_BREACHED=false
            BREACH_SUMMARY="${{ steps.guard.outputs.reason || 'Evaluation skipped' }}"
          fi

          echo "slo_breached=${SLO_BREACHED}" >> "$GITHUB_OUTPUT"
          echo "breach_summary=${BREACH_SUMMARY}" >> "$GITHUB_OUTPUT"

  trigger-rollback:
    name: Trigger Auto-Rollback on Breach
    needs: [error-budget-check]
    runs-on: ubuntu-latest
    if: needs.error-budget-check.outputs.slo_breached == 'true'
    outputs:
      deployment_id: ${{ steps.latest.outputs.deployment_id }}
      deployment_sha: ${{ steps.latest.outputs.deployment_sha }}
      deployer: ${{ steps.latest.outputs.deployer }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Identify latest production deployment
        id: latest
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LATEST_DEPLOYMENT=$(gh api \
            --method GET \
            --paginate \
            "/repos/$GITHUB_REPOSITORY/deployments" \
            --jq '[.[] | select(.environment=="production")] | sort_by(.created_at) | reverse | .[0]')

          if [ -z "$LATEST_DEPLOYMENT" ] || [ "$LATEST_DEPLOYMENT" = "null" ]; then
            echo "No production deployments found to roll back" >&2
            exit 1
          fi

          DEPLOYMENT_ID=$(echo "$LATEST_DEPLOYMENT" | jq -r '.id')
          DEPLOYMENT_SHA=$(echo "$LATEST_DEPLOYMENT" | jq -r '.sha')
          DEPLOYER=$(echo "$LATEST_DEPLOYMENT" | jq -r '.creator.login')

          echo "deployment_id=$DEPLOYMENT_ID" >> "$GITHUB_OUTPUT"
          echo "deployment_sha=$DEPLOYMENT_SHA" >> "$GITHUB_OUTPUT"
          echo "deployer=$DEPLOYER" >> "$GITHUB_OUTPUT"

          echo "ðŸ“¦ Latest production deployment: $DEPLOYMENT_ID ($DEPLOYMENT_SHA) by @$DEPLOYER" >> "$GITHUB_STEP_SUMMARY"

      - name: Flag deployment as failed to trigger rollback
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api \
            "/repos/$GITHUB_REPOSITORY/deployments/${{ steps.latest.outputs.deployment_id }}/statuses" \
            --method POST \
            --field state="failure" \
            --field environment="production" \
            --field description="SLO breach detected: ${{ needs.error-budget-check.outputs.breach_summary }}"

          echo "ðŸš¨ Marked deployment ${{ steps.latest.outputs.deployment_id }} as failed to activate auto-rollback" >> "$GITHUB_STEP_SUMMARY"

  alert-owner:
    name: Alert Responsible Engineer
    needs: [error-budget-check, trigger-rollback]
    runs-on: ubuntu-latest
    if: needs.error-budget-check.outputs.slo_breached == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create incident issue and assign
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `${{ toJSON(needs.error-budget-check.outputs.breach_summary) }}`;
            const deploymentId = `${{ needs.trigger-rollback.outputs.deployment_id }}`;
            const deploymentSha = `${{ needs.trigger-rollback.outputs.deployment_sha }}`;
            const deployer = `${{ needs.trigger-rollback.outputs.deployer }}`;

            const title = `ðŸš¨ SLO breach triggered rollback (deploy ${deploymentId})`;
            const body = [
              `SLO breach detected: ${summary}`,
              '',
              `Rollback initiated for deployment **${deploymentId}** (sha: ${deploymentSha}).`,
              `Last deployer: @${deployer}.`,
              '',
              'Follow-up actions:',
              '- [ ] Review rollback workflow logs',
              '- [ ] Identify root cause and prepare fix',
              '- [ ] Schedule forward deployment once stable'
            ].join('\n');

            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ['slo-violation', 'rollback', 'priority:high'],
              assignees: [deployer]
            });

            core.info(`Created incident issue #${issue.data.number} assigned to @${deployer}`);

      - name: Notify Slack
        if: env.SLACK_WEBHOOK != ''
        env:
          DEPLOYER: ${{ needs.trigger-rollback.outputs.deployer }}
        run: |
          curl -X POST "$SLACK_WEBHOOK" \
            -H 'Content-type: application/json' \
            --data "{\n  \"text\": \"ðŸš¨ SLO breach triggered rollback for production\",\n  \"attachments\": [\n    {\n      \"color\": \"danger\",\n      \"title\": \"Rollback initiated\",\n      \"text\": \"Deployment ${{ needs.trigger-rollback.outputs.deployment_id }} marked failed due to SLO breach.\",\n      \"fields\": [\n        {\n          \"title\": \"Deployment SHA\",\n          \"value\": \"${{ needs.trigger-rollback.outputs.deployment_sha }}\",\n          \"short\": true\n        },\n        {\n          \"title\": \"Responsible engineer\",\n          \"value\": \"@$DEPLOYER\",\n          \"short\": true\n        },\n        {\n          \"title\": \"SLO details\",\n          \"value\": \"${{ needs.error-budget-check.outputs.breach_summary }}\",\n          \"short\": false\n        }\n      ]\n    }\n  ]\n}"
