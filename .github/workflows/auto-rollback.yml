name: ðŸ”„ Auto-Rollback Safety Net

on:
  deployment_status:
  workflow_run:
    workflows: ['ðŸš¢ Release Captain']
    types: [completed]
  repository_dispatch:
    types: [slo-breach]
  workflow_dispatch: # Allow manual runs during stabilization
  # Disabled scheduled trigger until production environment is configured
  # schedule:
  #   # Monitor health every 5 minutes after deployments
  #   - cron: '*/5 * * * *'

# Prevent concurrent rollback operations
concurrency:
  group: auto-rollback-${{ github.ref }}
  cancel-in-progress: false

env:
  NODE_VERSION: '20.11.1'
  PNPM_VERSION: '9.6.0'
  HEALTH_CHECK_TIMEOUT: 300
  MAX_ROLLBACK_ATTEMPTS: 3

permissions:
  contents: read
  deployments: write
  pull-requests: write
  actions: write
  checks: write

jobs:
  detect-deployment-failure:
    name: ðŸ” Detect Deployment Issues
    if: |
      (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'failure') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'failure') ||
      (github.event_name == 'repository_dispatch' && github.event.action == 'slo-breach')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_rollback: ${{ steps.analyze.outputs.should_rollback }}
      rollback_target: ${{ steps.analyze.outputs.rollback_target }}
      failure_type: ${{ steps.analyze.outputs.failure_type }}
      slo_context: ${{ steps.analyze.outputs.slo_context }}
      environment: ${{ steps.analyze.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze deployment failure
        id: analyze
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ” Analyzing deployment failure..."

          DEPLOYMENT_SHA=""
          ENVIRONMENT="production"
          PREFERRED_ROLLBACK=""
          FAILURE_TYPE="unknown"
          SLO_CONTEXT=""

          # Get current deployment info
          if [[ "${{ github.event_name }}" == "deployment_status" ]]; then
            DEPLOYMENT_ID="${{ github.event.deployment.id }}"
            DEPLOYMENT_SHA="${{ github.event.deployment.sha }}"
            ENVIRONMENT="${{ github.event.deployment.environment }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            DEPLOYMENT_SHA="${{ github.event.workflow_run.head_sha }}"
            ENVIRONMENT="production"
            FAILURE_TYPE="pipeline"
          elif [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            DEPLOYMENT_SHA="${{ github.event.client_payload.deployment_sha }}"
            PREFERRED_ROLLBACK="${{ github.event.client_payload.rollback_target }}"
            ENVIRONMENT="${{ github.event.client_payload.environment }}"
            FAILURE_TYPE="slo_breach"
            SLO_CONTEXT="${{ github.event.client_payload.failing_slos }}"
          fi

          if [[ -z "$ENVIRONMENT" ]]; then
            ENVIRONMENT="production"
          fi

          echo "Deployment SHA: ${DEPLOYMENT_SHA:-unknown}"
          echo "Environment: $ENVIRONMENT"
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

          # Check if this is a production environment
          if [[ "$ENVIRONMENT" != "production" && "$ENVIRONMENT" != "staging" ]]; then
            echo "Non-critical environment, skipping rollback"
            echo "should_rollback=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Find last successful deployment
          LAST_SUCCESS="$PREFERRED_ROLLBACK"
          if [[ -z "$LAST_SUCCESS" ]]; then
            DEPLOYMENTS=$(gh api "/repos/$GITHUB_REPOSITORY/deployments?environment=$ENVIRONMENT&per_page=10" 2>/dev/null || true)
            if [[ -n "$DEPLOYMENTS" && "$DEPLOYMENTS" != "[]" ]]; then
              while read -r sha id; do
                STATUS=$(gh api "/repos/$GITHUB_REPOSITORY/deployments/$id/statuses?per_page=1" --jq '.[0].state' 2>/dev/null || echo "unknown")

                if [[ "$STATUS" == "success" ]]; then
                  if [[ -z "$DEPLOYMENT_SHA" ]]; then
                    DEPLOYMENT_SHA="$sha"
                    continue
                  fi

                  if [[ "$sha" == "$DEPLOYMENT_SHA" ]]; then
                    continue
                  fi

                  LAST_SUCCESS="$sha"
                  break
                fi
              done < <(echo "$DEPLOYMENTS" | jq -r '.[] | "\(.sha) \(.id)"')
            fi
          fi

          if [[ -z "$LAST_SUCCESS" ]]; then
            echo "No previous successful deployment found"
            echo "should_rollback=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Analyze failure type
          if [[ "${{ github.event.deployment_status.description }}" == *"health check"* ]]; then
            FAILURE_TYPE="health_check"
          elif [[ "${{ github.event.deployment_status.description }}" == *"smoke test"* ]]; then
            FAILURE_TYPE="smoke_test"
          elif [[ "${{ github.event.workflow_run.conclusion }}" == "failure" ]]; then
            FAILURE_TYPE="pipeline"
          fi

          echo "should_rollback=true" >> $GITHUB_OUTPUT
          echo "rollback_target=$LAST_SUCCESS" >> $GITHUB_OUTPUT
          echo "failure_type=$FAILURE_TYPE" >> $GITHUB_OUTPUT
          echo "slo_context=$SLO_CONTEXT" >> $GITHUB_OUTPUT

          echo "ðŸŽ¯ Rollback target: $LAST_SUCCESS"
          echo "ðŸ’¥ Failure type: $FAILURE_TYPE"

  health-monitor:
    name: ðŸ¥ Health Monitor
    if: false # Belt-and-suspenders guard during stabilization
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      health_status: ${{ steps.check.outputs.health_status }}
      critical_failure: ${{ steps.check.outputs.critical_failure }}
    steps:
      - uses: actions/checkout@v4

      - name: Check system health
        id: check
        run: |
          echo "ðŸ¥ Performing system health checks..."

          HEALTH_ENDPOINTS=(
            "https://api.summit.dev/health"
            "https://graph.summit.dev/health"
            "https://auth.summit.dev/health"
          )

          FAILED_ENDPOINTS=()
          TOTAL_CHECKS=0
          PASSED_CHECKS=0

          for endpoint in "${HEALTH_ENDPOINTS[@]}"; do
            TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
            echo "Checking: $endpoint"

            if curl -f -s --max-time 30 "$endpoint" > /dev/null; then
              echo "âœ… $endpoint - OK"
              PASSED_CHECKS=$((PASSED_CHECKS + 1))
            else
              echo "âŒ $endpoint - FAILED"
              FAILED_ENDPOINTS+=("$endpoint")
            fi
          done

          # Calculate health percentage
          HEALTH_PERCENTAGE=$((PASSED_CHECKS * 100 / TOTAL_CHECKS))
          echo "Health percentage: $HEALTH_PERCENTAGE%"

          # Determine if this is a critical failure
          CRITICAL_FAILURE="false"
          if [[ $HEALTH_PERCENTAGE -lt 67 ]]; then
            echo "ðŸš¨ Critical health failure detected"
            CRITICAL_FAILURE="true"
          fi

          echo "health_status=$HEALTH_PERCENTAGE" >> $GITHUB_OUTPUT
          echo "critical_failure=$CRITICAL_FAILURE" >> $GITHUB_OUTPUT

          # Save failure details
          if [[ ${#FAILED_ENDPOINTS[@]} -gt 0 ]]; then
            echo "Failed endpoints:" > /tmp/health-failures.txt
            printf '%s\n' "${FAILED_ENDPOINTS[@]}" >> /tmp/health-failures.txt
          fi

      - name: Check deployment metrics
        if: steps.check.outputs.critical_failure == 'true'
        run: |
          echo "ðŸ“Š Checking deployment metrics for anomalies..."

          # This would integrate with your observability stack
          # For now, we'll check basic metrics

          # Check error rates (would typically query Prometheus/Grafana)
          echo "Checking error rate spikes..."

          # Check latency (would typically query your APM)
          echo "Checking latency increases..."

          # Check traffic drops (would typically query load balancer metrics)
          echo "Checking traffic anomalies..."

          echo "ðŸ“ˆ Metrics check completed"

  execute-rollback:
    name: â†©ï¸ Execute Rollback
    needs: [detect-deployment-failure, health-monitor]
    if: |
      always() && (
        (needs.detect-deployment-failure.outputs.should_rollback == 'true') ||
        (needs.health-monitor.outputs.critical_failure == 'true')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: production-rollback
      url: https://summit.dev
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Prepare rollback
        id: prepare
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "â†©ï¸ Preparing rollback operation..."

          ROLLBACK_ENV="${{ needs.detect-deployment-failure.outputs.environment || 'production' }}"
          if [[ -z "$ROLLBACK_ENV" ]]; then
            ROLLBACK_ENV="production"
          fi

          # Determine rollback target
          if [[ "${{ needs.detect-deployment-failure.outputs.rollback_target }}" != "" ]]; then
            ROLLBACK_TARGET="${{ needs.detect-deployment-failure.outputs.rollback_target }}"
            FAILURE_KIND="${{ needs.detect-deployment-failure.outputs.failure_type }}"
            SLO_CONTEXT="${{ needs.detect-deployment-failure.outputs.slo_context }}"

            if [[ "$FAILURE_KIND" == "slo_breach" ]]; then
              if [[ -n "$SLO_CONTEXT" ]]; then
                ROLLBACK_REASON="SLO breach detected: $SLO_CONTEXT"
              else
                ROLLBACK_REASON="SLO breach detected by automated guardrail"
              fi
            else
              ROLLBACK_REASON="Deployment failure: $FAILURE_KIND"
            fi
          else
            # Health monitor triggered rollback - find last known good deployment
            ROLLBACK_TARGET=$(gh api "/repos/$GITHUB_REPOSITORY/deployments" \
              --jq '.[] | select(.environment == "production") | .sha' \
              | head -1)
            ROLLBACK_REASON="Critical health failure detected ({{ needs.health-monitor.outputs.health_status }}% health)"
          fi

          if [[ -z "$ROLLBACK_TARGET" ]]; then
            echo "âŒ No rollback target found"
            exit 1
          fi

          echo "ðŸŽ¯ Rolling back to: $ROLLBACK_TARGET"
          echo "ðŸ“ Reason: $ROLLBACK_REASON"
          echo "ðŸŒŽ Environment: $ROLLBACK_ENV"

          echo "rollback_target=$ROLLBACK_TARGET" >> $GITHUB_OUTPUT
          echo "rollback_reason=$ROLLBACK_REASON" >> $GITHUB_OUTPUT

      - name: Create rollback deployment
        id: deploy
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ Executing rollback deployment..."

          ROLLBACK_TARGET="${{ steps.prepare.outputs.rollback_target }}"
          ROLLBACK_REASON="${{ steps.prepare.outputs.rollback_reason }}"
          ROLLBACK_ENV="${{ needs.detect-deployment-failure.outputs.environment || 'production' }}"
          if [[ -z "$ROLLBACK_ENV" ]]; then
            ROLLBACK_ENV="production"
          fi

          # Create deployment
          DEPLOYMENT_ID=$(gh api "/repos/$GITHUB_REPOSITORY/deployments" \
            --method POST \
            --field ref="$ROLLBACK_TARGET" \
            --field environment="$ROLLBACK_ENV" \
            --field description="Auto-rollback: $ROLLBACK_REASON" \
            --field auto_merge=false \
            --jq '.id')

          echo "ðŸ“¦ Created rollback deployment: $DEPLOYMENT_ID"

          # Update deployment status to in_progress
          gh api "/repos/$GITHUB_REPOSITORY/deployments/$DEPLOYMENT_ID/statuses" \
            --method POST \
            --field state="in_progress" \
            --field description="Rollback in progress..."

          # Execute the actual rollback (this would be deployment-specific)
          echo "ðŸ”§ Executing rollback commands..."

          # This is where you'd run your actual rollback scripts
          # Examples:
          # - Kubernetes: kubectl rollout undo deployment/app
          # - Docker: docker service update --rollback service-name
          # - Terraform: terraform apply -var="image_tag=$ROLLBACK_TARGET"

          # For demonstration, we'll simulate the rollback
          echo "Simulating rollback execution..."
          sleep 10

          # Verify rollback health
          echo "ðŸ¥ Verifying rollback health..."

          # Wait for services to stabilize
          sleep 30

          # Check health endpoints
          HEALTH_CHECK_PASSED=true
          for endpoint in "https://api.summit.dev/health" "https://graph.summit.dev/health"; do
            if ! curl -f -s --max-time 30 "$endpoint" > /dev/null; then
              echo "âŒ Health check failed for $endpoint"
              HEALTH_CHECK_PASSED=false
            fi
          done

          if [[ "$HEALTH_CHECK_PASSED" == "true" ]]; then
            echo "âœ… Rollback completed successfully"

            # Update deployment status to success
            gh api "/repos/$GITHUB_REPOSITORY/deployments/$DEPLOYMENT_ID/statuses" \
              --method POST \
              --field state="success" \
              --field description="Rollback completed successfully"
          else
            echo "âŒ Rollback health checks failed"

            # Update deployment status to failure
            gh api "/repos/$GITHUB_REPOSITORY/deployments/$DEPLOYMENT_ID/statuses" \
              --method POST \
              --field state="failure" \
              --field description="Rollback failed health checks"

            exit 1
          fi

      - name: Notify stakeholders
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ROLLBACK_ENV: ${{ needs.detect-deployment-failure.outputs.environment }}
          SLO_CONTEXT: ${{ needs.detect-deployment-failure.outputs.slo_context }}
        run: |
          echo "ðŸ“¢ Notifying stakeholders of rollback..."

          ROLLBACK_STATUS="${{ job.status }}"
          ROLLBACK_TARGET="${{ steps.prepare.outputs.rollback_target }}"
          ROLLBACK_REASON="${{ steps.prepare.outputs.rollback_reason }}"
          ENVIRONMENT="${ROLLBACK_ENV:-production}"

          # Create incident issue
          ISSUE_BODY="## ðŸš¨ Auto-Rollback Executed

          **Status**: $ROLLBACK_STATUS
          **Target**: $ROLLBACK_TARGET
          **Reason**: $ROLLBACK_REASON
          **Environment**: $ENVIRONMENT
          **SLO Context**: ${SLO_CONTEXT:-n/a}
          **Time**: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          ### Actions Taken
          - â†©ï¸ Automatic rollback triggered
          - ðŸ¥ Health checks performed
          - ðŸ”§ Deployment reverted to last known good state

          ### Next Steps
          - [ ] Investigate root cause of failure
          - [ ] Fix underlying issue
          - [ ] Test fix in staging environment
          - [ ] Plan forward deployment

          **Auto-generated by Release Captain ðŸš¢**"

          gh issue create \
            --title "ðŸš¨ Auto-Rollback: $(date +%Y-%m-%d) - $ROLLBACK_REASON" \
            --body "$ISSUE_BODY" \
            --label "incident,auto-rollback,priority:high"

          # Post to team channel (would integrate with Slack/Teams)
          echo "ðŸ”” Team notifications sent"

  post-rollback-analysis:
    name: ðŸ“Š Post-Rollback Analysis
    needs: [execute-rollback]
    if: always() && needs.execute-rollback.result != 'skipped'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Collect rollback metrics
        run: |
          echo "ðŸ“Š Collecting rollback metrics..."

          # Calculate rollback time
          ROLLBACK_DURATION="Unknown"
          if [[ "${{ needs.execute-rollback.result }}" == "success" ]]; then
            echo "âœ… Rollback completed successfully"
            echo "â±ï¸ Duration: $ROLLBACK_DURATION"
          else
            echo "âŒ Rollback failed"
          fi

          # Store metrics for analysis
          cat > /tmp/rollback-metrics.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "success": "${{ needs.execute-rollback.result == 'success' }}",
            "duration": "$ROLLBACK_DURATION",
            "trigger": "${{ github.event_name }}",
            "reason": "${{ needs.detect-deployment-failure.outputs.failure_type || 'health_monitor' }}"
          }
          EOF

          echo "ðŸ“ˆ Metrics saved for analysis"

      - name: Update runbooks
        run: |
          echo "ðŸ“š Updating incident runbooks with rollback data..."

          # This would update your incident response documentation
          # with lessons learned and timing data

          echo "ðŸ“– Runbook updates completed"
