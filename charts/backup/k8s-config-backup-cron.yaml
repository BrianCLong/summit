apiVersion: batch/v1
kind: CronJob
metadata:
  name: k8s-config-backup
  namespace: backup-system
  labels:
    app.kubernetes.io/name: k8s-config-backup
    app.kubernetes.io/component: backup
    app.kubernetes.io/part-of: intelgraph
spec:
  schedule: '0 3 * * *' # Daily at 3 AM UTC
  timeZone: 'UTC'
  successfulJobsHistoryLimit: 7
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  startingDeadlineSeconds: 300
  jobTemplate:
    spec:
      activeDeadlineSeconds: 3600 # 1 hour timeout
      backoffLimit: 2
      template:
        metadata:
          labels:
            app.kubernetes.io/name: k8s-config-backup
            app.kubernetes.io/component: backup
        spec:
          restartPolicy: Never
          securityContext:
            runAsNonRoot: true
            runAsUser: 65532
            runAsGroup: 65532
            fsGroup: 65532
          serviceAccountName: k8s-config-backup
          containers:
            - name: k8s-config-backup
              image: bitnami/kubectl:latest
              imagePullPolicy: IfNotPresent
              command:
                - /bin/bash
                - -c
                - |
                  set -euo pipefail

                  # Configuration
                  BACKUP_NAME="k8s-config-backup-$(date +%Y%m%d-%H%M%S)"
                  BACKUP_DIR="/backups/${BACKUP_NAME}"
                  RETENTION_DAYS=30

                  echo "Starting Kubernetes configuration backup: ${BACKUP_NAME}"

                  # Create backup directory structure
                  mkdir -p "${BACKUP_DIR}/secrets"
                  mkdir -p "${BACKUP_DIR}/configmaps" 
                  mkdir -p "${BACKUP_DIR}/deployments"
                  mkdir -p "${BACKUP_DIR}/services"
                  mkdir -p "${BACKUP_DIR}/ingress"
                  mkdir -p "${BACKUP_DIR}/pvc"
                  mkdir -p "${BACKUP_DIR}/networkpolicies"
                  mkdir -p "${BACKUP_DIR}/rbac"
                  mkdir -p "${BACKUP_DIR}/custom-resources"

                  # Define namespaces to backup
                  NAMESPACES=(
                    "default"
                    "database" 
                    "monitoring"
                    "security"
                    "cache"
                    "backup-system"
                    "ingress-nginx"
                    "cert-manager"
                  )

                  # Function to backup resource with metadata
                  backup_resource() {
                    local resource_type="$1"
                    local namespace="$2"
                    local output_dir="$3"
                    
                    echo "Backing up ${resource_type} in namespace ${namespace}..."
                    
                    # Get all resources of this type in the namespace
                    kubectl get ${resource_type} -n ${namespace} -o json > "${output_dir}/${namespace}-${resource_type}.json" 2>/dev/null || {
                      echo "No ${resource_type} found in namespace ${namespace}"
                      echo '{"apiVersion":"v1","kind":"List","items":[]}' > "${output_dir}/${namespace}-${resource_type}.json"
                    }
                    
                    # Also create YAML backup for readability
                    kubectl get ${resource_type} -n ${namespace} -o yaml > "${output_dir}/${namespace}-${resource_type}.yaml" 2>/dev/null || {
                      echo "apiVersion: v1\nkind: List\nitems: []" > "${output_dir}/${namespace}-${resource_type}.yaml"
                    }
                  }

                  # Backup secrets (with special handling for sensitive data)
                  echo "Backing up secrets..."
                  for ns in "${NAMESPACES[@]}"; do
                    # Get list of secrets
                    kubectl get secrets -n ${ns} -o json | \
                    jq '
                      .items[] | 
                      select(.type != "kubernetes.io/service-account-token") |
                      {
                        apiVersion: .apiVersion,
                        kind: .kind,
                        metadata: {
                          name: .metadata.name,
                          namespace: .metadata.namespace,
                          labels: .metadata.labels,
                          annotations: .metadata.annotations
                        },
                        type: .type,
                        data: (.data | to_entries | map({key: .key, value: "[REDACTED]"}) | from_entries)
                      }
                    ' > "${BACKUP_DIR}/secrets/${ns}-secrets-metadata.json" 2>/dev/null || {
                      echo '[]' > "${BACKUP_DIR}/secrets/${ns}-secrets-metadata.json"
                    }
                    
                    # Create a list of secrets for restore reference
                    kubectl get secrets -n ${ns} -o name > "${BACKUP_DIR}/secrets/${ns}-secrets-list.txt" 2>/dev/null || {
                      touch "${BACKUP_DIR}/secrets/${ns}-secrets-list.txt"
                    }
                  done

                  # Backup ConfigMaps
                  echo "Backing up configmaps..."
                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "configmaps" "${ns}" "${BACKUP_DIR}/configmaps"
                  done

                  # Backup Deployments
                  echo "Backing up deployments..."
                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "deployments" "${ns}" "${BACKUP_DIR}/deployments"
                  done

                  # Backup Services
                  echo "Backing up services..."
                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "services" "${ns}" "${BACKUP_DIR}/services"
                  done

                  # Backup Ingress
                  echo "Backing up ingress resources..."
                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "ingress" "${ns}" "${BACKUP_DIR}/ingress"
                  done

                  # Backup PersistentVolumeClaims
                  echo "Backing up persistent volume claims..."
                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "pvc" "${ns}" "${BACKUP_DIR}/pvc"
                  done

                  # Backup NetworkPolicies
                  echo "Backing up network policies..."
                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "networkpolicies" "${ns}" "${BACKUP_DIR}/networkpolicies"
                  done

                  # Backup RBAC resources
                  echo "Backing up RBAC resources..."
                  kubectl get clusterroles -o yaml > "${BACKUP_DIR}/rbac/clusterroles.yaml"
                  kubectl get clusterrolebindings -o yaml > "${BACKUP_DIR}/rbac/clusterrolebindings.yaml"

                  for ns in "${NAMESPACES[@]}"; do
                    backup_resource "roles" "${ns}" "${BACKUP_DIR}/rbac"
                    backup_resource "rolebindings" "${ns}" "${BACKUP_DIR}/rbac"
                    backup_resource "serviceaccounts" "${ns}" "${BACKUP_DIR}/rbac"
                  done

                  # Backup Custom Resources
                  echo "Backing up custom resources..."

                  # Get CRDs
                  kubectl get crd -o yaml > "${BACKUP_DIR}/custom-resources/crds.yaml"

                  # Backup Prometheus resources (if exists)
                  kubectl get prometheusrules -A -o yaml > "${BACKUP_DIR}/custom-resources/prometheusrules.yaml" 2>/dev/null || echo "No PrometheusRules found"
                  kubectl get servicemonitors -A -o yaml > "${BACKUP_DIR}/custom-resources/servicemonitors.yaml" 2>/dev/null || echo "No ServiceMonitors found"

                  # Backup cert-manager resources (if exists)
                  kubectl get certificates -A -o yaml > "${BACKUP_DIR}/custom-resources/certificates.yaml" 2>/dev/null || echo "No Certificates found"
                  kubectl get clusterissuers -A -o yaml > "${BACKUP_DIR}/custom-resources/clusterissuers.yaml" 2>/dev/null || echo "No ClusterIssuers found"

                  # Backup network policies
                  kubectl get networkpolicies -A -o yaml > "${BACKUP_DIR}/custom-resources/networkpolicies.yaml" 2>/dev/null || echo "No NetworkPolicies found"

                  # Create cluster information
                  echo "Collecting cluster information..."
                  kubectl cluster-info > "${BACKUP_DIR}/cluster-info.txt"
                  kubectl get nodes -o yaml > "${BACKUP_DIR}/nodes.yaml"
                  kubectl get namespaces -o yaml > "${BACKUP_DIR}/namespaces.yaml"
                  kubectl get pv -o yaml > "${BACKUP_DIR}/persistent-volumes.yaml"
                  kubectl get storageclasses -o yaml > "${BACKUP_DIR}/storage-classes.yaml"

                  # Create backup manifest
                  BACKUP_SIZE=$(du -sb "${BACKUP_DIR}" | cut -f1)
                  RESOURCE_COUNTS=$(find "${BACKUP_DIR}" -name "*.json" -o -name "*.yaml" | wc -l)

                  cat > "${BACKUP_DIR}/backup-manifest.json" << EOF
                  {
                    "backup_name": "${BACKUP_NAME}",
                    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                    "backup_type": "kubernetes_configuration",
                    "cluster_name": "${CLUSTER_NAME:-unknown}",
                    "kubernetes_version": "$(kubectl version --client=false -o json | jq -r '.serverVersion.gitVersion' 2>/dev/null || echo 'unknown')",
                    "namespaces_backed_up": $(printf '%s\n' "${NAMESPACES[@]}" | jq -R . | jq -s .),
                    "backup_size_bytes": ${BACKUP_SIZE},
                    "resource_files_count": ${RESOURCE_COUNTS},
                    "retention_policy": "${RETENTION_DAYS} days",
                    "backup_method": "kubectl_export",
                    "includes_secrets_metadata": true,
                    "secrets_data_redacted": true
                  }
                  EOF

                  # Create restoration script
                  cat > "${BACKUP_DIR}/restore-script.sh" << 'EOF'
                  #!/bin/bash
                  # Kubernetes Configuration Restore Script
                  # Usage: ./restore-script.sh [namespace]

                  set -euo pipefail

                  RESTORE_NAMESPACE=${1:-""}
                  BACKUP_DIR=$(dirname "$0")

                  echo "Starting Kubernetes configuration restore..."

                  if [[ -n "$RESTORE_NAMESPACE" ]]; then
                    echo "Restoring configuration for namespace: $RESTORE_NAMESPACE"
                    
                    # Create namespace if it doesn't exist
                    kubectl create namespace "$RESTORE_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
                    
                    # Restore configmaps
                    if [[ -f "${BACKUP_DIR}/configmaps/${RESTORE_NAMESPACE}-configmaps.yaml" ]]; then
                      kubectl apply -f "${BACKUP_DIR}/configmaps/${RESTORE_NAMESPACE}-configmaps.yaml"
                    fi
                    
                    # Restore services
                    if [[ -f "${BACKUP_DIR}/services/${RESTORE_NAMESPACE}-services.yaml" ]]; then
                      kubectl apply -f "${BACKUP_DIR}/services/${RESTORE_NAMESPACE}-services.yaml"
                    fi
                    
                    # Restore deployments
                    if [[ -f "${BACKUP_DIR}/deployments/${RESTORE_NAMESPACE}-deployments.yaml" ]]; then
                      kubectl apply -f "${BACKUP_DIR}/deployments/${RESTORE_NAMESPACE}-deployments.yaml"
                    fi
                    
                    echo "Note: Secrets must be restored manually due to security considerations"
                    echo "Refer to: ${BACKUP_DIR}/secrets/${RESTORE_NAMESPACE}-secrets-list.txt"
                  else
                    echo "Please specify a namespace to restore: ./restore-script.sh <namespace>"
                    echo "Available namespaces in backup:"
                    ls "${BACKUP_DIR}/configmaps" | grep -o '^[^-]*' | sort -u
                  fi
                  EOF

                  chmod +x "${BACKUP_DIR}/restore-script.sh"

                  # Create inventory report
                  echo "Creating inventory report..."
                  cat > "${BACKUP_DIR}/inventory-report.txt" << EOF
                  Kubernetes Configuration Backup Inventory
                  ========================================

                  Backup Name: ${BACKUP_NAME}
                  Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
                  Cluster: ${CLUSTER_NAME:-unknown}

                  Namespaces Backed Up:
                  $(printf '  - %s\n' "${NAMESPACES[@]}")

                  Resource Counts:
                  EOF

                  for ns in "${NAMESPACES[@]}"; do
                    echo "  Namespace: ${ns}" >> "${BACKUP_DIR}/inventory-report.txt"
                    echo "    Secrets: $(kubectl get secrets -n ${ns} --no-headers 2>/dev/null | wc -l)" >> "${BACKUP_DIR}/inventory-report.txt"
                    echo "    ConfigMaps: $(kubectl get configmaps -n ${ns} --no-headers 2>/dev/null | wc -l)" >> "${BACKUP_DIR}/inventory-report.txt"
                    echo "    Deployments: $(kubectl get deployments -n ${ns} --no-headers 2>/dev/null | wc -l)" >> "${BACKUP_DIR}/inventory-report.txt"
                    echo "    Services: $(kubectl get services -n ${ns} --no-headers 2>/dev/null | wc -l)" >> "${BACKUP_DIR}/inventory-report.txt"
                  done

                  # Compress backup
                  echo "Compressing backup..."
                  tar -czf "${BACKUP_DIR}.tar.gz" -C "/backups" "${BACKUP_NAME}"
                  rm -rf "${BACKUP_DIR}"

                  # Upload to S3 with encryption
                  echo "Uploading to S3..."
                  aws s3 cp "${BACKUP_DIR}.tar.gz" \
                    "s3://${BACKUP_BUCKET}/kubernetes/$(date +%Y/%m/%d)/${BACKUP_NAME}.tar.gz" \
                    --server-side-encryption AES256 \
                    --storage-class STANDARD_IA \
                    --metadata backup-type=kubernetes,cluster=${CLUSTER_NAME:-unknown},timestamp=$(date +%s)

                  # Cross-region replication
                  echo "Replicating to DR region..."
                  aws s3 cp "s3://${BACKUP_BUCKET}/kubernetes/$(date +%Y/%m/%d)/${BACKUP_NAME}.tar.gz" \
                    "s3://${DR_BACKUP_BUCKET}/kubernetes/$(date +%Y/%m/%d)/${BACKUP_NAME}.tar.gz" \
                    --source-region ${AWS_REGION} \
                    --region ${DR_AWS_REGION}

                  # Cleanup local backup
                  rm -f "${BACKUP_DIR}.tar.gz"

                  # Cleanup old backups
                  echo "Cleaning up old backups..."
                  aws s3 ls "s3://${BACKUP_BUCKET}/kubernetes/" --recursive | \
                    awk '{if($1 < "'$(date -d "${RETENTION_DAYS} days ago" +%Y-%m-%d)'") print $4}' | \
                    xargs -r -I {} aws s3 rm "s3://${BACKUP_BUCKET}/{}"

                  # Send success notification
                  curl -X POST "${SLACK_WEBHOOK_URL}" \
                    -H 'Content-Type: application/json' \
                    -d "{\"text\":\"âœ… Kubernetes configuration backup completed: ${BACKUP_NAME}\\nCluster: ${CLUSTER_NAME:-unknown}\\nSize: $(numfmt --to=iec ${BACKUP_SIZE})\"}" || true

                  echo "Kubernetes configuration backup completed successfully: ${BACKUP_NAME}"

              env:
                - name: BACKUP_BUCKET
                  valueFrom:
                    configMapKeyRef:
                      name: backup-config
                      key: backup-bucket
                - name: DR_BACKUP_BUCKET
                  valueFrom:
                    configMapKeyRef:
                      name: backup-config
                      key: dr-backup-bucket
                - name: AWS_REGION
                  valueFrom:
                    configMapKeyRef:
                      name: backup-config
                      key: aws-region
                - name: DR_AWS_REGION
                  valueFrom:
                    configMapKeyRef:
                      name: backup-config
                      key: dr-aws-region
                - name: CLUSTER_NAME
                  valueFrom:
                    configMapKeyRef:
                      name: backup-config
                      key: cluster-name
                - name: SLACK_WEBHOOK_URL
                  valueFrom:
                    secretKeyRef:
                      name: backup-secrets
                      key: slack-webhook-url
                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: backup-secrets
                      key: aws-access-key-id
                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: backup-secrets
                      key: aws-secret-access-key
              resources:
                requests:
                  memory: '512Mi'
                  cpu: '250m'
                limits:
                  memory: '2Gi'
                  cpu: '1000m'
              volumeMounts:
                - name: backup-storage
                  mountPath: /backups
          volumes:
            - name: backup-storage
              emptyDir:
                sizeLimit: 10Gi
          tolerations:
            - key: 'backup-workload'
              operator: 'Equal'
              value: 'true'
              effect: 'NoSchedule'
          nodeSelector:
            node-type: 'backup-optimized'
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: k8s-config-backup
  namespace: backup-system
  labels:
    app.kubernetes.io/name: k8s-config-backup
    app.kubernetes.io/component: backup
  annotations:
    eks.amazonaws.com/role-arn: 'arn:aws:iam::123456789012:role/k8s-backup-role'
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: k8s-config-backup
rules:
  - apiGroups: ['']
    resources: ['*']
    verbs: ['get', 'list']
  - apiGroups: ['apps']
    resources: ['*']
    verbs: ['get', 'list']
  - apiGroups: ['networking.k8s.io']
    resources: ['*']
    verbs: ['get', 'list']
  - apiGroups: ['rbac.authorization.k8s.io']
    resources: ['*']
    verbs: ['get', 'list']
  - apiGroups: ['apiextensions.k8s.io']
    resources: ['customresourcedefinitions']
    verbs: ['get', 'list']
  - apiGroups: ['monitoring.coreos.com']
    resources: ['*']
    verbs: ['get', 'list']
  - apiGroups: ['cert-manager.io']
    resources: ['*']
    verbs: ['get', 'list']
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: k8s-config-backup
subjects:
  - kind: ServiceAccount
    name: k8s-config-backup
    namespace: backup-system
roleRef:
  kind: ClusterRole
  name: k8s-config-backup
  apiGroup: rbac.authorization.k8s.io
