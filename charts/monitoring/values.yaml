# IntelGraph Monitoring Stack Configuration
# Production-ready observability for Maestro Orchestration System
global:
  environment: production
  domain: intelgraph.ai
  clusterName: intelgraph-prod
  region: us-west-2

# Prometheus Configuration - High Availability Setup
prometheus:
  enabled: true

  # HA Configuration
  server:
    replicaCount: 2
    retention: '30d'
    retentionSize: '100GB'

    # Storage Configuration
    persistentVolume:
      enabled: true
      size: 150Gi
      storageClass: gp3-ssd
      accessModes:
        - ReadWriteOnce

    # Resource Configuration
    resources:
      requests:
        memory: '4Gi'
        cpu: '1000m'
      limits:
        memory: '8Gi'
        cpu: '4000m'

    # Anti-affinity for HA
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                    - prometheus
            topologyKey: kubernetes.io/hostname

    # Prometheus Configuration
    config:
      global:
        scrape_interval: 15s
        evaluation_interval: 15s
        external_labels:
          cluster: intelgraph-prod
          environment: production

      # Alerting Configuration
      alerting:
        alertmanagers:
          - static_configs:
              - targets:
                  - alertmanager:9093

      # Rule Files
      rule_files:
        - '/etc/prometheus/rules/*.yml'

      # Scrape Configurations
      scrape_configs:
        # Kubernetes API Server
        - job_name: 'kubernetes-apiservers'
          kubernetes_sd_configs:
            - role: endpoints
          scheme: https
          tls_config:
            ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
          relabel_configs:
            - source_labels:
                [
                  __meta_kubernetes_namespace,
                  __meta_kubernetes_service_name,
                  __meta_kubernetes_endpoint_port_name,
                ]
              action: keep
              regex: default;kubernetes;https

        # Kubernetes Nodes
        - job_name: 'kubernetes-nodes'
          kubernetes_sd_configs:
            - role: node
          scheme: https
          tls_config:
            ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
          relabel_configs:
            - action: labelmap
              regex: __meta_kubernetes_node_label_(.+)
            - target_label: __address__
              replacement: kubernetes.default.svc:443
            - source_labels: [__meta_kubernetes_node_name]
              regex: (.+)
              target_label: __metrics_path__
              replacement: /api/v1/nodes/${1}/proxy/metrics

        # Maestro Orchestrator
        - job_name: 'maestro-orchestrator'
          kubernetes_sd_configs:
            - role: pod
              namespaces:
                names:
                  - default
                  - maestro
          relabel_configs:
            - source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
              action: keep
              regex: maestro
            - source_labels: [__meta_kubernetes_pod_container_port_name]
              action: keep
              regex: metrics
            - source_labels: [__meta_kubernetes_pod_name]
              target_label: pod
            - source_labels: [__meta_kubernetes_namespace]
              target_label: namespace

        # Neo4j Database
        - job_name: 'neo4j'
          kubernetes_sd_configs:
            - role: service
              namespaces:
                names:
                  - database
          relabel_configs:
            - source_labels: [__meta_kubernetes_service_label_app]
              action: keep
              regex: neo4j
            - source_labels: [__meta_kubernetes_service_port_name]
              action: keep
              regex: metrics

        # Redis Cache
        - job_name: 'redis'
          kubernetes_sd_configs:
            - role: service
              namespaces:
                names:
                  - cache
          relabel_configs:
            - source_labels: [__meta_kubernetes_service_label_app]
              action: keep
              regex: redis
            - source_labels: [__meta_kubernetes_service_port_name]
              action: keep
              regex: metrics

        # Ingress Controller
        - job_name: 'nginx-ingress'
          kubernetes_sd_configs:
            - role: pod
              namespaces:
                names:
                  - ingress-nginx
          relabel_configs:
            - source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
              action: keep
              regex: ingress-nginx
            - source_labels: [__meta_kubernetes_pod_container_port_number]
              action: keep
              regex: '10254'

        # Blackbox synthetic probes
        - job_name: 'blackbox'
          metrics_path: /probe
          params:
            module: [http_2xx_ttfb]
          static_configs:
            - targets:
                - https://maestro.intelgraph.ai/health
                - https://maestro.intelgraph.ai/graphql
          relabel_configs:
            - source_labels: [__address__]
              target_label: __param_target
            - source_labels: [__param_target]
              target_label: instance
            - target_label: __address__
              replacement: blackbox-exporter.monitoring.svc.cluster.local:9115

  # Alertmanager Configuration
  alertmanager:
    enabled: true
    replicaCount: 2

    # Storage
    persistentVolume:
      enabled: true
      size: 10Gi
      storageClass: gp3-ssd

    # Configuration
    # Mount secret containing PagerDuty routing key
    extraSecretMounts:
      - name: pagerduty-routing-key
        secretName: pagerduty-routing-key
        mountPath: /etc/alertmanager/secrets
        readOnly: true

    config:
      global:
        smtp_smarthost: 'smtp.gmail.com:587'
        smtp_from: 'alerts@intelgraph.ai'
        slack_api_url: '${SLACK_WEBHOOK_URL}'

      # Routing Configuration
      route:
        group_by: ['alertname', 'cluster', 'service']
        group_wait: 10s
        group_interval: 10s
        repeat_interval: 1h
        receiver: 'default'
        routes:
          - match:
              severity: critical
            receiver: 'critical-alerts'
            group_wait: 5s
            repeat_interval: 15m
          - match:
              severity: warning
            receiver: 'warning-alerts'
            repeat_interval: 1h

      # Receivers Configuration
      receivers:
        - name: 'default'
          slack_configs:
            - channel: '#intelgraph-alerts'
              title: 'IntelGraph Alert'
              text: '{{ range .Alerts }}{{ .Annotations.summary }}\n{{ .Annotations.description }}{{ end }}'

        - name: 'critical-alerts'
          slack_configs:
            - channel: '#intelgraph-critical'
              title: 'CRITICAL: IntelGraph Alert'
              text: '{{ range .Alerts }}{{ .Annotations.summary }}\n{{ .Annotations.description }}{{ end }}'
              send_resolved: true
          pagerduty_configs:
            - routing_key_file: '/etc/alertmanager/secrets/pagerduty-routing-key'
              description: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'

        - name: 'warning-alerts'
          slack_configs:
            - channel: '#intelgraph-warnings'
              title: 'Warning: IntelGraph Alert'
              text: '{{ range .Alerts }}{{ .Annotations.summary }}\n{{ .Annotations.description }}{{ end }}'

# Grafana Configuration
grafana:
  enabled: true

  # Admin Configuration
  adminUser: admin
  adminPassword: '${GRAFANA_ADMIN_PASSWORD}'

  # Persistence
  persistence:
    enabled: true
    size: 20Gi
    storageClassName: gp3-ssd

  # Resources
  resources:
    requests:
      memory: '1Gi'
      cpu: '500m'
    limits:
      memory: '2Gi'
      cpu: '1000m'

  # Ingress
  ingress:
    enabled: true
    ingressClassName: nginx
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-prod
      nginx.ingress.kubernetes.io/ssl-redirect: 'true'
    hosts:
      - grafana.intelgraph.ai
    tls:
      - secretName: grafana-tls
        hosts:
          - grafana.intelgraph.ai

  # Data Sources
  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
        - name: Prometheus
          type: prometheus
          url: http://prometheus-server:80
          access: proxy
          isDefault: true
          editable: false

        - name: Loki
          type: loki
          url: http://loki:3100
          access: proxy
          editable: false

        - name: Jaeger
          type: jaeger
          url: http://jaeger-query:16686
          access: proxy
          editable: false

  # Dashboard Providers
  dashboardProviders:
    dashboardproviders.yaml:
      apiVersion: 1
      providers:
        - name: 'default'
          orgId: 1
          folder: ''
          type: file
          disableDeletion: false
          editable: true
          options:
            path: /var/lib/grafana/dashboards/default
        - name: 'intelgraph'
          orgId: 1
          folder: 'IntelGraph'
          type: file
          disableDeletion: false
          editable: true
          options:
            path: /var/lib/grafana/dashboards/intelgraph

  # Configuration
  grafana.ini:
    server:
      domain: grafana.intelgraph.ai
      root_url: https://grafana.intelgraph.ai
    security:
      admin_user: admin
      secret_key: '${GRAFANA_SECRET_KEY}'
    auth:
      disable_login_form: false
    auth.anonymous:
      enabled: false
    smtp:
      enabled: true
      host: smtp.gmail.com:587
      user: alerts@intelgraph.ai
      password: '${SMTP_PASSWORD}'
      from_address: alerts@intelgraph.ai
      from_name: IntelGraph Monitoring
    alerting:
      enabled: true
      execute_alerts: true

# Jaeger Distributed Tracing
jaeger:
  enabled: true

  # All-in-one deployment for production
  allInOne:
    enabled: true

    # Storage Configuration
    storage:
      type: elasticsearch
      elasticsearch:
        host: elasticsearch.logging
        port: 9200
        indexPrefix: jaeger

    # Resources
    resources:
      requests:
        memory: '1Gi'
        cpu: '500m'
      limits:
        memory: '2Gi'
        cpu: '1000m'

    # Ingress
    ingress:
      enabled: true
      ingressClassName: nginx
      annotations:
        cert-manager.io/cluster-issuer: letsencrypt-prod
        nginx.ingress.kubernetes.io/ssl-redirect: 'true'
      hosts:
        - jaeger.intelgraph.ai
      tls:
        - secretName: jaeger-tls
          hosts:
            - jaeger.intelgraph.ai

  # OpenTelemetry Collector
  otel:
    enabled: true
    mode: deployment

    # Configuration
    config:
      receivers:
        otlp:
          protocols:
            grpc:
              endpoint: 0.0.0.0:4317
            http:
              endpoint: 0.0.0.0:4318
        jaeger:
          protocols:
            grpc:
              endpoint: 0.0.0.0:14250
            thrift_http:
              endpoint: 0.0.0.0:14268
            thrift_compact:
              endpoint: 0.0.0.0:6831

      processors:
        batch:
        memory_limiter:
          limit_mib: 1000

      exporters:
        jaeger:
          endpoint: jaeger-collector:14250
          tls:
            insecure: true
        logging:
          loglevel: info

      service:
        pipelines:
          traces:
            receivers: [otlp, jaeger]
            processors: [memory_limiter, batch]
            exporters: [jaeger, logging]

# Loki Logging Stack
loki:
  enabled: true

  # Loki Configuration
  loki:
    auth_enabled: false
    server:
      http_listen_port: 3100

    ingester:
      lifecycler:
        address: 127.0.0.1
        ring:
          kvstore:
            store: inmemory
          replication_factor: 1
        final_sleep: 0s
      chunk_idle_period: 5m
      chunk_retain_period: 30s

    schema_config:
      configs:
        - from: 2020-05-15
          store: boltdb-shipper
          object_store: s3
          schema: v11
          index:
            prefix: loki_index_
            period: 24h

    storage_config:
      boltdb_shipper:
        active_index_directory: /loki/index
        cache_location: /loki/index_cache
        shared_store: s3
      aws:
        s3: s3://intelgraph-loki-storage/loki
        region: us-west-2
        access_key_id: '${AWS_ACCESS_KEY_ID}'
        secret_access_key: '${AWS_SECRET_ACCESS_KEY}'

    limits_config:
      enforce_metric_name: false
      reject_old_samples: true
      reject_old_samples_max_age: 168h
      ingestion_rate_mb: 16
      ingestion_burst_size_mb: 24

    chunk_store_config:
      max_look_back_period: 0

    table_manager:
      retention_deletes_enabled: true
      retention_period: 168h

  # Persistence
  persistence:
    enabled: true
    size: 50Gi
    storageClassName: gp3-ssd

  # Resources
  resources:
    requests:
      memory: '2Gi'
      cpu: '1000m'
    limits:
      memory: '4Gi'
      cpu: '2000m'

# Promtail Log Collection
promtail:
  enabled: true

  # Configuration
  config:
    clients:
      - url: http://loki:3100/loki/api/v1/push

    positions:
      filename: /tmp/positions.yaml

    scrape_configs:
      # Kubernetes Pod Logs
      - job_name: kubernetes-pods
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
          - source_labels:
              - __meta_kubernetes_pod_controller_name
            regex: ([0-9a-z-.]+?)(-[0-9a-f]{8,10})?
            action: replace
            target_label: __tmp_controller_name
          - source_labels:
              - __meta_kubernetes_pod_label_app_kubernetes_io_name
              - __meta_kubernetes_pod_label_app
              - __tmp_controller_name
              - __meta_kubernetes_pod_name
            regex: ^;*([^;]+)(;.*)?$
            action: replace
            target_label: app
          - source_labels:
              - __meta_kubernetes_pod_label_app_kubernetes_io_instance
              - __meta_kubernetes_pod_label_release
            regex: ^;*([^;]+)(;.*)?$
            action: replace
            target_label: instance
          - source_labels:
              - __meta_kubernetes_pod_label_app_kubernetes_io_component
              - __meta_kubernetes_pod_label_component
            regex: ^;*([^;]+)(;.*)?$
            action: replace
            target_label: component
          - action: replace
            source_labels:
              - __meta_kubernetes_pod_node_name
            target_label: node_name
          - action: replace
            source_labels:
              - __meta_kubernetes_namespace
            target_label: namespace
          - action: replace
            replacement: $1
            separator: /
            source_labels:
              - namespace
              - app
            target_label: job
          - action: replace
            source_labels:
              - __meta_kubernetes_pod_name
            target_label: pod
          - action: replace
            source_labels:
              - __meta_kubernetes_pod_container_name
            target_label: container
          - action: replace
            replacement: /var/log/pods/*$1/*.log
            separator: /
            source_labels:
              - __meta_kubernetes_pod_uid
              - __meta_kubernetes_pod_container_name
            target_label: __path__
          - action: replace
            regex: true/(.*)
            replacement: /var/log/pods/*$1/*.log
            separator: /
            source_labels:
              - __meta_kubernetes_pod_annotationpresent_kubernetes_io_config_hash
              - __meta_kubernetes_pod_annotation_kubernetes_io_config_hash
              - __meta_kubernetes_pod_container_name
            target_label: __path__

# Kube State Metrics
kube-state-metrics:
  enabled: true

  # Resources
  resources:
    requests:
      memory: '512Mi'
      cpu: '250m'
    limits:
      memory: '1Gi'
      cpu: '500m'

  # Service Monitor
  prometheus:
    monitor:
      enabled: true
      namespace: monitoring

# Node Exporter
node-exporter:
  enabled: true

  # Deploy as DaemonSet on all nodes
  hostNetwork: true
  hostPID: true

  # Resources
  resources:
    requests:
      memory: '128Mi'
      cpu: '100m'
    limits:
      memory: '256Mi'
      cpu: '200m'

  # Service Monitor
  prometheus:
    monitor:
      enabled: true
      namespace: monitoring

# Additional Configurations
serviceMonitor:
  enabled: true
  namespace: monitoring
  interval: 30s
  scrapeTimeout: 10s

# Network Policies
networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 3000 # Grafana
        - protocol: TCP
          port: 9090 # Prometheus
        - protocol: TCP
          port: 16686 # Jaeger
        - protocol: TCP
          port: 3100 # Loki
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 443 # HTTPS
        - protocol: UDP
          port: 53 # DNS
