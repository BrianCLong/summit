import { LineageGraph, LineageNode, LineageEdge } from './lineage.js';

export interface ProvEntity {
  'prov:type'?: string;
  [key: string]: any;
}

export interface ProvActivity {
  'prov:startTime'?: string;
  'prov:endTime'?: string;
  [key: string]: any;
}

export interface ProvAgent {
  'prov:type'?: string;
  [key: string]: any;
}

export interface ProvDocument {
  prefix: {
    [key: string]: string;
  };
  entity: {
    [key: string]: ProvEntity;
  };
  activity: {
    [key: string]: ProvActivity;
  };
  agent: {
    [key: string]: ProvAgent;
  };
  wasDerivedFrom?: {
    [key: string]: {
      'prov:generatedEntity': string;
      'prov:usedEntity': string;
      'prov:type'?: string;
    };
  };
  wasGeneratedBy?: {
    [key: string]: {
      'prov:entity': string;
      'prov:activity': string;
    };
  };
  used?: {
    [key: string]: {
      'prov:activity': string;
      'prov:entity': string;
    };
  };
  wasAttributedTo?: {
    [key: string]: {
      'prov:entity': string;
      'prov:agent': string;
    };
  };
  wasAssociatedWith?: {
    [key: string]: {
      'prov:activity': string;
      'prov:agent': string;
    };
  };
}

const ACTION_TYPES = ['Action', 'Job', 'Run', 'Task', 'Build', 'Deployment', 'MaestroRun'];
const AGENT_TYPES = ['User', 'System', 'Service', 'Bot', 'Agent'];

function isActivity(type: string): boolean {
  return ACTION_TYPES.includes(type) || type.endsWith('Run') || type.endsWith('Job');
}

function isAgent(type: string): boolean {
  return AGENT_TYPES.includes(type);
}

export function convertLineageToProv(graph: LineageGraph): ProvDocument {
  const doc: ProvDocument = {
    prefix: {
      prov: 'http://www.w3.org/ns/prov#',
      summit: 'https://summit.dev/provenance/',
    },
    entity: {},
    activity: {},
    agent: {},
    wasDerivedFrom: {},
    wasGeneratedBy: {},
    used: {},
    wasAttributedTo: {},
    wasAssociatedWith: {},
  };

  // Process Nodes
  for (const node of graph.nodes) {
    const id = `summit:${node.id}`;
    if (isActivity(node.type)) {
      doc.activity[id] = {
        'prov:type': node.type,
        'prov:label': node.label,
        'prov:startTime': node.createdAt.toISOString(),
        'prov:endTime': node.updatedAt.toISOString(),
        ...node.metadata,
      };
    } else if (isAgent(node.type)) {
      doc.agent[id] = {
        'prov:type': node.type,
        'prov:label': node.label,
        ...node.metadata,
      };
    } else {
      doc.entity[id] = {
        'prov:type': node.type,
        'prov:label': node.label,
        'prov:generatedAt': node.createdAt.toISOString(),
        ...node.metadata,
      };
    }
  }

  // Process Edges
  let relCounter = 0;
  for (const edge of graph.edges) {
    const sourceId = `summit:${edge.sourceId}`;
    const targetId = `summit:${edge.targetId}`;
    const relId = `_:rel${relCounter++}`;

    // Map relationships based on node types and edge relation
    // Note: LineageEdge in lineage.ts usually means Source -> Target dependency?
    // In lineage.ts: "edges.push({ sourceId: targetId, targetId: nodeId ... })" for "derivedFrom".
    // So if A derivedFrom B, edge is B -> A (source=B, target=A).

    // Check types of source and target
    const sourceNode = graph.nodes.find(n => n.id === edge.sourceId);
    const targetNode = graph.nodes.find(n => n.id === edge.targetId);

    const sourceType = sourceNode ? (isActivity(sourceNode.type) ? 'Activity' : isAgent(sourceNode.type) ? 'Agent' : 'Entity') : 'Entity';
    const targetType = targetNode ? (isActivity(targetNode.type) ? 'Activity' : isAgent(targetNode.type) ? 'Agent' : 'Entity') : 'Entity';

    if (edge.relation === 'derivedFrom') {
      // Entity -> Entity
       if (doc.wasDerivedFrom) {
         doc.wasDerivedFrom[relId] = {
           'prov:generatedEntity': targetId,
           'prov:usedEntity': sourceId,
         };
       }
    } else if (edge.relation === 'generatedBy' || (targetType === 'Entity' && sourceType === 'Activity')) {
        // Activity -> Entity (Entity was generated by Activity)
        if (doc.wasGeneratedBy) {
            doc.wasGeneratedBy[relId] = {
                'prov:entity': targetId,
                'prov:activity': sourceId,
            };
        }
    } else if (edge.relation === 'used' || (targetType === 'Activity' && sourceType === 'Entity')) {
        // Entity -> Activity (Activity used Entity)
        if (doc.used) {
            doc.used[relId] = {
                'prov:activity': targetId,
                'prov:entity': sourceId,
            };
        }
    } else if (edge.relation === 'attributedTo' || (targetType === 'Entity' && sourceType === 'Agent')) {
        // Agent -> Entity (Entity attributed to Agent)
        if (doc.wasAttributedTo) {
            doc.wasAttributedTo[relId] = {
                'prov:entity': targetId,
                'prov:agent': sourceId,
            };
        }
    } else if (targetType === 'Activity' && sourceType === 'Agent') {
        // Agent -> Activity (Activity associated with Agent)
        if (doc.wasAssociatedWith) {
            doc.wasAssociatedWith[relId] = {
                'prov:activity': targetId,
                'prov:agent': sourceId,
            };
        }
    } else {
       // Default fallback: DerivedFrom
       if (doc.wasDerivedFrom) {
         doc.wasDerivedFrom[relId] = {
           'prov:generatedEntity': targetId,
           'prov:usedEntity': sourceId,
           'prov:type': edge.relation
         };
       }
    }
  }

  return doc;
}
