import { logger } from '../../config/logger.js';
import type { ChatMessage, LlmOrchestrator } from '../types.js';

type TokenEstimator = (text: string) => number;

export interface ConstructContextParams {
  task: string;
  agentId: string;
  conversationHistory: ChatMessage[];
  agentMemory: Record<string, unknown>;
  tokenBudget: number;
  estimateTokens?: TokenEstimator;
}

export interface UpdateAgentMemoryParams {
  agentId: string;
  agentRole: string;
  tenantId: string;
  orchestrator: LlmOrchestrator;
  previousMemory: Record<string, unknown>;
  agentOutput: string;
  enableDynamicTemplate?: boolean;
}

const DEFAULT_TEMPLATE = {
  task_summary: '',
  agent_role_focus: '',
  global_strategies: [''],
  key_requirements: [''],
  constraints: [''],
  assumptions: [''],
  decisions: [{ decision: '', rationale: '', date: '' }],
  open_questions: [''],
  risks: [{ risk: '', mitigation: '' }],
  useful_artifacts: [{ type: '', path_or_link: '', notes: '' }],
  next_actions: [''],
  glossary: { term: 'definition' },
};

const TEMPLATE_PROMPT =
  'You are designing an intrinsic memory template for an autonomous agent. ' +
  'For the provided task description, return concise update instructions and a JSON memory template tailored to the task. ' +
  'Respond with ONLY JSON containing {"update_instructions": [...], "template": { ... }} suitable for tracking the task.';

const MEMORY_UPDATE_INSTRUCTION =
  'You are maintaining the memory of an agent working as [ROLE] in a multi-agent conversation.\n' +
  'Use the old memory and the newest output by the agent to populate and update the current memory json with factual information.\n' +
  'For context, old memory content:\n[MEMORY CONTENT]\nCurrent content generated by the agent:\n[AGENT OUTPUT]\n' +
  'Update the memory content to incorporate new information while preserving key historical context.\n' +
  'The updated content should be concise and focus on information relevant to both the old memory and the newly generated output.';

function defaultTokenEstimator(text: string): number {
  if (!text) {
    return 0;
  }
  return Math.ceil(text.length / 4);
}

export class IntrinsicMemoryEngine {
  private readonly memories = new Map<string, Record<string, unknown>>();
  private readonly templates = new Map<string, Record<string, unknown>>();

  constructContext(params: ConstructContextParams): ChatMessage[] {
    const estimate = params.estimateTokens ?? defaultTokenEstimator;
    const context: ChatMessage[] = [];
    const taskMessage = params.conversationHistory[0] ?? { role: 'user', content: params.task };
    context.push(taskMessage);

    const memoryContent = params.agentMemory ?? {};
    const memoryString = JSON.stringify(memoryContent);
    context.push({ role: 'system', content: `Agent memory: ${memoryString}` });

    let used = estimate(taskMessage.content ?? '') + estimate(memoryString);
    const history = params.conversationHistory.slice(1);
    const reversed = [...history].reverse();
    const selected: ChatMessage[] = [];
    for (const turn of reversed) {
      const tokens = estimate(turn.content ?? '');
      if (used + tokens > params.tokenBudget) {
        break;
      }
      selected.push(turn);
      used += tokens;
    }
    selected.reverse().forEach((turn) => context.push(turn));

    logger.info(
      {
        event: 'context_constructed',
        agentId: params.agentId,
        turnsIncluded: selected.length,
        approxTokens: used,
      },
      'Intrinsic memory context constructed',
    );

    return context;
  }

  getMemory(agentId: string): Record<string, unknown> {
    if (!this.memories.has(agentId)) {
      this.memories.set(agentId, { ...DEFAULT_TEMPLATE });
    }
    return this.memories.get(agentId) as Record<string, unknown>;
  }

  private async generateTemplate(
    orchestrator: LlmOrchestrator,
    tenantId: string,
    agentId: string,
    task: string,
  ): Promise<Record<string, unknown>> {
    const response = await orchestrator.chat({
      tenantId,
      purpose: 'agent',
      riskLevel: 'medium',
      messages: [
        {
          role: 'system',
          content: `${TEMPLATE_PROMPT}\nTask: ${task}`,
        },
      ],
      jsonMode: true,
    });

    try {
      const parsed = JSON.parse(response.content ?? '{}');
      const template = parsed.template ?? parsed;
      this.templates.set(agentId, template);
      return template;
    } catch (error) {
      logger.warn({ event: 'template_generation_failed', agentId }, 'Falling back to default template');
      return { ...DEFAULT_TEMPLATE };
    }
  }

  async updateAgentMemory(params: UpdateAgentMemoryParams & { task: string }): Promise<Record<string, unknown>> {
    const previousMemory = params.previousMemory ?? this.getMemory(params.agentId);
    let template = this.templates.get(params.agentId);
    if (!template && params.enableDynamicTemplate) {
      template = await this.generateTemplate(
        params.orchestrator,
        params.tenantId,
        params.agentId,
        params.task,
      );
    }

    const baseMemory = template ? { ...template, ...previousMemory } : previousMemory;
    const instruction = MEMORY_UPDATE_INSTRUCTION.replace('[ROLE]', params.agentRole)
      .replace('[MEMORY CONTENT]', JSON.stringify(baseMemory))
      .replace('[AGENT OUTPUT]', params.agentOutput);

    const response = await params.orchestrator.chat({
      tenantId: params.tenantId,
      purpose: 'agent',
      riskLevel: 'medium',
      messages: [
        {
          role: 'system',
          content: instruction,
        },
      ],
      jsonMode: true,
    });

    const beforeBytes = Buffer.byteLength(JSON.stringify(previousMemory));
    try {
      const updated = JSON.parse(response.content ?? '{}');
      this.memories.set(params.agentId, updated);
      logger.info(
        {
          event: 'memory_update_attempt',
          agentId: params.agentId,
          ok: true,
          bytesBefore: beforeBytes,
          bytesAfter: Buffer.byteLength(JSON.stringify(updated)),
        },
        'Agent memory updated',
      );
      return updated;
    } catch (error) {
      logger.warn(
        {
          event: 'memory_update_attempt',
          agentId: params.agentId,
          ok: false,
          bytesBefore: beforeBytes,
        },
        'Agent memory update failed, preserving previous memory',
      );
      this.memories.set(params.agentId, previousMemory);
      return previousMemory;
    }
  }
}

export const defaultTemplate = DEFAULT_TEMPLATE;
