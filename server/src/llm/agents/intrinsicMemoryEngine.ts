import { logger } from '../../config/logger.js';
import type { ChatMessage, LlmOrchestrator } from '../types.js';

type TokenEstimator = (text: string) => number;

export interface ConstructContextParams {
  task: string;
  agentId: string;
  conversationHistory: ChatMessage[];
  agentMemory: Record<string, unknown>;
  tokenBudget: number;
  estimateTokens?: TokenEstimator;
}

export interface UpdateAgentMemoryParams {
  agentId: string;
  agentRole: string;
  tenantId: string;
  orchestrator: LlmOrchestrator;
  previousMemory: Record<string, unknown>;
  agentOutput: string;
  enableDynamicTemplate?: boolean;
}

const DEFAULT_TEMPLATE = {
  task_summary: '',
  agent_role_focus: '',
  global_strategies: [] as string[],
  key_requirements: [] as string[],
  constraints: [] as string[],
  assumptions: [] as string[],
  decisions: [] as Array<{ decision: string; rationale: string; date: string }>,
  open_questions: [] as string[],
  risks: [] as Array<{ risk: string; mitigation: string }>,
  useful_artifacts: [] as Array<{ type: string; path_or_link: string; notes: string }>,
  next_actions: [] as string[],
  glossary: {} as Record<string, string>,
};

const TEMPLATE_PROMPT =
  'You are designing an intrinsic memory template for an autonomous agent. ' +
  'For the provided task description, return concise update instructions and a JSON memory template tailored to the task. ' +
  'Respond with ONLY JSON containing {"update_instructions": [...], "template": { ... }} suitable for tracking the task.';

const MEMORY_UPDATE_INSTRUCTION =
  'You are maintaining the memory of an agent working as [ROLE] in a multi-agent conversation.\n' +
  'Use the old memory and the newest output by the agent to populate and update the current memory json with factual information.\n' +
  'For context, old memory content:\n[MEMORY CONTENT]\nCurrent content generated by the agent:\n[AGENT OUTPUT]\n' +
  'Update the memory content to incorporate new information while preserving key historical context.\n' +
  'The updated content should be concise and focus on information relevant to both the old memory and the newly generated output.\n' +
  'Respond with ONLY updated JSON.';

function defaultTokenEstimator(text: string): number {
  if (!text) {
    return 0;
  }
  return Math.ceil(text.length / 4);
}

function cloneDefaultTemplate(): Record<string, unknown> {
  return JSON.parse(JSON.stringify(DEFAULT_TEMPLATE));
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}

export class IntrinsicMemoryEngine {
  private readonly memories = new Map<string, Record<string, unknown>>();
  private readonly templates = new Map<string, Record<string, unknown>>();

  constructContext(params: ConstructContextParams): ChatMessage[] {
    const estimate = params.estimateTokens ?? defaultTokenEstimator;
    const context: ChatMessage[] = [];
    const systemMessages = params.conversationHistory.filter((message) => message.role === 'system');
    systemMessages.forEach((message) => context.push(message));

    const taskIndex = params.conversationHistory.findIndex(
      (message) => message.role === 'user' && message.content === params.task,
    );
    const taskMessage =
      params.conversationHistory[taskIndex] ?? { role: 'user', content: params.task };
    context.push(taskMessage);

    const memoryContent = params.agentMemory ?? {};
    const memoryString = JSON.stringify(memoryContent);
    const memoryMessage = `Agent memory: ${memoryString}`;
    context.push({ role: 'system', content: memoryMessage });

    let used =
      systemMessages.reduce((sum, message) => sum + estimate(message.content ?? ''), 0) +
      estimate(taskMessage.content ?? '') +
      estimate(memoryMessage);
    const history = params.conversationHistory.filter(
      (message, index) => message.role !== 'system' && index !== taskIndex,
    );
    const reversed = [...history].reverse();
    const selected: ChatMessage[] = [];
    for (const turn of reversed) {
      const tokens = estimate(turn.content ?? '');
      if (used + tokens > params.tokenBudget) {
        break;
      }
      selected.push(turn);
      used += tokens;
    }
    selected.reverse().forEach((turn) => context.push(turn));

    logger.info(
      {
        event: 'context_constructed',
        agentId: params.agentId,
        turnsIncluded: selected.length,
        approxTokens: used,
      },
      'Intrinsic memory context constructed',
    );

    return context;
  }

  getMemory(agentId: string): Record<string, unknown> {
    if (!this.memories.has(agentId)) {
      this.memories.set(agentId, cloneDefaultTemplate());
    }
    return this.memories.get(agentId) as Record<string, unknown>;
  }

  private async generateTemplate(
    orchestrator: LlmOrchestrator,
    tenantId: string,
    agentId: string,
    task: string,
  ): Promise<Record<string, unknown>> {
    const response = await orchestrator.chat({
      tenantId,
      purpose: 'agent',
      riskLevel: 'medium',
      messages: [
        {
          role: 'system',
          content: `${TEMPLATE_PROMPT}\nTask: ${task}`,
        },
      ],
      jsonMode: true,
    });

    try {
      const parsed = JSON.parse(response.content ?? '{}');
      const templateCandidate = parsed.template ?? parsed;
      if (isRecord(templateCandidate)) {
        this.templates.set(agentId, templateCandidate);
        return templateCandidate;
      }
      throw new Error('Template JSON must be an object');
    } catch (error) {
      logger.warn({ event: 'template_generation_failed', agentId }, 'Falling back to default template');
      return cloneDefaultTemplate();
    }
  }

  async updateAgentMemory(params: UpdateAgentMemoryParams & { task: string }): Promise<Record<string, unknown>> {
    const previousMemory = params.previousMemory ?? this.getMemory(params.agentId);
    let template = this.templates.get(params.agentId);
    if (!template && params.enableDynamicTemplate) {
      template = await this.generateTemplate(
        params.orchestrator,
        params.tenantId,
        params.agentId,
        params.task,
      );
    }

    const baseMemory = template ? { ...template, ...previousMemory } : previousMemory;
    const instruction = MEMORY_UPDATE_INSTRUCTION.replace('[ROLE]', params.agentRole)
      .replace('[MEMORY CONTENT]', JSON.stringify(baseMemory))
      .replace('[AGENT OUTPUT]', params.agentOutput);

    const response = await params.orchestrator.chat({
      tenantId: params.tenantId,
      purpose: 'agent',
      riskLevel: 'medium',
      messages: [
        {
          role: 'system',
          content: instruction,
        },
      ],
      jsonMode: true,
    });

    const beforeBytes = Buffer.byteLength(JSON.stringify(previousMemory));
    try {
      const parsed = JSON.parse(response.content ?? '{}');
      if (!isRecord(parsed)) {
        throw new Error('Memory JSON must be an object');
      }
      this.memories.set(params.agentId, parsed);
      logger.info(
        {
          event: 'memory_update_attempt',
          agentId: params.agentId,
          ok: true,
          bytesBefore: beforeBytes,
          bytesAfter: Buffer.byteLength(JSON.stringify(parsed)),
        },
        'Agent memory updated',
      );
      return parsed;
    } catch (error) {
      logger.warn(
        {
          event: 'memory_update_attempt',
          agentId: params.agentId,
          ok: false,
          bytesBefore: beforeBytes,
        },
        'Agent memory update failed, preserving previous memory',
      );
      this.memories.set(params.agentId, previousMemory);
      return previousMemory;
    }
  }
}

export const defaultTemplate = DEFAULT_TEMPLATE;
