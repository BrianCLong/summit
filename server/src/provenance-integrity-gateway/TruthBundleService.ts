/**
 * Truth Bundle Service
 *
 * Generates tamper-evident response packets for impersonation and deepfake incidents.
 * Creates comprehensive bundles containing:
 * - Original signed asset
 * - Diff highlights
 * - Distribution map
 * - Recommended communications response
 */

import * as crypto from 'crypto';
import { promises as fs } from 'fs';
import * as path from 'path';
import { EventEmitter } from 'events';
import { Counter, Histogram } from 'prom-client';
import pino from 'pino';
import { pool } from '../db/pg.js';
import { provenanceLedger } from '../provenance/ledger.js';
import { CryptoPipeline, createDefaultCryptoPipeline } from '../security/crypto/pipeline.js';
import type { SignatureBundle } from '../security/crypto/types.js';
import { contentSigningService, type ContentSigningService } from './ContentSigningService.js';
import { deepfakeDetectionService, type DeepfakeDetectionService } from './DeepfakeDetectionService.js';
import type {
  TruthBundle,
  TruthBundleIncident,
  SignedAsset,
  FraudulentContentRecord,
  DiffHighlight,
  TimelineEvent,
  DistributionMapEntry,
  ResponseRecommendation,
  RecommendedAction,
  ExternalReference,
  GenerateTruthBundleRequest,
  GenerateTruthBundleResponse,
  DeepfakeDetectionResult,
  ImpersonationDetectionResult,
  TamperingResult,
  OfficialAssetMatch,
} from './types.js';

const logger = (pino as any)({ name: 'TruthBundleService' });

// =============================================================================
// Metrics
// =============================================================================

const bundlesGeneratedTotal = new Counter({
  name: 'pig_truth_bundles_generated_total',
  help: 'Total truth bundles generated',
  labelNames: ['tenant_id', 'incident_type', 'severity'],
});

const bundleGenerationDuration = new Histogram({
  name: 'pig_truth_bundle_generation_duration_seconds',
  help: 'Duration of truth bundle generation',
  buckets: [0.5, 1, 2.5, 5, 10, 30, 60],
  labelNames: ['incident_type'],
});

// =============================================================================
// Configuration
// =============================================================================

export interface TruthBundleServiceConfig {
  /** Storage path for bundles */
  storagePath: string;

  /** Key ID for bundle signing */
  signingKeyId: string;

  /** Include detailed forensic analysis */
  includeForensicDetails: boolean;

  /** Auto-generate distribution map */
  autoGenerateDistributionMap: boolean;

  /** External monitoring platforms for distribution tracking */
  monitoringPlatforms: MonitoringPlatform[];

  /** Response template library path */
  responseTemplatesPath?: string;

  /** Legal template library path */
  legalTemplatesPath?: string;
}

interface MonitoringPlatform {
  name: string;
  apiEndpoint?: string;
  apiKey?: string;
  enabled: boolean;
}

export const defaultTruthBundleConfig: TruthBundleServiceConfig = {
  storagePath: '/data/truth-bundles',
  signingKeyId: 'truth-bundle-signing',
  includeForensicDetails: true,
  autoGenerateDistributionMap: true,
  monitoringPlatforms: [],
  responseTemplatesPath: undefined,
  legalTemplatesPath: undefined,
};

// =============================================================================
// Truth Bundle Service
// =============================================================================

export class TruthBundleService extends EventEmitter {
  private config: TruthBundleServiceConfig;
  private cryptoPipeline?: CryptoPipeline;
  private contentSigningService: ContentSigningService;
  private deepfakeService: DeepfakeDetectionService;
  private initialized = false;

  constructor(
    config: Partial<TruthBundleServiceConfig> = {},
    contentSigning?: ContentSigningService,
    deepfake?: DeepfakeDetectionService
  ) {
    super();
    this.config = { ...defaultTruthBundleConfig, ...config };
    this.contentSigningService = contentSigning || contentSigningService;
    this.deepfakeService = deepfake || deepfakeDetectionService;
  }

  /**
   * Initialize the service
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      // Initialize crypto pipeline
      this.cryptoPipeline = await createDefaultCryptoPipeline({
        timestampingEndpointEnv: 'TRUTH_BUNDLE_TSA_ENDPOINT',
        auditSubsystem: 'truth-bundle',
        trustAnchorsEnv: 'TRUTH_BUNDLE_TRUST_ANCHORS',
      }) || undefined;

      // Ensure storage directory exists
      await fs.mkdir(this.config.storagePath, { recursive: true });

      // Initialize dependent services
      await this.contentSigningService.initialize();
      await this.deepfakeService.initialize();

      this.initialized = true;
      logger.info('TruthBundleService initialized');
    } catch (error: any) {
      logger.error({ error }, 'Failed to initialize TruthBundleService');
      throw error;
    }
  }

  /**
   * Generate a truth bundle for an incident
   */
  async generateTruthBundle(
    request: GenerateTruthBundleRequest,
    tenantId: string,
    userId: string
  ): Promise<GenerateTruthBundleResponse> {
    await this.ensureInitialized();
    const startTime = Date.now();

    logger.info({
      originalAssetId: request.originalAssetId,
      incidentType: request.incidentType,
      tenantId,
    }, 'Generating truth bundle');

    try {
      // Get the original signed asset
      const originalAsset = await this.contentSigningService.getAsset(
        request.originalAssetId,
        tenantId
      );

      if (!originalAsset) {
        throw new Error(`Original asset not found: ${request.originalAssetId}`);
      }

      // Process fraudulent content
      const fraudulentBuffer = await this.getContentBuffer(request.fraudulentContent);
      const fraudulentHash = crypto.createHash('sha256').update(fraudulentBuffer).digest('hex');

      // Store fraudulent content as evidence
      const evidenceUri = await this.storeEvidence(
        fraudulentBuffer,
        tenantId,
        fraudulentHash
      );

      // Run analysis on fraudulent content
      const analysisResults = await this.analyzeContent(
        fraudulentBuffer,
        originalAsset,
        tenantId
      );

      // Generate incident record
      const incident = await this.createIncidentRecord(
        request,
        fraudulentHash
      );

      // Create fraudulent content record
      const fraudulentContentRecord = await this.createFraudulentContentRecord(
        fraudulentBuffer,
        fraudulentHash,
        evidenceUri,
        request.fraudulentContentUrl,
        analysisResults
      );

      // Generate diff highlights
      const diffHighlights = await this.generateDiffHighlights(
        originalAsset,
        fraudulentBuffer,
        analysisResults
      );

      // Build timeline
      const timeline = await this.buildTimeline(
        originalAsset,
        incident,
        fraudulentContentRecord
      );

      // Generate distribution map
      const distributionMap = this.config.autoGenerateDistributionMap
        ? await this.generateDistributionMap(
          fraudulentHash,
          request.fraudulentContentUrl,
          tenantId
        )
        : [];

      // Generate response recommendations
      const recommendedResponse = request.generateRecommendations !== false
        ? await this.generateResponseRecommendations(
          incident,
          analysisResults,
          distributionMap
        )
        : this.getDefaultRecommendations(incident.severity);

      // Generate bundle ID
      const bundleId = `tb_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;

      // Sign the bundle
      const bundleData = {
        id: bundleId,
        tenantId,
        incident,
        originalAssetId: originalAsset.id,
        fraudulentContentHash: fraudulentHash,
        diffHighlightsCount: diffHighlights.length,
        distributionMapCount: distributionMap.length,
        createdAt: new Date().toISOString(),
      };

      const signature = await this.signBundle(bundleData);

      // Create the truth bundle
      const bundle: TruthBundle = {
        id: bundleId,
        tenantId,
        createdAt: new Date(),
        createdBy: userId,
        incident,
        originalAsset,
        fraudulentContent: fraudulentContentRecord,
        diffHighlights,
        timeline,
        distributionMap,
        recommendedResponse,
        signature,
        status: 'draft',
      };

      // Store the bundle
      await this.storeBundle(bundle);

      // Record in provenance ledger
      await provenanceLedger.appendEntry({
        tenantId,
        timestamp: new Date(),
        actionType: 'TRUTH_BUNDLE_GENERATED',
        resourceType: 'TruthBundle',
        resourceId: bundleId,
        actorId: userId,
        actorType: 'user',
        payload: {
          mutationType: 'CREATE',
          entityId: bundleId,
          entityType: 'TruthBundle',
          newState: {
            id: bundleId,
            type: 'TruthBundle',
            version: 1,
            data: {
              incidentType: incident.type,
              severity: incident.severity,
              originalAssetId: originalAsset.id,
            },
            metadata: {},
          },
        },
        metadata: {
          purpose: 'incident-response',
          incidentId: incident.id,
        },
      });

      // Update metrics
      bundlesGeneratedTotal.inc({
        tenant_id: tenantId,
        incident_type: incident.type,
        severity: incident.severity,
      });

      bundleGenerationDuration.observe(
        { incident_type: incident.type },
        (Date.now() - startTime) / 1000
      );

      this.emit('truthbundle:generated', { bundle });

      logger.info({
        bundleId,
        incidentType: incident.type,
        severity: incident.severity,
        duration: Date.now() - startTime,
      }, 'Truth bundle generated');

      return {
        bundle,
        analysisResults,
      };
    } catch (error: any) {
      logger.error({ error }, 'Failed to generate truth bundle');
      throw error;
    }
  }

  /**
   * Get a truth bundle by ID
   */
  async getBundle(bundleId: string, tenantId: string): Promise<TruthBundle | null> {
    await this.ensureInitialized();

    const result = await pool.query(
      `SELECT * FROM truth_bundles WHERE id = $1 AND tenant_id = $2`,
      [bundleId, tenantId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return this.mapRowToBundle(result.rows[0]);
  }

  /**
   * List truth bundles for a tenant
   */
  async listBundles(
    tenantId: string,
    options: {
      status?: TruthBundle['status'][];
      incidentType?: TruthBundleIncident['type'][];
      severity?: TruthBundleIncident['severity'][];
      limit?: number;
      offset?: number;
    } = {}
  ): Promise<{ bundles: TruthBundle[]; total: number }> {
    await this.ensureInitialized();

    const conditions: string[] = ['tenant_id = $1'];
    const params: any[] = [tenantId];
    let paramIndex = 2;

    if (options.status && options.status.length > 0) {
      conditions.push(`status = ANY($${paramIndex})`);
      params.push(options.status);
      paramIndex++;
    }

    if (options.incidentType && options.incidentType.length > 0) {
      conditions.push(`incident->>'type' = ANY($${paramIndex})`);
      params.push(options.incidentType);
      paramIndex++;
    }

    if (options.severity && options.severity.length > 0) {
      conditions.push(`incident->>'severity' = ANY($${paramIndex})`);
      params.push(options.severity);
      paramIndex++;
    }

    const limit = options.limit || 50;
    const offset = options.offset || 0;

    const countResult = await pool.query(
      `SELECT COUNT(*) FROM truth_bundles WHERE ${conditions.join(' AND ')}`,
      params
    );

    const dataResult = await pool.query(
      `SELECT * FROM truth_bundles
       WHERE ${conditions.join(' AND ')}
       ORDER BY created_at DESC
       LIMIT ${limit} OFFSET ${offset}`,
      params
    );

    return {
      bundles: dataResult.rows.map((row: any) => this.mapRowToBundle(row)),
      total: parseInt(countResult.rows[0].count),
    };
  }

  /**
   * Publish a truth bundle
   */
  async publishBundle(
    bundleId: string,
    tenantId: string,
    userId: string
  ): Promise<TruthBundle> {
    await this.ensureInitialized();

    const bundle = await this.getBundle(bundleId, tenantId);

    if (!bundle) {
      throw new Error(`Bundle not found: ${bundleId}`);
    }

    if (bundle.status === 'published') {
      throw new Error('Bundle is already published');
    }

    // Update status
    const updatedBundle: TruthBundle = {
      ...bundle,
      status: 'published',
    };

    await this.updateBundle(updatedBundle);

    // Record in provenance ledger
    await provenanceLedger.appendEntry({
      tenantId,
      timestamp: new Date(),
      actionType: 'TRUTH_BUNDLE_PUBLISHED',
      resourceType: 'TruthBundle',
      resourceId: bundleId,
      actorId: userId,
      actorType: 'user',
      payload: {
        mutationType: 'UPDATE',
        entityId: bundleId,
        entityType: 'TruthBundle',
        previousState: {
          id: bundle.id,
          type: 'TruthBundle',
          version: 1,
          data: { status: bundle.status },
          metadata: {},
        },
        newState: {
          id: updatedBundle.id,
          type: 'TruthBundle',
          version: 1,
          data: { status: 'published' },
          metadata: {},
        },
      },
      metadata: {
        purpose: 'truth-bundle-publication',
      },
    });

    return updatedBundle;
  }

  /**
   * Update distribution map for a bundle
   */
  async updateDistributionMap(
    bundleId: string,
    entries: DistributionMapEntry[],
    tenantId: string,
    userId: string
  ): Promise<TruthBundle> {
    await this.ensureInitialized();

    const bundle = await this.getBundle(bundleId, tenantId);

    if (!bundle) {
      throw new Error(`Bundle not found: ${bundleId}`);
    }

    const updatedBundle: TruthBundle = {
      ...bundle,
      distributionMap: [...bundle.distributionMap, ...entries],
    };

    await this.updateBundle(updatedBundle);

    // Add timeline event
    updatedBundle.timeline.push({
      timestamp: new Date(),
      type: 'distribution_map_updated',
      description: `Added ${entries.length} distribution map entries`,
      source: 'system',
      data: { entriesAdded: entries.length },
    });

    await this.updateBundle(updatedBundle);

    return updatedBundle;
  }

  /**
   * Add external reference to bundle
   */
  async addExternalReference(
    bundleId: string,
    reference: ExternalReference,
    tenantId: string,
    userId: string
  ): Promise<TruthBundle> {
    await this.ensureInitialized();

    const bundle = await this.getBundle(bundleId, tenantId);

    if (!bundle) {
      throw new Error(`Bundle not found: ${bundleId}`);
    }

    const updatedBundle: TruthBundle = {
      ...bundle,
      externalReferences: [...(bundle.externalReferences || []), reference],
    };

    await this.updateBundle(updatedBundle);

    return updatedBundle;
  }

  /**
   * Export bundle as PDF or JSON
   */
  async exportBundle(
    bundleId: string,
    tenantId: string,
    format: 'pdf' | 'json' | 'html'
  ): Promise<Buffer> {
    await this.ensureInitialized();

    const bundle = await this.getBundle(bundleId, tenantId);

    if (!bundle) {
      throw new Error(`Bundle not found: ${bundleId}`);
    }

    switch (format) {
      case 'json':
        return Buffer.from(JSON.stringify(bundle, null, 2));

      case 'html':
        return this.generateHTMLExport(bundle);

      case 'pdf':
        return this.generatePDFExport(bundle);

      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  // ===========================================================================
  // Private Methods
  // ===========================================================================

  /**
   * Analyze fraudulent content
   */
  private async analyzeContent(
    content: Buffer,
    originalAsset: SignedAsset,
    tenantId: string
  ): Promise<{
    deepfake?: DeepfakeDetectionResult;
    impersonation?: ImpersonationDetectionResult;
    tampering?: TamperingResult;
    officialMatch?: OfficialAssetMatch;
  }> {
    const results: {
      deepfake?: DeepfakeDetectionResult;
      impersonation?: ImpersonationDetectionResult;
      tampering?: TamperingResult;
      officialMatch?: OfficialAssetMatch;
    } = {};

    // Run deepfake detection
    results.deepfake = await this.deepfakeService.detectDeepfake(
      content,
      originalAsset.mimeType,
      'fraudulent-content',
      tenantId
    );

    // Run impersonation detection
    results.impersonation = await this.deepfakeService.detectImpersonation(
      {
        content,
        filename: 'fraudulent-content',
        mimeType: originalAsset.mimeType,
      },
      tenantId
    );

    // Match against official assets
    results.officialMatch = await this.deepfakeService.matchOfficialAsset(
      content,
      originalAsset.mimeType,
      tenantId
    );

    return results;
  }

  /**
   * Create incident record
   */
  private async createIncidentRecord(
    request: GenerateTruthBundleRequest,
    fraudulentHash: string
  ): Promise<TruthBundleIncident> {
    return {
      id: `inc_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`,
      type: request.incidentType,
      discoveredAt: new Date(),
      discoveryMethod: 'manual_submission',
      severity: request.severity,
      impactAssessment: request.context,
    };
  }

  /**
   * Create fraudulent content record
   */
  private async createFraudulentContentRecord(
    content: Buffer,
    contentHash: string,
    storageUri: string,
    firstSeenUrl: string | undefined,
    analysisResults: any
  ): Promise<FraudulentContentRecord> {
    // Extract metadata from content
    const metadata = await this.extractMetadata(content);

    return {
      contentHash,
      storageUri,
      firstSeenAt: new Date(),
      firstSeenLocation: firstSeenUrl || 'direct_submission',
      mimeType: metadata.mimeType || 'application/octet-stream',
      fileSize: content.length,
      metadata,
      detectionResults: {
        deepfake: analysisResults.deepfake,
        impersonation: analysisResults.impersonation,
        tampering: analysisResults.tampering,
      },
    };
  }

  /**
   * Generate diff highlights between original and fraudulent content
   */
  private async generateDiffHighlights(
    originalAsset: SignedAsset,
    fraudulentContent: Buffer,
    analysisResults: any
  ): Promise<DiffHighlight[]> {
    const highlights: DiffHighlight[] = [];

    // Add deepfake indicators as diff highlights
    if (analysisResults.deepfake?.indicators) {
      for (const indicator of analysisResults.deepfake.indicators) {
        highlights.push({
          type: indicator.type === 'audio_mismatch' ? 'audio' : 'visual',
          description: indicator.description,
          region: indicator.region,
          severity: this.mapConfidenceToSeverity(indicator.confidence),
          technicalDetails: {
            indicatorType: indicator.type,
            confidence: indicator.confidence,
          },
        });
      }
    }

    // Add impersonation findings as diff highlights
    if (analysisResults.impersonation?.findings) {
      for (const finding of analysisResults.impersonation.findings) {
        highlights.push({
          type: finding.type === 'voice' ? 'audio' : 'visual',
          description: finding.description,
          region: finding.region,
          severity: this.mapConfidenceToSeverity(finding.confidence),
          technicalDetails: finding.evidence,
        });
      }
    }

    // Add official asset match differences
    if (analysisResults.officialMatch?.differences) {
      for (const diff of analysisResults.officialMatch.differences) {
        highlights.push({
          type: diff.type === 'content' ? 'visual' : diff.type,
          description: diff.description,
          region: diff.region,
          severity: diff.severity,
        });
      }
    }

    return highlights;
  }

  /**
   * Build incident timeline
   */
  private async buildTimeline(
    originalAsset: SignedAsset,
    incident: TruthBundleIncident,
    fraudulentContent: FraudulentContentRecord
  ): Promise<TimelineEvent[]> {
    const events: TimelineEvent[] = [];

    // Original asset creation
    events.push({
      timestamp: originalAsset.createdAt,
      type: 'original_created',
      description: `Original asset "${originalAsset.title}" was created and signed`,
      source: 'system',
      data: {
        assetId: originalAsset.id,
        assetType: originalAsset.assetType,
      },
    });

    // Original asset publication (if applicable)
    if (originalAsset.status === 'published' && originalAsset.distributions) {
      for (const dist of originalAsset.distributions) {
        events.push({
          timestamp: dist.distributedAt,
          type: 'original_published',
          description: `Original asset published to ${dist.channel}`,
          source: 'system',
          data: {
            channel: dist.channel,
            url: dist.url,
          },
        });
      }
    }

    // Fraudulent content first seen
    events.push({
      timestamp: fraudulentContent.firstSeenAt,
      type: 'fraudulent_discovered',
      description: `Fraudulent content first discovered at ${fraudulentContent.firstSeenLocation}`,
      source: 'detection',
      data: {
        location: fraudulentContent.firstSeenLocation,
        contentHash: fraudulentContent.contentHash,
      },
    });

    // Incident created
    events.push({
      timestamp: incident.discoveredAt,
      type: 'incident_created',
      description: `${incident.type} incident created with ${incident.severity} severity`,
      source: 'system',
      data: {
        incidentId: incident.id,
        severity: incident.severity,
      },
    });

    // Sort by timestamp
    events.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

    return events;
  }

  /**
   * Generate distribution map
   */
  private async generateDistributionMap(
    contentHash: string,
    knownUrl: string | undefined,
    tenantId: string
  ): Promise<DistributionMapEntry[]> {
    const entries: DistributionMapEntry[] = [];

    // Add known URL if provided
    if (knownUrl) {
      const platform = this.detectPlatform(knownUrl);
      entries.push({
        platform,
        url: knownUrl,
        firstObserved: new Date(),
        lastObserved: new Date(),
        status: 'active',
      });
    }

    // Query external monitoring platforms (if configured)
    for (const platform of this.config.monitoringPlatforms) {
      if (!platform.enabled || !platform.apiEndpoint) continue;

      try {
        const platformEntries = await this.queryMonitoringPlatform(
          platform,
          contentHash,
          tenantId
        );
        entries.push(...platformEntries);
      } catch (error: any) {
        logger.warn({ error, platform: platform.name }, 'Failed to query monitoring platform');
      }
    }

    return entries;
  }

  /**
   * Generate response recommendations
   */
  private async generateResponseRecommendations(
    incident: TruthBundleIncident,
    analysisResults: any,
    distributionMap: DistributionMapEntry[]
  ): Promise<ResponseRecommendation> {
    const actions: RecommendedAction[] = [];
    let priority = 1;

    // Urgency based on severity
    const urgency = this.mapSeverityToUrgency(incident.severity);

    // Technical actions
    if (distributionMap.some(d => d.status === 'active')) {
      actions.push({
        priority: priority++,
        action: 'Submit takedown requests to platforms hosting the fraudulent content',
        category: 'technical',
        suggestedTimeline: urgency === 'emergency' ? 'Immediately' : 'Within 24 hours',
      });
    }

    // Communications actions
    actions.push({
      priority: priority++,
      action: 'Prepare internal briefing for executives and communications team',
      category: 'communications',
      suggestedTimeline: urgency === 'emergency' ? 'Within 1 hour' : 'Within 4 hours',
    });

    if (incident.severity === 'high' || incident.severity === 'critical') {
      actions.push({
        priority: priority++,
        action: 'Draft public statement clarifying the authentic content',
        category: 'communications',
        suggestedTimeline: 'Within 4 hours',
      });
    }

    // Legal actions
    if (analysisResults.impersonation?.impersonationDetected) {
      actions.push({
        priority: priority++,
        action: 'Consult legal team regarding potential trademark/identity violations',
        category: 'legal',
        suggestedTimeline: 'Within 24 hours',
      });
    }

    // Executive actions for critical incidents
    if (incident.severity === 'critical') {
      actions.push({
        priority: priority++,
        action: 'Brief executive leadership on incident and response plan',
        category: 'executive',
        suggestedTimeline: 'Within 2 hours',
      });
    }

    // Generate statement templates
    const statementTemplate = this.generateStatementTemplate(incident, analysisResults);
    const socialMediaResponse = this.generateSocialMediaResponse(incident);
    const pressStatement = incident.severity === 'critical'
      ? this.generatePressStatement(incident, analysisResults)
      : undefined;

    // Legal considerations
    const legalConsiderations = this.generateLegalConsiderations(incident, analysisResults);

    // Stakeholders to notify
    const stakeholdersToNotify = this.identifyStakeholders(incident);

    return {
      urgency,
      actions,
      statementTemplate,
      socialMediaResponse,
      pressStatement,
      legalConsiderations,
      stakeholdersToNotify,
    };
  }

  /**
   * Store evidence file
   */
  private async storeEvidence(
    content: Buffer,
    tenantId: string,
    contentHash: string
  ): Promise<string> {
    const evidenceDir = path.join(this.config.storagePath, tenantId, 'evidence');
    await fs.mkdir(evidenceDir, { recursive: true });

    const evidencePath = path.join(evidenceDir, `${contentHash}`);
    await fs.writeFile(evidencePath, content);

    return evidencePath;
  }

  /**
   * Sign bundle data
   */
  private async signBundle(bundleData: any): Promise<SignatureBundle> {
    const dataString = JSON.stringify(bundleData);
    const hash = crypto.createHash('sha256').update(dataString).digest('hex');

    if (this.cryptoPipeline) {
      return this.cryptoPipeline.signPayload(
        Buffer.from(hash),
        this.config.signingKeyId,
        {
          includeTimestamp: true,
          metadata: {
            purpose: 'truth-bundle-signing',
            bundleId: bundleData.id,
          },
        }
      );
    }

    // Fallback signature
    const hmac = crypto.createHmac('sha256', process.env.TRUTH_BUNDLE_SECRET || 'default-secret');
    hmac.update(dataString);

    return {
      keyId: this.config.signingKeyId,
      keyVersion: 1,
      algorithm: 'HMAC_SHA256' as any,
      signature: hmac.digest('base64'),
    };
  }

  /**
   * Store bundle in database
   */
  private async storeBundle(bundle: TruthBundle): Promise<void> {
    await pool.query(
      `INSERT INTO truth_bundles (
        id, tenant_id, created_at, created_by, incident,
        original_asset_id, fraudulent_content, diff_highlights,
        timeline, distribution_map, recommended_response,
        signature, status, external_references
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`,
      [
        bundle.id,
        bundle.tenantId,
        bundle.createdAt,
        bundle.createdBy,
        JSON.stringify(bundle.incident),
        bundle.originalAsset.id,
        JSON.stringify(bundle.fraudulentContent),
        JSON.stringify(bundle.diffHighlights),
        JSON.stringify(bundle.timeline),
        JSON.stringify(bundle.distributionMap),
        JSON.stringify(bundle.recommendedResponse),
        JSON.stringify(bundle.signature),
        bundle.status,
        bundle.externalReferences ? JSON.stringify(bundle.externalReferences) : null,
      ]
    );
  }

  /**
   * Update bundle in database
   */
  private async updateBundle(bundle: TruthBundle): Promise<void> {
    await pool.query(
      `UPDATE truth_bundles SET
        diff_highlights = $3,
        timeline = $4,
        distribution_map = $5,
        recommended_response = $6,
        status = $7,
        external_references = $8
      WHERE id = $1 AND tenant_id = $2`,
      [
        bundle.id,
        bundle.tenantId,
        JSON.stringify(bundle.diffHighlights),
        JSON.stringify(bundle.timeline),
        JSON.stringify(bundle.distributionMap),
        JSON.stringify(bundle.recommendedResponse),
        bundle.status,
        bundle.externalReferences ? JSON.stringify(bundle.externalReferences) : null,
      ]
    );
  }

  /**
   * Map database row to TruthBundle
   */
  private mapRowToBundle(row: any): TruthBundle {
    return {
      id: row.id,
      tenantId: row.tenant_id,
      createdAt: row.created_at,
      createdBy: row.created_by,
      incident: this.parseJSON(row.incident),
      originalAsset: row.original_asset, // Would need to join or populate
      fraudulentContent: this.parseJSON(row.fraudulent_content),
      diffHighlights: this.parseJSON(row.diff_highlights),
      timeline: this.parseJSON(row.timeline),
      distributionMap: this.parseJSON(row.distribution_map),
      recommendedResponse: this.parseJSON(row.recommended_response),
      signature: this.parseJSON(row.signature),
      status: row.status,
      externalReferences: row.external_references
        ? this.parseJSON(row.external_references)
        : undefined,
    };
  }

  /**
   * Parse JSON safely
   */
  private parseJSON(value: any): any {
    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }

  /**
   * Get content as buffer
   */
  private async getContentBuffer(content: string | Buffer): Promise<Buffer> {
    if (Buffer.isBuffer(content)) {
      return content;
    }
    return fs.readFile(content);
  }

  /**
   * Extract metadata from content
   */
  private async extractMetadata(content: Buffer): Promise<Record<string, any>> {
    // Would use appropriate libraries for different file types
    return {
      size: content.length,
      mimeType: 'application/octet-stream',
    };
  }

  /**
   * Detect platform from URL
   */
  private detectPlatform(url: string): string {
    const urlLower = url.toLowerCase();

    if (urlLower.includes('twitter.com') || urlLower.includes('x.com')) return 'Twitter/X';
    if (urlLower.includes('facebook.com') || urlLower.includes('fb.com')) return 'Facebook';
    if (urlLower.includes('instagram.com')) return 'Instagram';
    if (urlLower.includes('linkedin.com')) return 'LinkedIn';
    if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) return 'YouTube';
    if (urlLower.includes('tiktok.com')) return 'TikTok';
    if (urlLower.includes('telegram')) return 'Telegram';
    if (urlLower.includes('reddit.com')) return 'Reddit';

    return 'Unknown';
  }

  /**
   * Query external monitoring platform
   */
  private async queryMonitoringPlatform(
    platform: MonitoringPlatform,
    contentHash: string,
    tenantId: string
  ): Promise<DistributionMapEntry[]> {
    // Would integrate with external monitoring services
    return [];
  }

  /**
   * Map confidence to severity
   */
  private mapConfidenceToSeverity(confidence: number): 'minor' | 'moderate' | 'significant' | 'critical' {
    if (confidence >= 0.9) return 'critical';
    if (confidence >= 0.7) return 'significant';
    if (confidence >= 0.5) return 'moderate';
    return 'minor';
  }

  /**
   * Map severity to urgency
   */
  private mapSeverityToUrgency(
    severity: 'low' | 'medium' | 'high' | 'critical'
  ): 'routine' | 'priority' | 'urgent' | 'emergency' {
    switch (severity) {
      case 'critical':
        return 'emergency';
      case 'high':
        return 'urgent';
      case 'medium':
        return 'priority';
      default:
        return 'routine';
    }
  }

  /**
   * Generate statement template
   */
  private generateStatementTemplate(
    incident: TruthBundleIncident,
    analysisResults: any
  ): string {
    return `We are aware of ${incident.type === 'deepfake' ? 'a manipulated video/image' : 'content impersonating our organization'} that is being circulated online. This content is not authentic and does not represent our organization's official communications.

Our official statements and media are always published through verified channels and can be verified using our content authenticity system.

We take the security and authenticity of our communications seriously and are taking appropriate action to address this situation.

For authentic information, please refer to our official website and verified social media accounts.`;
  }

  /**
   * Generate social media response
   */
  private generateSocialMediaResponse(incident: TruthBundleIncident): string {
    return `IMPORTANT: We're aware of ${incident.type === 'deepfake' ? 'fake/manipulated content' : 'impersonation attempts'} falsely attributed to us. This content is NOT authentic. Our official content is always verifiable. Stay safe - only trust our verified channels.`;
  }

  /**
   * Generate press statement
   */
  private generatePressStatement(
    incident: TruthBundleIncident,
    analysisResults: any
  ): string {
    return `FOR IMMEDIATE RELEASE

[Organization Name] Statement Regarding Inauthentic Content

[City, Date] - [Organization Name] has become aware of ${incident.type === 'deepfake' ? 'artificially manipulated content' : 'content falsely attributed to our organization'} currently circulating online.

We can confirm that this content is not authentic and does not represent official communications from [Organization Name].

[Organization Name] employs industry-leading content authentication technology to ensure the integrity of our official communications. All authentic content from our organization can be verified through our content provenance system.

We are actively working with relevant platforms and authorities to address this situation.

Members of the press and public seeking to verify the authenticity of content attributed to [Organization Name] are encouraged to contact our communications team or use our verification portal.

###

Media Contact:
[Contact Information]`;
  }

  /**
   * Generate legal considerations
   */
  private generateLegalConsiderations(
    incident: TruthBundleIncident,
    analysisResults: any
  ): string[] {
    const considerations: string[] = [];

    if (analysisResults.impersonation?.impersonationDetected) {
      considerations.push('Potential trademark infringement if organizational branding is used');
      considerations.push('Consider filing DMCA takedown notices for infringing content');
    }

    if (incident.type === 'deepfake') {
      considerations.push('Review applicable deepfake legislation in relevant jurisdictions');
      considerations.push('Consider reporting to law enforcement if criminal intent is suspected');
    }

    if (incident.severity === 'critical') {
      considerations.push('Preserve all evidence for potential legal proceedings');
      considerations.push('Document all instances and distribution of the content');
    }

    considerations.push('Review terms of service violations on each platform');

    return considerations;
  }

  /**
   * Identify stakeholders to notify
   */
  private identifyStakeholders(incident: TruthBundleIncident): string[] {
    const stakeholders: string[] = [
      'Communications Team',
      'Legal Department',
      'Security Team',
    ];

    if (incident.severity === 'critical' || incident.severity === 'high') {
      stakeholders.push('Executive Leadership');
      stakeholders.push('Board of Directors (if applicable)');
    }

    if (incident.type === 'impersonation') {
      stakeholders.push('Brand/Marketing Team');
    }

    stakeholders.push('Relevant Business Units');

    return stakeholders;
  }

  /**
   * Get default recommendations
   */
  private getDefaultRecommendations(
    severity: 'low' | 'medium' | 'high' | 'critical'
  ): ResponseRecommendation {
    return {
      urgency: this.mapSeverityToUrgency(severity),
      actions: [
        {
          priority: 1,
          action: 'Review and assess the incident',
          category: 'technical',
        },
        {
          priority: 2,
          action: 'Document findings',
          category: 'technical',
        },
      ],
    };
  }

  /**
   * Generate HTML export
   */
  private async generateHTMLExport(bundle: TruthBundle): Promise<Buffer> {
    const html = `<!DOCTYPE html>
<html>
<head>
  <title>Truth Bundle: ${bundle.id}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; }
    h1 { color: #333; }
    .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; }
    .severity-critical { color: #dc3545; }
    .severity-high { color: #fd7e14; }
    .severity-medium { color: #ffc107; }
    .severity-low { color: #28a745; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
  </style>
</head>
<body>
  <h1>Truth Bundle Report</h1>
  <p><strong>Bundle ID:</strong> ${bundle.id}</p>
  <p><strong>Created:</strong> ${bundle.createdAt.toISOString()}</p>
  <p><strong>Status:</strong> ${bundle.status}</p>

  <div class="section">
    <h2>Incident Details</h2>
    <p><strong>Type:</strong> ${bundle.incident.type}</p>
    <p><strong>Severity:</strong> <span class="severity-${bundle.incident.severity}">${bundle.incident.severity}</span></p>
    <p><strong>Discovered:</strong> ${bundle.incident.discoveredAt}</p>
  </div>

  <div class="section">
    <h2>Original Asset</h2>
    <p><strong>Title:</strong> ${bundle.originalAsset.title}</p>
    <p><strong>Hash:</strong> ${bundle.originalAsset.contentHash}</p>
  </div>

  <div class="section">
    <h2>Fraudulent Content</h2>
    <p><strong>Hash:</strong> ${bundle.fraudulentContent.contentHash}</p>
    <p><strong>First Seen:</strong> ${bundle.fraudulentContent.firstSeenLocation}</p>
  </div>

  <div class="section">
    <h2>Differences Detected</h2>
    <table>
      <tr><th>Type</th><th>Description</th><th>Severity</th></tr>
      ${bundle.diffHighlights.map(d => `
        <tr>
          <td>${d.type}</td>
          <td>${d.description}</td>
          <td>${d.severity}</td>
        </tr>
      `).join('')}
    </table>
  </div>

  <div class="section">
    <h2>Distribution Map</h2>
    <table>
      <tr><th>Platform</th><th>URL</th><th>Status</th></tr>
      ${bundle.distributionMap.map(d => `
        <tr>
          <td>${d.platform}</td>
          <td><a href="${d.url}">${d.url}</a></td>
          <td>${d.status}</td>
        </tr>
      `).join('')}
    </table>
  </div>

  <div class="section">
    <h2>Recommended Actions</h2>
    <ol>
      ${bundle.recommendedResponse.actions.map(a => `
        <li><strong>[${a.category}]</strong> ${a.action}</li>
      `).join('')}
    </ol>
  </div>

  <footer>
    <p>Generated: ${new Date().toISOString()}</p>
    <p>Signature: ${bundle.signature.signature.substring(0, 32)}...</p>
  </footer>
</body>
</html>`;

    return Buffer.from(html);
  }

  /**
   * Generate PDF export
   */
  private async generatePDFExport(bundle: TruthBundle): Promise<Buffer> {
    // Would use a PDF library like PDFKit
    // For now, return HTML as a placeholder
    return this.generateHTMLExport(bundle);
  }

  /**
   * Ensure service is initialized
   */
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }

  /**
   * Cleanup resources
   */
  async cleanup(): Promise<void> {
    // Cleanup resources
  }
}

// Export default instance
export const truthBundleService = new TruthBundleService();
