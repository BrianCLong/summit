import { EvaluationHarness } from './harness.js';
import {
  EvaluationRequest,
  EvaluationReport,
  EvaluationCapability,
  EvaluationCapabilityType,
  ProhibitedActionType,
  EvaluationCapabilitySchema,
  EvaluationRequestSchema
} from './types.js';

export class AutonomousEvaluationService {
  private harness: EvaluationHarness;
  private capabilities: Map<string, EvaluationCapability>;

  constructor() {
    this.harness = new EvaluationHarness();
    this.capabilities = new Map();
    this.registerDefaultCapabilities();
  }

  private registerDefaultCapabilities() {
    // Epic 1: Define allowed capabilities
    this.registerCapability({
      type: EvaluationCapabilityType.TEST_GENERATION,
      version: '1.0.0',
      description: 'Generates and executes unit tests for code artifacts.',
      allowedActions: ['GENERATE_TEST', 'EXECUTE_TEST_READONLY', 'REPORT_COVERAGE'],
      prohibitedActions: [
        ProhibitedActionType.SELF_APPROVAL,
        ProhibitedActionType.MERGE_GATING,
        ProhibitedActionType.CRITERIA_MODIFICATION
      ]
    });

    this.registerCapability({
      type: EvaluationCapabilityType.STATIC_ANALYSIS,
      version: '1.0.0',
      description: 'Performs static analysis on code or configuration.',
      allowedActions: ['LINT', 'TYPE_CHECK', 'PATTERN_MATCH'],
      prohibitedActions: [
        ProhibitedActionType.SUPPRESSION,
        ProhibitedActionType.CI_MODIFICATION
      ]
    });
  }

  public registerCapability(capability: EvaluationCapability) {
    // Validate schema
    const validated = EvaluationCapabilitySchema.parse(capability);
    // Explicitly cast because we are using manual interface
    this.capabilities.set(validated.type as string, validated as unknown as EvaluationCapability);
  }

  public getCapability(type: EvaluationCapabilityType): EvaluationCapability | undefined {
    return this.capabilities.get(type);
  }

  public async evaluate(request: EvaluationRequest): Promise<EvaluationReport> {
    // 1. Validate Request
    const validatedRequest = EvaluationRequestSchema.parse(request);

    // 2. Check Capability permissions
    const capability = this.capabilities.get(validatedRequest.capability);
    if (!capability) {
      throw new Error(`Capability ${validatedRequest.capability} not registered.`);
    }

    // 3. Epic 5: Threat Modeling & Guardrails
    // Use the validated request (which is typed as Zod output) but we need to pass it to enforceGuardrails
    // which expects EvaluationRequest interface.
    this.enforceGuardrails(validatedRequest as unknown as EvaluationRequest);

    // 4. Run Execution via Harness (Epic 2)
    const report = await this.harness.runEvaluation(validatedRequest as unknown as EvaluationRequest);

    // 5. Epic 4: Reporting & Attribution
    // The report is already generated by the harness, but we can wrap it or log it here.
    this.auditLog(report);

    return report;
  }

  private enforceGuardrails(request: EvaluationRequest) {
    // Prevent recursive self-evaluation abuse
    // If the target is an EvaluationReport, we need to be careful.
    if (request.target && (request.target as any).isAdvisory !== undefined) {
         // This looks like an evaluation report.
         // We might allow meta-evaluation (evaluating a report), but we need strict depth limits.
         // For this sprint, we block it to prevent recursion loops.
         throw new Error("Recursive evaluation detected: Agents cannot evaluate evaluation reports directly in this version.");
    }

    // Epic 3: Ensure criteria are explicit and not hidden
    if (!request.criteria || request.criteria.length === 0) {
      throw new Error("Evaluation request must have explicit criteria.");
    }

    // Check for "Test result suppression" attempts
    // This is hard to check in the request, but we ensure the harness reports ALL results.
  }

  private auditLog(report: EvaluationReport) {
    console.log(`[AUDIT] Evaluation ${report.id} by ${report.agentId}: ${report.criteriaResults.every(r => r.passed) ? 'PASS' : 'FAIL'} (Advisory)`);
    // In a real system, write to a DB or immutable ledger.
  }
}
