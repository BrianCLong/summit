import { cacheService } from '../services/CacheService.js';

/**
 * Wraps a GraphQL resolver function with automatic caching capabilities.
 *
 * This high-order function intercepts the resolver call, checks the cache for an existing result
 * using the key generated by `keyGenerator`, and returns the cached value if found.
 * If not found, it executes the resolver, caches the result, and then returns it.
 *
 * @typeParam TArgs - The type of the arguments passed to the resolver.
 * @typeParam TResult - The return type of the resolver.
 * @param keyGenerator - A function that generates a unique cache key based on the resolver's arguments (parent, args, context, info).
 * @param resolver - The original resolver function to be wrapped.
 * @param ttl - Optional time-to-live for the cached entry in seconds. If not provided, the default TTL from CacheService is used.
 * @returns A new resolver function that implements the caching logic.
 */
export const withCache = <TArgs = unknown, TResult = unknown>(
  keyGenerator: (parent: unknown, args: TArgs, context: unknown, info: unknown) => string,
  resolver: (parent: unknown, args: TArgs, context: unknown, info: unknown) => Promise<TResult>,
  ttl?: number
): ((parent: unknown, args: TArgs, context: unknown, info: unknown) => Promise<TResult>) => {
  return async (parent: unknown, args: TArgs, context: unknown, info: unknown): Promise<TResult> => {
    const key = keyGenerator(parent, args, context, info);

    return cacheService.getOrSet(
      key,
      () => resolver(parent, args, context, info),
      ttl
    );
  };
};

/**
 * Generates a consistent cache key for lists with filtering, sorting, and pagination.
 * 
 * @param prefix - Prefix for the cache key (e.g., 'entities')
 * @param params - Object containing filter, sort, and pagination parameters
 * @returns A string cache key
 */
export const listCacheKey = (prefix: string, params: Record<string, any>): string => {
  const sortedParams = Object.keys(params)
    .sort()
    .reduce((acc, key) => {
      // Filter out undefined/null/empty values to keep keys canonical? 
      // Or keep them valid? Keeping them ensures strict match.
      // But let's just JSON.stringify the sorted object.
      acc[key] = params[key];
      return acc;
    }, {} as Record<string, any>);

  return `${prefix}:${JSON.stringify(sortedParams)}`;
};
