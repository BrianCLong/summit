/**
 * Vulnerability Dashboard API
 * @module server/src/security/vulnerability-dashboard-api
 *
 * REST API endpoints for the vulnerability management dashboard.
 */

import { Router, Request, Response, NextFunction } from 'express';
import {
  getAirGapVulnManager,
  initializeAirGapVulnManager,
  type DashboardData,
  type ScanHistoryEntry,
  type SBOMEntry,
  type VulnerabilityEntry,
} from './airgap-vuln-manager.js';

const router = Router();

// Middleware to ensure manager is initialized
async function ensureInitialized(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    await initializeAirGapVulnManager();
    next();
  } catch (error) {
    res.status(503).json({
      error: 'Vulnerability manager not available',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}

router.use(ensureInitialized);

/**
 * GET /api/security/dashboard
 * Get dashboard summary data
 */
router.get('/dashboard', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const data = await manager.getDashboardData();
    res.json(data);
  } catch (error) {
    console.error('Failed to get dashboard data:', error);
    res.status(500).json({
      error: 'Failed to retrieve dashboard data',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/vulnerabilities
 * Search and list vulnerabilities
 */
router.get('/vulnerabilities', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();

    const query = {
      severity: req.query.severity
        ? (req.query.severity as string).split(',')
        : undefined,
      package: req.query.package as string | undefined,
      hasExploit: req.query.hasExploit === 'true' ? true : undefined,
      cisaKev: req.query.cisaKev === 'true' ? true : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string, 10) : 50,
    };

    const vulnerabilities = manager.searchVulnerabilities(query);

    res.json({
      total: vulnerabilities.length,
      vulnerabilities,
    });
  } catch (error) {
    console.error('Failed to search vulnerabilities:', error);
    res.status(500).json({
      error: 'Failed to search vulnerabilities',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/vulnerabilities/:id
 * Get vulnerability details
 */
router.get('/vulnerabilities/:id', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const vulnerability = manager.getVulnerability(req.params.id);

    if (!vulnerability) {
      res.status(404).json({ error: 'Vulnerability not found' });
      return;
    }

    res.json(vulnerability);
  } catch (error) {
    console.error('Failed to get vulnerability:', error);
    res.status(500).json({
      error: 'Failed to retrieve vulnerability',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * POST /api/security/vulnerabilities/import
 * Import vulnerabilities from external source
 */
router.post('/vulnerabilities/import', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const vulnerabilities: VulnerabilityEntry[] = req.body.vulnerabilities;

    if (!Array.isArray(vulnerabilities)) {
      res.status(400).json({ error: 'Invalid request body, expected vulnerabilities array' });
      return;
    }

    const imported = await manager.importVulnerabilities(vulnerabilities);

    res.json({
      success: true,
      imported,
      message: `Imported ${imported} vulnerability entries`,
    });
  } catch (error) {
    console.error('Failed to import vulnerabilities:', error);
    res.status(500).json({
      error: 'Failed to import vulnerabilities',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/sboms
 * List all SBOMs
 */
router.get('/sboms', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const sboms = manager.getAllSBOMs();

    const limit = req.query.limit ? parseInt(req.query.limit as string, 10) : 50;

    res.json({
      total: sboms.length,
      sboms: sboms.slice(0, limit),
    });
  } catch (error) {
    console.error('Failed to list SBOMs:', error);
    res.status(500).json({
      error: 'Failed to list SBOMs',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/sboms/:id
 * Get SBOM details
 */
router.get('/sboms/:id', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const sbom = manager.getSBOM(req.params.id);

    if (!sbom) {
      res.status(404).json({ error: 'SBOM not found' });
      return;
    }

    res.json(sbom);
  } catch (error) {
    console.error('Failed to get SBOM:', error);
    res.status(500).json({
      error: 'Failed to retrieve SBOM',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * POST /api/security/sboms
 * Record new SBOM
 */
router.post('/sboms', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const sbom: SBOMEntry = req.body;

    if (!sbom.id || !sbom.name) {
      res.status(400).json({ error: 'Invalid SBOM data, id and name required' });
      return;
    }

    await manager.recordSBOM(sbom);

    res.status(201).json({
      success: true,
      id: sbom.id,
      message: 'SBOM recorded successfully',
    });
  } catch (error) {
    console.error('Failed to record SBOM:', error);
    res.status(500).json({
      error: 'Failed to record SBOM',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/scans
 * Get scan history
 */
router.get('/scans', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const limit = req.query.limit ? parseInt(req.query.limit as string, 10) : 20;
    const scans = manager.getRecentScans(limit);

    res.json({
      total: scans.length,
      scans,
    });
  } catch (error) {
    console.error('Failed to get scan history:', error);
    res.status(500).json({
      error: 'Failed to retrieve scan history',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * POST /api/security/scans
 * Record scan result
 */
router.post('/scans', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const scan: ScanHistoryEntry = req.body;

    if (!scan.id || !scan.target) {
      res.status(400).json({ error: 'Invalid scan data, id and target required' });
      return;
    }

    await manager.recordScan(scan);

    res.status(201).json({
      success: true,
      id: scan.id,
      message: 'Scan recorded successfully',
    });
  } catch (error) {
    console.error('Failed to record scan:', error);
    res.status(500).json({
      error: 'Failed to record scan',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/compliance-report
 * Generate compliance report
 */
router.get('/compliance-report', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const report = await manager.generateComplianceReport();

    res.json(report);
  } catch (error) {
    console.error('Failed to generate compliance report:', error);
    res.status(500).json({
      error: 'Failed to generate compliance report',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/health
 * Health check endpoint
 */
router.get('/health', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const health = manager.healthCheck();

    const statusCode = health.status === 'healthy' ? 200 : health.status === 'degraded' ? 200 : 503;

    res.status(statusCode).json(health);
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/trends
 * Get vulnerability trends
 */
router.get('/trends', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const days = req.query.days ? parseInt(req.query.days as string, 10) : 30;
    const data = await manager.getDashboardData();

    res.json({
      period: `${days} days`,
      trends: data.trendData.slice(-days),
    });
  } catch (error) {
    console.error('Failed to get trends:', error);
    res.status(500).json({
      error: 'Failed to retrieve trends',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

/**
 * GET /api/security/policy-violations
 * Get policy violations
 */
router.get('/policy-violations', async (req: Request, res: Response) => {
  try {
    const manager = getAirGapVulnManager();
    const data = await manager.getDashboardData();

    res.json({
      total: data.policyViolations.length,
      violations: data.policyViolations,
    });
  } catch (error) {
    console.error('Failed to get policy violations:', error);
    res.status(500).json({
      error: 'Failed to retrieve policy violations',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

export default router;
export { router as vulnerabilityDashboardRouter };
