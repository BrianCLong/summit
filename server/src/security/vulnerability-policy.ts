/**
 * Vulnerability Policy Engine - Phase 2
 *
 * Implements policy-as-code for security vulnerability management
 * with severity-based blocking and waiver system
 */

import fs from 'fs/promises';
import path from 'path';

interface VulnerabilityPolicy {
  version: string;
  services: {
    [serviceName: string]: ServicePolicy;
  };
  global: GlobalPolicy;
}

interface ServicePolicy {
  exposure: 'internet-facing' | 'internal' | 'private';
  severity_thresholds: {
    critical: 'block' | 'warn' | 'ignore';
    high: 'block' | 'warn' | 'ignore';
    medium: 'block' | 'warn' | 'ignore';
    low: 'block' | 'warn' | 'ignore';
  };
  allowed_vulnerabilities: string[]; // CVE IDs with waivers
  scan_schedule: 'on_push' | 'daily' | 'weekly';
}

interface GlobalPolicy {
  default_severity_thresholds: ServicePolicy['severity_thresholds'];
  emergency_bypass_enabled: boolean;
  waiver_expiry_days: number;
  notification_channels: string[];
}

interface VulnerabilityWaiver {
  cve_id: string;
  service: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  reason: string;
  approved_by: string;
  approval_date: string;
  expiry_date: string;
  mitigation_steps: string[];
  issue_url?: string;
}

interface VulnerabilityResult {
  allowed: boolean;
  blocked_vulnerabilities: string[];
  warnings: string[];
  waivers_applied: string[];
  policy_violations: string[];
}

/**
 * Vulnerability Policy Manager
 */
class VulnerabilityPolicyManager {
  private policyPath: string;
  private waiversPath: string;
  private policy: VulnerabilityPolicy | null = null;
  private waivers: VulnerabilityWaiver[] = [];

  constructor(
    policyPath: string = 'security/vulnerability-policy.json',
    waiversPath: string = 'security/vulnerability-waivers.json',
  ) {
    this.policyPath = policyPath;
    this.waiversPath = waiversPath;
  }

  /**
   * Initialize the policy manager
   */
  async initialize(): Promise<void> {
    console.log('üõ°Ô∏è  Initializing Vulnerability Policy Manager...');

    try {
      await this.loadPolicy();
      await this.loadWaivers();
      await this.validateConfiguration();

      console.log('‚úÖ Vulnerability Policy Manager initialized');
    } catch (error) {
      console.error('‚ùå Failed to initialize vulnerability policy:', error);
      throw error;
    }
  }

  /**
   * Load vulnerability policy from file
   */
  private async loadPolicy(): Promise<void> {
    try {
      const policyData = await fs.readFile(this.policyPath, 'utf-8');
      this.policy = JSON.parse(policyData);
      console.log(`üìã Loaded vulnerability policy v${this.policy?.version}`);
    } catch (error) {
      if (error.code === 'ENOENT') {
        // Create default policy if none exists
        await this.createDefaultPolicy();
      } else {
        throw error;
      }
    }
  }

  /**
   * Load vulnerability waivers from file
   */
  private async loadWaivers(): Promise<void> {
    try {
      const waiversData = await fs.readFile(this.waiversPath, 'utf-8');
      this.waivers = JSON.parse(waiversData);

      // Remove expired waivers
      const now = new Date();
      this.waivers = this.waivers.filter((waiver) => {
        const expiryDate = new Date(waiver.expiry_date);
        if (expiryDate < now) {
          console.log(`üóëÔ∏è  Removed expired waiver: ${waiver.cve_id}`);
          return false;
        }
        return true;
      });

      console.log(
        `üìÑ Loaded ${this.waivers.length} active vulnerability waivers`,
      );
    } catch (error) {
      if (error.code === 'ENOENT') {
        this.waivers = [];
        console.log(
          'üìÑ No vulnerability waivers file found, starting with empty list',
        );
      } else {
        throw error;
      }
    }
  }

  /**
   * Create default vulnerability policy
   */
  private async createDefaultPolicy(): Promise<void> {
    const defaultPolicy: VulnerabilityPolicy = {
      version: '1.0',
      global: {
        default_severity_thresholds: {
          critical: 'block',
          high: 'block',
          medium: 'warn',
          low: 'ignore',
        },
        emergency_bypass_enabled: true,
        waiver_expiry_days: 30,
        notification_channels: ['#security-alerts', '#platform-alerts'],
      },
      services: {
        'intelgraph-server': {
          exposure: 'internet-facing',
          severity_thresholds: {
            critical: 'block',
            high: 'block',
            medium: 'block', // Stricter for internet-facing services
            low: 'warn',
          },
          allowed_vulnerabilities: [],
          scan_schedule: 'on_push',
        },
        'analytics-engine': {
          exposure: 'internal',
          severity_thresholds: {
            critical: 'block',
            high: 'block',
            medium: 'warn',
            low: 'ignore',
          },
          allowed_vulnerabilities: [],
          scan_schedule: 'daily',
        },
      },
    };

    // Ensure directory exists
    await fs.mkdir(path.dirname(this.policyPath), { recursive: true });

    await fs.writeFile(this.policyPath, JSON.stringify(defaultPolicy, null, 2));
    this.policy = defaultPolicy;

    console.log('üìã Created default vulnerability policy');
  }

  /**
   * Validate policy configuration
   */
  private async validateConfiguration(): Promise<void> {
    if (!this.policy) {
      throw new Error('No policy loaded');
    }

    // Validate policy structure
    if (!this.policy.version || !this.policy.global || !this.policy.services) {
      throw new Error('Invalid policy structure');
    }

    // Validate service configurations
    for (const [serviceName, servicePolicy] of Object.entries(
      this.policy.services,
    )) {
      if (!servicePolicy.exposure || !servicePolicy.severity_thresholds) {
        throw new Error(`Invalid configuration for service: ${serviceName}`);
      }
    }

    console.log('‚úÖ Policy configuration validated');
  }

  /**
   * Evaluate vulnerabilities against policy
   */
  async evaluateVulnerabilities(
    serviceName: string,
    vulnerabilities: Array<{
      cve_id: string;
      severity: 'critical' | 'high' | 'medium' | 'low';
      description: string;
      package?: string;
    }>,
  ): Promise<VulnerabilityResult> {
    if (!this.policy) {
      throw new Error('Policy not initialized');
    }

    const servicePolicy =
      this.policy.services[serviceName] || this.createDefaultServicePolicy();

    const result: VulnerabilityResult = {
      allowed: true,
      blocked_vulnerabilities: [],
      warnings: [],
      waivers_applied: [],
      policy_violations: [],
    };

    console.log(
      `üîç Evaluating ${vulnerabilities.length} vulnerabilities for ${serviceName}`,
    );

    for (const vuln of vulnerabilities) {
      const action = this.getActionForVulnerability(vuln, servicePolicy);

      switch (action.type) {
        case 'block':
          result.blocked_vulnerabilities.push(vuln.cve_id);
          result.allowed = false;
          result.policy_violations.push(
            `${vuln.cve_id}: ${vuln.severity.toUpperCase()} severity blocked`,
          );
          break;

        case 'warn':
          result.warnings.push(
            `${vuln.cve_id}: ${vuln.severity.toUpperCase()} severity warning`,
          );
          break;

        case 'waiver':
          result.waivers_applied.push(vuln.cve_id);
          console.log(
            `‚ö†Ô∏è  Applied waiver for ${vuln.cve_id}: ${action.reason}`,
          );
          break;

        case 'ignore':
          // No action needed
          break;
      }
    }

    // Log results
    if (!result.allowed) {
      console.log(
        `‚ùå Policy violation: ${result.blocked_vulnerabilities.length} vulnerabilities blocked`,
      );
    } else if (result.warnings.length > 0) {
      console.log(
        `‚ö†Ô∏è  Policy warnings: ${result.warnings.length} vulnerabilities flagged`,
      );
    } else {
      console.log('‚úÖ All vulnerabilities within policy thresholds');
    }

    return result;
  }

  /**
   * Get action for a specific vulnerability
   */
  private getActionForVulnerability(
    vuln: { cve_id: string; severity: string },
    servicePolicy: ServicePolicy,
  ): {
    type: 'block' | 'warn' | 'ignore' | 'waiver';
    reason?: string;
  } {
    // Check for active waiver first
    const waiver = this.waivers.find(
      (w) => w.cve_id === vuln.cve_id && new Date(w.expiry_date) > new Date(),
    );

    if (waiver) {
      return { type: 'waiver', reason: waiver.reason };
    }

    // Check service-specific allowed vulnerabilities
    if (servicePolicy.allowed_vulnerabilities.includes(vuln.cve_id)) {
      return { type: 'ignore', reason: 'Service-specific allowlist' };
    }

    // Apply severity threshold
    const action =
      servicePolicy.severity_thresholds[
        vuln.severity as keyof ServicePolicy['severity_thresholds']
      ];
    return { type: action as any };
  }

  /**
   * Create default service policy
   */
  private createDefaultServicePolicy(): ServicePolicy {
    return {
      exposure: 'internal',
      severity_thresholds: this.policy!.global.default_severity_thresholds,
      allowed_vulnerabilities: [],
      scan_schedule: 'daily',
    };
  }

  /**
   * Create a new vulnerability waiver
   */
  async createWaiver(
    waiver: Omit<VulnerabilityWaiver, 'approval_date' | 'expiry_date'>,
  ): Promise<void> {
    const now = new Date();
    const expiryDate = new Date();
    expiryDate.setDate(
      expiryDate.getDate() + (this.policy?.global.waiver_expiry_days || 30),
    );

    const newWaiver: VulnerabilityWaiver = {
      ...waiver,
      approval_date: now.toISOString().split('T')[0],
      expiry_date: expiryDate.toISOString().split('T')[0],
    };

    this.waivers.push(newWaiver);

    // Save to file
    await fs.writeFile(this.waiversPath, JSON.stringify(this.waivers, null, 2));

    console.log(`üìù Created vulnerability waiver: ${newWaiver.cve_id}`);
  }

  /**
   * Generate waiver template for blocked vulnerabilities
   */
  generateWaiverTemplate(blockedVulns: string[], serviceName: string): object {
    return blockedVulns.map((cveId) => ({
      cve_id: cveId,
      service: serviceName,
      severity: 'REQUIRED: vulnerability severity',
      reason: 'REQUIRED: Business justification for accepting this risk',
      approved_by: 'REQUIRED: Security team member or service owner',
      mitigation_steps: [
        'REQUIRED: List specific mitigation measures',
        'e.g., Network segmentation prevents external access',
        'e.g., Monitoring in place for exploitation attempts',
      ],
      issue_url: 'OPTIONAL: Link to tracking issue',
    }));
  }

  /**
   * Get policy summary for a service
   */
  getServicePolicySummary(serviceName: string): object {
    const servicePolicy = this.policy?.services[serviceName];
    const activeWaivers = this.waivers.filter(
      (w) => w.service === serviceName && new Date(w.expiry_date) > new Date(),
    );

    return {
      service: serviceName,
      exposure: servicePolicy?.exposure || 'unknown',
      severity_thresholds:
        servicePolicy?.severity_thresholds ||
        this.policy?.global.default_severity_thresholds,
      active_waivers: activeWaivers.length,
      scan_schedule: servicePolicy?.scan_schedule || 'unknown',
    };
  }

  /**
   * Health check for vulnerability policy
   */
  healthCheck(): {
    status: 'healthy' | 'degraded' | 'unhealthy';
    details: any;
  } {
    try {
      const activeWaivers = this.waivers.filter(
        (w) => new Date(w.expiry_date) > new Date(),
      );

      const expiringWaivers = activeWaivers.filter((w) => {
        const expiryDate = new Date(w.expiry_date);
        const warningDate = new Date();
        warningDate.setDate(warningDate.getDate() + 7); // 7 days warning
        return expiryDate < warningDate;
      });

      return {
        status: this.policy ? 'healthy' : 'degraded',
        details: {
          policy_version: this.policy?.version,
          services_configured: Object.keys(this.policy?.services || {}).length,
          active_waivers: activeWaivers.length,
          expiring_waivers: expiringWaivers.length,
          emergency_bypass: this.policy?.global.emergency_bypass_enabled,
        },
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: { error: error.message },
      };
    }
  }
}

/**
 * Factory function
 */
export function createVulnerabilityPolicyManager(
  policyPath?: string,
  waiversPath?: string,
): VulnerabilityPolicyManager {
  return new VulnerabilityPolicyManager(policyPath, waiversPath);
}

export {
  VulnerabilityPolicyManager,
  VulnerabilityPolicy,
  VulnerabilityWaiver,
  VulnerabilityResult,
};
