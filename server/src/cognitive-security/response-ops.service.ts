/**
 * Response Operations Service
 *
 * Generates actionable response artifacts for detected campaigns:
 * - Verified briefings with citations and confidence
 * - Stakeholder-specific messaging (legal/PR/ops)
 * - Takedown/escalation packets for platforms
 * - Internal communications templates
 * - Evidence bundles for audit
 */

import { randomUUID } from 'crypto';
import pino from 'pino';
import type { Driver, Session } from 'neo4j-driver';

import type {
  Campaign,
  CampaignThreatLevel,
  ResponsePlaybook,
  ResponseAction,
  ResponseActionType,
  ResponseArtifact,
  VerifiedBriefing,
  TakedownPacket,
  ArtifactCitation,
  PlaybookStatus,
  Claim,
  ClaimVerdict,
  Evidence,
  CogSecIncident,
  IncidentStatus,
  IncidentTimelineEvent,
} from './types.js';

const logger = (pino as any)({ name: 'response-ops-service' });

// ============================================================================
// Configuration
// ============================================================================

export interface ResponseOpsConfig {
  /** Neo4j driver */
  neo4jDriver: Driver;
  /** LLM service for generating content */
  llmService?: LLMService;
  /** Template directory */
  templateDir?: string;
  /** Organization name for branding */
  organizationName?: string;
}

interface LLMService {
  complete(params: {
    prompt: string;
    model?: string;
    maxTokens?: number;
    temperature?: number;
  }): Promise<string>;
}

// ============================================================================
// Response Templates
// ============================================================================

const BRIEFING_TEMPLATE = `
# {{CAMPAIGN_NAME}} - Intelligence Briefing

**Classification:** {{THREAT_LEVEL}}
**Prepared:** {{DATE}}
**Analyst:** {{ANALYST}}

## Executive Summary

{{EXECUTIVE_SUMMARY}}

## Key Findings

{{KEY_FINDINGS}}

## Claim Analysis

{{CLAIM_VERDICTS}}

## Recommended Actions

{{RECOMMENDED_ACTIONS}}

## Risk Assessment

**Threat Level:** {{THREAT_LEVEL}}

**Risk Factors:**
{{RISK_FACTORS}}

**Mitigations:**
{{MITIGATIONS}}

## Evidence & Citations

{{CITATIONS}}

---
*This briefing was generated by {{ORG_NAME}} Cognitive Security Operations.*
*Confidence Score: {{CONFIDENCE}}*
`;

const STAKEHOLDER_TEMPLATES: Record<string, string> = {
  legal: `
## Legal Advisory - {{CAMPAIGN_NAME}}

**Date:** {{DATE}}
**Priority:** {{PRIORITY}}

### Summary
{{SUMMARY}}

### Legal Considerations
- Platform Terms of Service violations identified
- Potential defamation claims
- Evidence preservation requirements

### Recommended Legal Actions
{{ACTIONS}}

### Evidence Bundle Reference
Bundle ID: {{BUNDLE_ID}}
`,

  pr: `
## Communications Advisory - {{CAMPAIGN_NAME}}

**Date:** {{DATE}}
**Urgency:** {{PRIORITY}}

### Situation Overview
{{SUMMARY}}

### Key Messages
{{MESSAGES}}

### Talking Points
{{TALKING_POINTS}}

### Media Response Template
{{RESPONSE_TEMPLATE}}
`,

  ops: `
## Operational Response - {{CAMPAIGN_NAME}}

**Date:** {{DATE}}
**Priority:** {{PRIORITY}}

### Situation
{{SUMMARY}}

### Immediate Actions Required
{{IMMEDIATE_ACTIONS}}

### Monitoring Tasks
{{MONITORING_TASKS}}

### Escalation Path
{{ESCALATION_PATH}}
`,

  internal: `
## Internal Communication - {{CAMPAIGN_NAME}}

**Date:** {{DATE}}
**Distribution:** {{DISTRIBUTION}}

### What Happened
{{SUMMARY}}

### What We're Doing
{{ACTIONS}}

### What You Should Know
{{KEY_POINTS}}

### Questions?
Contact: {{CONTACT}}
`,
};

const TAKEDOWN_TEMPLATE = `
## Content Removal Request

**Platform:** {{PLATFORM}}
**Date:** {{DATE}}
**Reference:** {{REFERENCE}}

### Violation Type
{{VIOLATION_TYPE}}

### Content to Remove

**URLs:**
{{URLS}}

**Account IDs:**
{{ACCOUNT_IDS}}

### Evidence of Violation
{{EVIDENCE_SUMMARY}}

### Legal Basis
{{LEGAL_BASIS}}

### Contact Information
{{CONTACT_INFO}}

---
Evidence Bundle ID: {{BUNDLE_ID}}
`;

// ============================================================================
// Response Operations Service
// ============================================================================

export class ResponseOpsService {
  private readonly config: ResponseOpsConfig;

  constructor(config: ResponseOpsConfig) {
    this.config = config;
    logger.info('Response operations service initialized');
  }

  private getSession(): Session {
    return this.config.neo4jDriver.session();
  }

  // ==========================================================================
  // Playbook Generation
  // ==========================================================================

  /**
   * Generate a response playbook for a campaign
   */
  async generatePlaybook(
    campaignId: string,
    createdBy: string,
    options?: {
      priority?: number;
      assigneeId?: string;
      dueAt?: string;
    },
  ): Promise<ResponsePlaybook> {
    // Get campaign details
    const campaign = await this.getCampaignDetails(campaignId);
    if (!campaign) {
      throw new Error(`Campaign not found: ${campaignId}`);
    }

    // Determine actions based on threat level
    const actions = await this.determineActions(campaign);

    const playbook: ResponsePlaybook = {
      id: randomUUID(),
      name: `Response: ${campaign.name}`,
      description: `Response playbook for ${campaign.threatLevel} threat campaign`,
      status: 'DRAFT',
      campaignId,
      assigneeId: options?.assigneeId,
      actions,
      priority: options?.priority || this.threatLevelToPriority(campaign.threatLevel),
      dueAt: options?.dueAt,
      createdBy,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Persist playbook
    await this.persistPlaybook(playbook);

    // Update campaign with playbook reference
    await this.linkPlaybookToCampaign(playbook.id, campaignId);

    logger.info(
      { playbookId: playbook.id, campaignId, actionCount: actions.length },
      'Generated response playbook',
    );

    return playbook;
  }

  /**
   * Determine response actions based on campaign
   */
  private async determineActions(campaign: Campaign): Promise<ResponseAction[]> {
    const actions: ResponseAction[] = [];

    // Always generate a briefing
    actions.push({
      id: randomUUID(),
      type: 'BRIEFING',
      title: 'Generate Verified Briefing',
      description: 'Create comprehensive briefing with claim verdicts and citations',
      status: 'PENDING',
    });

    // Threat-level specific actions
    if (campaign.threatLevel === 'CRITICAL' || campaign.threatLevel === 'HIGH') {
      actions.push({
        id: randomUUID(),
        type: 'INTERNAL_COMMS',
        title: 'Prepare Internal Communications',
        description: 'Draft internal notification for relevant teams',
        status: 'PENDING',
      });

      actions.push({
        id: randomUUID(),
        type: 'ESCALATION',
        title: 'Escalate to Leadership',
        description: 'Prepare executive briefing and escalation',
        status: 'PENDING',
      });
    }

    if (campaign.threatLevel === 'CRITICAL') {
      actions.push({
        id: randomUUID(),
        type: 'STAKEHOLDER_MESSAGE',
        title: 'Prepare Legal Advisory',
        description: 'Draft legal considerations and recommendations',
        status: 'PENDING',
      });

      actions.push({
        id: randomUUID(),
        type: 'STAKEHOLDER_MESSAGE',
        title: 'Prepare PR Response',
        description: 'Draft communications response strategy',
        status: 'PENDING',
      });
    }

    // If coordinated actors identified, consider takedowns
    if (campaign.actorIds.length >= 5) {
      actions.push({
        id: randomUUID(),
        type: 'TAKEDOWN_PACKET',
        title: 'Prepare Takedown Requests',
        description: 'Generate platform-specific takedown packets',
        status: 'PENDING',
      });
    }

    // Always end with monitoring
    actions.push({
      id: randomUUID(),
      type: 'MONITORING',
      title: 'Establish Monitoring',
      description: 'Set up ongoing monitoring for campaign evolution',
      status: 'PENDING',
    });

    return actions;
  }

  /**
   * Convert threat level to priority (1 = highest)
   */
  private threatLevelToPriority(threatLevel: CampaignThreatLevel): number {
    switch (threatLevel) {
      case 'CRITICAL':
        return 1;
      case 'HIGH':
        return 2;
      case 'MEDIUM':
        return 3;
      case 'LOW':
        return 4;
      default:
        return 5;
    }
  }

  // ==========================================================================
  // Artifact Generation
  // ==========================================================================

  /**
   * Generate a verified briefing for a campaign
   */
  async generateBriefing(
    campaignId: string,
    generatedBy: string,
  ): Promise<VerifiedBriefing> {
    const campaign = await this.getCampaignDetails(campaignId);
    if (!campaign) {
      throw new Error(`Campaign not found: ${campaignId}`);
    }

    // Get claims and evidence
    const { claims, evidence } = await this.getCampaignClaimsAndEvidence(campaignId);

    // Build claim verdicts
    const claimVerdicts = claims.map((claim) => ({
      claimId: claim.id,
      claimText: claim.canonicalText,
      verdict: claim.verdict,
      confidence: claim.verdictConfidence,
    }));

    // Build citations
    const citations = this.buildCitations(claims, evidence);

    // Generate executive summary using LLM if available
    let executiveSummary = '';
    let keyFindings: string[] = [];
    let recommendedActions: string[] = [];

    if (this.config.llmService) {
      const summaryPrompt = this.buildSummaryPrompt(campaign, claims);
      const summaryResponse = await this.config.llmService.complete({
        prompt: summaryPrompt,
        maxTokens: 1000,
        temperature: 0.3,
      });

      const parsed = this.parseSummaryResponse(summaryResponse);
      executiveSummary = parsed.summary;
      keyFindings = parsed.findings;
      recommendedActions = parsed.actions;
    } else {
      // Fallback to template-based generation
      executiveSummary = `A ${campaign.threatLevel.toLowerCase()} threat campaign "${campaign.name}" ` +
        `has been detected involving ${campaign.actorIds.length} actors and ${claims.length} claims.`;
      keyFindings = [
        `${claims.filter((c) => c.verdict === 'REFUTED').length} claims have been refuted`,
        `${claims.filter((c) => c.verdict === 'VERIFIED').length} claims are verified true`,
        `Campaign spread across ${campaign.channelIds.length} channels`,
      ];
      recommendedActions = this.getDefaultRecommendations(campaign.threatLevel);
    }

    const briefing: VerifiedBriefing = {
      id: randomUUID(),
      type: 'BRIEFING',
      title: `Intelligence Briefing: ${campaign.name}`,
      content: this.renderBriefingTemplate(
        campaign,
        executiveSummary,
        keyFindings,
        claimVerdicts,
        recommendedActions,
        citations,
      ),
      targetAudience: 'leadership',
      citations,
      confidenceScore: this.calculateBriefingConfidence(claims),
      generatedBy,
      generatedAt: new Date().toISOString(),
      exportFormats: ['pdf', 'docx', 'markdown'],
      executiveSummary,
      keyFindings,
      claimVerdicts,
      recommendedActions,
      riskAssessment: {
        level: campaign.threatLevel,
        factors: this.getRiskFactors(campaign),
        mitigations: this.getMitigations(campaign.threatLevel),
      },
    };

    // Persist artifact
    await this.persistArtifact(briefing, campaignId);

    logger.info(
      { briefingId: briefing.id, campaignId },
      'Generated verified briefing',
    );

    return briefing;
  }

  /**
   * Generate stakeholder-specific message
   */
  async generateStakeholderMessage(
    campaignId: string,
    stakeholder: 'legal' | 'pr' | 'ops' | 'internal',
    generatedBy: string,
  ): Promise<ResponseArtifact> {
    const campaign = await this.getCampaignDetails(campaignId);
    if (!campaign) {
      throw new Error(`Campaign not found: ${campaignId}`);
    }

    const template = STAKEHOLDER_TEMPLATES[stakeholder];
    const { claims, evidence } = await this.getCampaignClaimsAndEvidence(campaignId);
    const citations = this.buildCitations(claims, evidence);

    // Generate content using LLM if available
    let content = '';
    if (this.config.llmService) {
      const prompt = this.buildStakeholderPrompt(campaign, stakeholder, claims);
      content = await this.config.llmService.complete({
        prompt,
        maxTokens: 1500,
        temperature: 0.4,
      });
    } else {
      content = this.renderStakeholderTemplate(template, campaign, stakeholder);
    }

    const artifact: ResponseArtifact = {
      id: randomUUID(),
      type: 'STAKEHOLDER_MESSAGE',
      title: `${stakeholder.toUpperCase()} Advisory: ${campaign.name}`,
      content,
      targetAudience: stakeholder,
      citations,
      confidenceScore: this.calculateBriefingConfidence(claims),
      generatedBy,
      generatedAt: new Date().toISOString(),
      exportFormats: ['pdf', 'docx', 'markdown'],
    };

    await this.persistArtifact(artifact, campaignId);

    logger.info(
      { artifactId: artifact.id, campaignId, stakeholder },
      'Generated stakeholder message',
    );

    return artifact;
  }

  /**
   * Generate takedown packet for a platform
   */
  async generateTakedownPacket(
    campaignId: string,
    platform: string,
    urls: string[],
    accountIds: string[],
    violationType: string,
    generatedBy: string,
    options?: {
      legalBasis?: string;
      contactInfo?: string;
    },
  ): Promise<TakedownPacket> {
    const campaign = await this.getCampaignDetails(campaignId);
    if (!campaign) {
      throw new Error(`Campaign not found: ${campaignId}`);
    }

    const { claims, evidence } = await this.getCampaignClaimsAndEvidence(campaignId);
    const citations = this.buildCitations(claims, evidence);

    // Generate evidence bundle
    const evidenceBundleId = await this.createEvidenceBundle(campaignId);

    const content = this.renderTakedownTemplate({
      platform,
      violationType,
      urls,
      accountIds,
      evidenceBundleId,
      legalBasis: options?.legalBasis,
      contactInfo: options?.contactInfo,
    });

    const takedownPacket: TakedownPacket = {
      id: randomUUID(),
      type: 'TAKEDOWN_PACKET',
      title: `Takedown Request: ${platform} - ${campaign.name}`,
      content,
      targetAudience: 'platform_trust_safety',
      citations,
      confidenceScore: this.calculateBriefingConfidence(claims),
      generatedBy,
      generatedAt: new Date().toISOString(),
      exportFormats: ['pdf'],
      platform,
      violationType,
      urls,
      accountIds,
      evidenceBundleId,
      legalBasis: options?.legalBasis,
      contactInfo: options?.contactInfo,
    };

    await this.persistArtifact(takedownPacket, campaignId);

    logger.info(
      { takedownId: takedownPacket.id, campaignId, platform, urlCount: urls.length },
      'Generated takedown packet',
    );

    return takedownPacket;
  }

  /**
   * Create evidence bundle for export
   */
  async createEvidenceBundle(campaignId: string): Promise<string> {
    const bundleId = randomUUID();
    const session = this.getSession();

    try {
      await session.run(
        `
        CREATE (b:CogSecEvidenceBundle {
          id: $bundleId,
          campaignId: $campaignId,
          createdAt: datetime(),
          status: 'CREATED'
        })
        WITH b
        MATCH (camp:CogSecCampaign {id: $campaignId})
        MERGE (camp)-[:HAS_BUNDLE]->(b)
        `,
        { bundleId, campaignId },
      );

      return bundleId;
    } finally {
      await session.close();
    }
  }

  // ==========================================================================
  // Incident Management
  // ==========================================================================

  /**
   * Create incident from campaign
   */
  async createIncident(
    campaignId: string,
    name: string,
    description: string,
    leadAnalystId: string,
    severity?: number,
  ): Promise<CogSecIncident> {
    const campaign = await this.getCampaignDetails(campaignId);
    if (!campaign) {
      throw new Error(`Campaign not found: ${campaignId}`);
    }

    const incident: CogSecIncident = {
      id: randomUUID(),
      name,
      description,
      status: 'OPEN',
      severity: severity || this.threatLevelToSeverity(campaign.threatLevel),
      campaignIds: [campaignId],
      playbookIds: campaign.responsePlaybookIds,
      leadAnalystId,
      teamMemberIds: [leadAnalystId],
      timeline: [
        {
          id: randomUUID(),
          type: 'DETECTION',
          description: `Incident created from campaign "${campaign.name}"`,
          actorId: leadAnalystId,
          timestamp: new Date().toISOString(),
          relatedEntityIds: [campaignId],
        },
      ],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    await this.persistIncident(incident);

    // Link campaign to incident
    await this.linkCampaignToIncident(campaignId, incident.id);

    logger.info(
      { incidentId: incident.id, campaignId },
      'Created incident from campaign',
    );

    return incident;
  }

  /**
   * Add timeline event to incident
   */
  async addTimelineEvent(
    incidentId: string,
    type: IncidentTimelineEvent['type'],
    description: string,
    actorId?: string,
    relatedEntityIds?: string[],
  ): Promise<IncidentTimelineEvent> {
    const event: IncidentTimelineEvent = {
      id: randomUUID(),
      type,
      description,
      actorId,
      timestamp: new Date().toISOString(),
      relatedEntityIds,
    };

    const session = this.getSession();
    try {
      await session.run(
        `
        MATCH (i:CogSecIncident {id: $incidentId})
        SET i.timeline = i.timeline + [$event],
            i.updatedAt = datetime()
        `,
        { incidentId, event: JSON.stringify(event) },
      );

      return event;
    } finally {
      await session.close();
    }
  }

  /**
   * Update incident status
   */
  async updateIncidentStatus(
    incidentId: string,
    status: IncidentStatus,
    actorId: string,
  ): Promise<CogSecIncident> {
    const session = this.getSession();
    try {
      const result = await session.run(
        `
        MATCH (i:CogSecIncident {id: $incidentId})
        SET i.status = $status,
            i.updatedAt = datetime()
        ${status === 'RESOLVED' ? ', i.resolvedAt = datetime()' : ''}
        RETURN i
        `,
        { incidentId, status },
      );

      if (result.records.length === 0) {
        throw new Error(`Incident not found: ${incidentId}`);
      }

      // Add timeline event
      await this.addTimelineEvent(
        incidentId,
        status === 'RESOLVED' ? 'RESOLUTION' : 'UPDATE',
        `Status changed to ${status}`,
        actorId,
      );

      return this.recordToIncident(result.records[0].get('i'));
    } finally {
      await session.close();
    }
  }

  // ==========================================================================
  // Playbook Execution
  // ==========================================================================

  /**
   * Execute a playbook action
   */
  async executeAction(
    playbookId: string,
    actionId: string,
    executorId: string,
  ): Promise<ResponseAction> {
    const session = this.getSession();
    try {
      // Get playbook
      const result = await session.run(
        'MATCH (p:CogSecPlaybook {id: $playbookId}) RETURN p',
        { playbookId },
      );

      if (result.records.length === 0) {
        throw new Error(`Playbook not found: ${playbookId}`);
      }

      const playbook = this.recordToPlaybook(result.records[0].get('p'));
      const action = playbook.actions.find((a) => a.id === actionId);

      if (!action) {
        throw new Error(`Action not found: ${actionId}`);
      }

      // Generate artifact based on action type
      let artifact: ResponseArtifact | undefined;

      switch (action.type) {
        case 'BRIEFING':
          artifact = await this.generateBriefing(playbook.campaignId, executorId);
          break;
        case 'STAKEHOLDER_MESSAGE':
          const stakeholder = this.inferStakeholder(action.title);
          artifact = await this.generateStakeholderMessage(
            playbook.campaignId,
            stakeholder,
            executorId,
          );
          break;
        // Other action types would be handled similarly
      }

      // Update action status
      action.status = 'COMPLETED';
      action.completedAt = new Date().toISOString();
      action.completedBy = executorId;
      action.artifact = artifact;

      // Persist updated playbook
      await this.updatePlaybookActions(playbookId, playbook.actions);

      logger.info(
        { playbookId, actionId, actionType: action.type },
        'Executed playbook action',
      );

      return action;
    } finally {
      await session.close();
    }
  }

  /**
   * Update playbook status
   */
  async updatePlaybookStatus(
    playbookId: string,
    status: PlaybookStatus,
  ): Promise<ResponsePlaybook> {
    const session = this.getSession();
    try {
      const result = await session.run(
        `
        MATCH (p:CogSecPlaybook {id: $playbookId})
        SET p.status = $status,
            p.updatedAt = datetime()
        RETURN p
        `,
        { playbookId, status },
      );

      if (result.records.length === 0) {
        throw new Error(`Playbook not found: ${playbookId}`);
      }

      return this.recordToPlaybook(result.records[0].get('p'));
    } finally {
      await session.close();
    }
  }

  // ==========================================================================
  // Helper Methods
  // ==========================================================================

  private async getCampaignDetails(campaignId: string): Promise<Campaign | null> {
    const session = this.getSession();
    try {
      const result = await session.run(
        'MATCH (c:CogSecCampaign {id: $campaignId}) RETURN c',
        { campaignId },
      );

      if (result.records.length === 0) return null;

      const props = result.records[0].get('c').properties;
      return {
        ...props,
        metrics:
          typeof props.metrics === 'string'
            ? JSON.parse(props.metrics)
            : props.metrics,
      };
    } finally {
      await session.close();
    }
  }

  private async getCampaignClaimsAndEvidence(
    campaignId: string,
  ): Promise<{ claims: Claim[]; evidence: Evidence[] }> {
    const session = this.getSession();
    try {
      const result = await session.run(
        `
        MATCH (camp:CogSecCampaign {id: $campaignId})
        OPTIONAL MATCH (c:CogSecClaim) WHERE c.id IN camp.claimIds
        OPTIONAL MATCH (c)-[:SUPPORTED_BY]->(e:CogSecEvidence)
        RETURN collect(DISTINCT c) AS claims, collect(DISTINCT e) AS evidence
        `,
        { campaignId },
      );

      const record = result.records[0];
      return {
        claims: (record.get('claims') as any[])
          .filter((c) => c)
          .map((c) => this.recordToClaim(c)),
        evidence: (record.get('evidence') as any[])
          .filter((e) => e)
          .map((e) => this.recordToEvidence(e)),
      };
    } finally {
      await session.close();
    }
  }

  private buildCitations(
    claims: Claim[],
    evidence: Evidence[],
  ): ArtifactCitation[] {
    const citations: ArtifactCitation[] = [];

    for (const claim of claims) {
      citations.push({
        id: randomUUID(),
        referenceText: claim.canonicalText.substring(0, 200),
        sourceType: 'CLAIM',
        sourceId: claim.id,
        confidence: claim.verdictConfidence,
      });
    }

    for (const ev of evidence) {
      citations.push({
        id: randomUUID(),
        referenceText: ev.title,
        sourceType: 'EVIDENCE',
        sourceId: ev.id,
        externalUrl: ev.sourceUrl,
        confidence: ev.sourceCredibility,
      });
    }

    return citations;
  }

  private buildSummaryPrompt(campaign: Campaign, claims: Claim[]): string {
    const claimSummaries = claims
      .slice(0, 10)
      .map((c) => `- "${c.canonicalText}" (${c.verdict})`)
      .join('\n');

    return `
You are an intelligence analyst creating a briefing about an influence campaign.

Campaign Details:
- Name: ${campaign.name}
- Threat Level: ${campaign.threatLevel}
- Actors Involved: ${campaign.actorIds.length}
- Channels Used: ${campaign.channelIds.length}
- Claims Tracked: ${claims.length}

Sample Claims:
${claimSummaries}

Generate a structured response with:
1. SUMMARY: A 2-3 sentence executive summary
2. FINDINGS: 3-5 key findings as bullet points
3. ACTIONS: 3-5 recommended actions

Format your response exactly as:
SUMMARY: [your summary]
FINDINGS:
- [finding 1]
- [finding 2]
ACTIONS:
- [action 1]
- [action 2]
`;
  }

  private parseSummaryResponse(response: string): {
    summary: string;
    findings: string[];
    actions: string[];
  } {
    const summaryMatch = response.match(/SUMMARY:\s*(.+?)(?=FINDINGS:|$)/s);
    const findingsMatch = response.match(
      /FINDINGS:\s*(.+?)(?=ACTIONS:|$)/s,
    );
    const actionsMatch = response.match(/ACTIONS:\s*(.+?)$/s);

    const extractBullets = (text: string): string[] =>
      text
        .split('\n')
        .filter((line) => line.trim().startsWith('-'))
        .map((line) => line.replace(/^-\s*/, '').trim());

    return {
      summary: summaryMatch?.[1]?.trim() || '',
      findings: findingsMatch ? extractBullets(findingsMatch[1]) : [],
      actions: actionsMatch ? extractBullets(actionsMatch[1]) : [],
    };
  }

  private buildStakeholderPrompt(
    campaign: Campaign,
    stakeholder: string,
    claims: Claim[],
  ): string {
    return `
You are a communications specialist preparing a ${stakeholder} advisory.

Campaign: ${campaign.name}
Threat Level: ${campaign.threatLevel}
Claims: ${claims.length} tracked claims

Generate a ${stakeholder}-appropriate advisory that:
- Uses appropriate tone and terminology for ${stakeholder}
- Highlights relevant concerns for their domain
- Provides actionable recommendations

Format as a professional advisory document.
`;
  }

  private getDefaultRecommendations(threatLevel: CampaignThreatLevel): string[] {
    const base = ['Continue monitoring campaign evolution'];

    switch (threatLevel) {
      case 'CRITICAL':
        return [
          'Immediate executive notification required',
          'Activate crisis communications team',
          'Prepare legal response',
          'Coordinate with external stakeholders',
          ...base,
        ];
      case 'HIGH':
        return [
          'Brief leadership within 24 hours',
          'Prepare communications holding statement',
          'Assess legal implications',
          ...base,
        ];
      case 'MEDIUM':
        return [
          'Track campaign development',
          'Prepare response options',
          ...base,
        ];
      default:
        return base;
    }
  }

  private getRiskFactors(campaign: Campaign): string[] {
    const factors: string[] = [];

    if (campaign.actorIds.length > 10) {
      factors.push('Large coordinated actor network');
    }
    if (campaign.channelIds.length > 5) {
      factors.push('Multi-platform spread');
    }
    if (campaign.coordinationSignalIds.length > 5) {
      factors.push('Strong coordination signals');
    }

    return factors.length > 0 ? factors : ['Standard campaign indicators'];
  }

  private getMitigations(threatLevel: CampaignThreatLevel): string[] {
    switch (threatLevel) {
      case 'CRITICAL':
        return [
          'Immediate platform escalation',
          'Legal action consideration',
          'Public statement preparation',
        ];
      case 'HIGH':
        return [
          'Enhanced monitoring',
          'Stakeholder notification',
          'Response preparation',
        ];
      default:
        return ['Standard monitoring procedures'];
    }
  }

  private calculateBriefingConfidence(claims: Claim[]): number {
    if (claims.length === 0) return 0.5;

    const avgConfidence =
      claims.reduce((sum, c) => sum + c.verdictConfidence, 0) / claims.length;
    const verifiedRatio =
      claims.filter((c) => c.verdict !== 'UNVERIFIED').length / claims.length;

    return (avgConfidence * 0.7 + verifiedRatio * 0.3);
  }

  private renderBriefingTemplate(
    campaign: Campaign,
    summary: string,
    findings: string[],
    verdicts: Array<{ claimId: string; claimText: string; verdict: ClaimVerdict; confidence: number }>,
    actions: string[],
    citations: ArtifactCitation[],
  ): string {
    return BRIEFING_TEMPLATE
      .replace('{{CAMPAIGN_NAME}}', campaign.name)
      .replace(/{{THREAT_LEVEL}}/g, campaign.threatLevel)
      .replace('{{DATE}}', new Date().toISOString().split('T')[0])
      .replace('{{ANALYST}}', 'CogSec System')
      .replace('{{EXECUTIVE_SUMMARY}}', summary)
      .replace('{{KEY_FINDINGS}}', findings.map((f) => `- ${f}`).join('\n'))
      .replace(
        '{{CLAIM_VERDICTS}}',
        verdicts
          .map(
            (v) =>
              `| ${v.verdict} | ${v.claimText.substring(0, 100)}... | ${Math.round(v.confidence * 100)}% |`,
          )
          .join('\n'),
      )
      .replace('{{RECOMMENDED_ACTIONS}}', actions.map((a) => `1. ${a}`).join('\n'))
      .replace('{{RISK_FACTORS}}', this.getRiskFactors(campaign).map((f) => `- ${f}`).join('\n'))
      .replace('{{MITIGATIONS}}', this.getMitigations(campaign.threatLevel).map((m) => `- ${m}`).join('\n'))
      .replace(
        '{{CITATIONS}}',
        citations.map((c) => `- [${c.sourceType}] ${c.referenceText}`).join('\n'),
      )
      .replace('{{ORG_NAME}}', this.config.organizationName || 'IntelGraph')
      .replace('{{CONFIDENCE}}', Math.round(this.calculateBriefingConfidence([]) * 100) + '%');
  }

  private renderStakeholderTemplate(
    template: string,
    campaign: Campaign,
    stakeholder: string,
  ): string {
    return template
      .replace('{{CAMPAIGN_NAME}}', campaign.name)
      .replace('{{DATE}}', new Date().toISOString().split('T')[0])
      .replace('{{PRIORITY}}', campaign.threatLevel)
      .replace('{{SUMMARY}}', campaign.description || `${campaign.threatLevel} threat campaign detected`)
      .replace('{{ACTIONS}}', '- Review and respond as appropriate')
      .replace('{{MESSAGES}}', '- Key message pending review')
      .replace('{{TALKING_POINTS}}', '- Talking points pending review')
      .replace('{{RESPONSE_TEMPLATE}}', 'Response template pending review')
      .replace('{{IMMEDIATE_ACTIONS}}', '- Assess situation\n- Coordinate response')
      .replace('{{MONITORING_TASKS}}', '- Monitor campaign evolution')
      .replace('{{ESCALATION_PATH}}', '- Standard escalation procedures')
      .replace('{{DISTRIBUTION}}', 'Internal - Need to Know')
      .replace('{{KEY_POINTS}}', '- Situation is being actively monitored')
      .replace('{{CONTACT}}', 'Security Operations Team');
  }

  private renderTakedownTemplate(params: {
    platform: string;
    violationType: string;
    urls: string[];
    accountIds: string[];
    evidenceBundleId: string;
    legalBasis?: string;
    contactInfo?: string;
  }): string {
    return TAKEDOWN_TEMPLATE
      .replace('{{PLATFORM}}', params.platform)
      .replace('{{DATE}}', new Date().toISOString().split('T')[0])
      .replace('{{REFERENCE}}', `TKD-${Date.now()}`)
      .replace('{{VIOLATION_TYPE}}', params.violationType)
      .replace('{{URLS}}', params.urls.map((u) => `- ${u}`).join('\n'))
      .replace('{{ACCOUNT_IDS}}', params.accountIds.map((id) => `- ${id}`).join('\n'))
      .replace('{{EVIDENCE_SUMMARY}}', 'See attached evidence bundle')
      .replace('{{LEGAL_BASIS}}', params.legalBasis || 'Platform Terms of Service violation')
      .replace('{{CONTACT_INFO}}', params.contactInfo || 'trust-safety@organization.com')
      .replace('{{BUNDLE_ID}}', params.evidenceBundleId);
  }

  private inferStakeholder(title: string): 'legal' | 'pr' | 'ops' | 'internal' {
    const lower = title.toLowerCase();
    if (lower.includes('legal')) return 'legal';
    if (lower.includes('pr') || lower.includes('communication')) return 'pr';
    if (lower.includes('internal') || lower.includes('employee')) return 'internal';
    return 'ops';
  }

  private threatLevelToSeverity(level: CampaignThreatLevel): number {
    switch (level) {
      case 'CRITICAL':
        return 1;
      case 'HIGH':
        return 2;
      case 'MEDIUM':
        return 3;
      case 'LOW':
        return 4;
      default:
        return 5;
    }
  }

  // ==========================================================================
  // Persistence
  // ==========================================================================

  private async persistPlaybook(playbook: ResponsePlaybook): Promise<void> {
    const session = this.getSession();
    try {
      await session.run(
        `
        CREATE (p:CogSecPlaybook {
          id: $id,
          name: $name,
          description: $description,
          status: $status,
          campaignId: $campaignId,
          incidentId: $incidentId,
          assigneeId: $assigneeId,
          actions: $actions,
          priority: $priority,
          dueAt: $dueAt,
          createdBy: $createdBy,
          createdAt: datetime($createdAt),
          updatedAt: datetime($updatedAt)
        })
        `,
        {
          ...playbook,
          actions: JSON.stringify(playbook.actions),
        },
      );
    } finally {
      await session.close();
    }
  }

  private async updatePlaybookActions(
    playbookId: string,
    actions: ResponseAction[],
  ): Promise<void> {
    const session = this.getSession();
    try {
      await session.run(
        `
        MATCH (p:CogSecPlaybook {id: $playbookId})
        SET p.actions = $actions,
            p.updatedAt = datetime()
        `,
        { playbookId, actions: JSON.stringify(actions) },
      );
    } finally {
      await session.close();
    }
  }

  private async linkPlaybookToCampaign(
    playbookId: string,
    campaignId: string,
  ): Promise<void> {
    const session = this.getSession();
    try {
      await session.run(
        `
        MATCH (p:CogSecPlaybook {id: $playbookId})
        MATCH (c:CogSecCampaign {id: $campaignId})
        MERGE (c)-[:HAS_PLAYBOOK]->(p)
        SET c.responsePlaybookIds = coalesce(c.responsePlaybookIds, []) + $playbookId
        `,
        { playbookId, campaignId },
      );
    } finally {
      await session.close();
    }
  }

  private async persistArtifact(
    artifact: ResponseArtifact,
    campaignId: string,
  ): Promise<void> {
    const session = this.getSession();
    try {
      await session.run(
        `
        CREATE (a:CogSecArtifact {
          id: $id,
          type: $type,
          title: $title,
          content: $content,
          targetAudience: $targetAudience,
          citations: $citations,
          confidenceScore: $confidenceScore,
          generatedBy: $generatedBy,
          generatedAt: datetime($generatedAt),
          exportFormats: $exportFormats
        })
        WITH a
        MATCH (c:CogSecCampaign {id: $campaignId})
        MERGE (c)-[:HAS_ARTIFACT]->(a)
        `,
        {
          ...artifact,
          citations: JSON.stringify(artifact.citations),
          campaignId,
        },
      );
    } finally {
      await session.close();
    }
  }

  private async persistIncident(incident: CogSecIncident): Promise<void> {
    const session = this.getSession();
    try {
      await session.run(
        `
        CREATE (i:CogSecIncident {
          id: $id,
          name: $name,
          description: $description,
          status: $status,
          severity: $severity,
          campaignIds: $campaignIds,
          playbookIds: $playbookIds,
          leadAnalystId: $leadAnalystId,
          teamMemberIds: $teamMemberIds,
          timeline: $timeline,
          createdAt: datetime($createdAt),
          updatedAt: datetime($updatedAt)
        })
        `,
        {
          ...incident,
          timeline: JSON.stringify(incident.timeline),
        },
      );
    } finally {
      await session.close();
    }
  }

  private async linkCampaignToIncident(
    campaignId: string,
    incidentId: string,
  ): Promise<void> {
    const session = this.getSession();
    try {
      await session.run(
        `
        MATCH (c:CogSecCampaign {id: $campaignId})
        MATCH (i:CogSecIncident {id: $incidentId})
        SET c.incidentId = $incidentId
        MERGE (i)-[:INCLUDES_CAMPAIGN]->(c)
        `,
        { campaignId, incidentId },
      );
    } finally {
      await session.close();
    }
  }

  // ==========================================================================
  // Record Converters
  // ==========================================================================

  private recordToPlaybook(node: any): ResponsePlaybook {
    const props = node.properties || node;
    return {
      id: props.id,
      name: props.name,
      description: props.description,
      status: props.status,
      campaignId: props.campaignId,
      incidentId: props.incidentId,
      assigneeId: props.assigneeId,
      actions:
        typeof props.actions === 'string'
          ? JSON.parse(props.actions)
          : props.actions,
      priority: props.priority,
      dueAt: props.dueAt,
      createdBy: props.createdBy,
      createdAt: props.createdAt?.toString() || props.createdAt,
      updatedAt: props.updatedAt?.toString() || props.updatedAt,
    };
  }

  private recordToIncident(node: any): CogSecIncident {
    const props = node.properties || node;
    return {
      id: props.id,
      name: props.name,
      description: props.description,
      status: props.status,
      severity: props.severity,
      campaignIds: props.campaignIds || [],
      playbookIds: props.playbookIds || [],
      leadAnalystId: props.leadAnalystId,
      teamMemberIds: props.teamMemberIds || [],
      investigationId: props.investigationId,
      timeline:
        typeof props.timeline === 'string'
          ? JSON.parse(props.timeline)
          : props.timeline || [],
      createdAt: props.createdAt?.toString() || props.createdAt,
      updatedAt: props.updatedAt?.toString() || props.updatedAt,
      resolvedAt: props.resolvedAt?.toString(),
    };
  }

  private recordToClaim(node: any): Claim {
    const props = node.properties || node;
    return {
      id: props.id,
      canonicalText: props.canonicalText,
      originalText: props.originalText,
      language: props.language,
      sourceType: props.sourceType,
      sourceUrl: props.sourceUrl,
      firstObservedAt: props.firstObservedAt?.toString() || props.firstObservedAt,
      lastObservedAt: props.lastObservedAt?.toString() || props.lastObservedAt,
      verdict: props.verdict,
      verdictConfidence: props.verdictConfidence,
      evidenceIds: props.evidenceIds || [],
      relatedClaimIds: props.relatedClaimIds || [],
      narrativeIds: props.narrativeIds || [],
      actorIds: props.actorIds || [],
      channelIds: props.channelIds || [],
      embedding: props.embedding,
      entities:
        typeof props.entities === 'string'
          ? JSON.parse(props.entities)
          : props.entities || [],
      metadata:
        typeof props.metadata === 'string'
          ? JSON.parse(props.metadata)
          : props.metadata || {},
      createdAt: props.createdAt?.toString() || props.createdAt,
      updatedAt: props.updatedAt?.toString() || props.updatedAt,
    };
  }

  private recordToEvidence(node: any): Evidence {
    const props = node.properties || node;
    return {
      id: props.id,
      type: props.type,
      title: props.title,
      content: props.content,
      sourceUrl: props.sourceUrl,
      sourceCredibility: props.sourceCredibility,
      contentCredentialId: props.contentCredentialId,
      claimIds: props.claimIds || [],
      supportsVerdict: props.supportsVerdict,
      verified: props.verified,
      verifiedBy: props.verifiedBy,
      verifiedAt: props.verifiedAt?.toString(),
      verificationNotes: props.verificationNotes,
      capturedAt: props.capturedAt?.toString() || props.capturedAt,
      createdAt: props.createdAt?.toString() || props.createdAt,
      metadata:
        typeof props.metadata === 'string'
          ? JSON.parse(props.metadata)
          : props.metadata || {},
    };
  }

  /**
   * Health check
   */
  async healthCheck(): Promise<{ healthy: boolean; details: Record<string, unknown> }> {
    const session = this.getSession();
    try {
      await session.run('RETURN 1');
      return {
        healthy: true,
        details: {
          neo4jConnected: true,
          hasLLM: !!this.config.llmService,
          organization: this.config.organizationName,
        },
      };
    } catch (error: any) {
      return {
        healthy: false,
        details: {
          neo4jConnected: false,
          error: error instanceof Error ? error.message : 'Unknown',
        },
      };
    } finally {
      await session.close();
    }
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

let serviceInstance: ResponseOpsService | null = null;

export function createResponseOpsService(
  config: ResponseOpsConfig,
): ResponseOpsService {
  return new ResponseOpsService(config);
}

export function initializeResponseOpsService(
  config: ResponseOpsConfig,
): ResponseOpsService {
  serviceInstance = new ResponseOpsService(config);
  return serviceInstance;
}

export function getResponseOpsService(): ResponseOpsService {
  if (!serviceInstance) {
    throw new Error('Response ops service not initialized');
  }
  return serviceInstance;
}
