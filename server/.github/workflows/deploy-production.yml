# =============================================================================
# Summit v4.0 - Production Deployment Pipeline
# =============================================================================
name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v4.0.0)'
        required: true
        type: string
      skip_tests:
        description: 'Skip tests (emergency deployments only)'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY: summit/server
  EKS_CLUSTER_NAME: summit-production
  KUBERNETES_NAMESPACE: summit

concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  # ===========================================================================
  # Build and Test
  # ===========================================================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
      - uses: pnpm/action-setup@v4
        with:
          version: 10.0.0
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linting
        run: pnpm lint

      - name: Run type checking
        run: pnpm typecheck

      - name: Run unit tests
        run: pnpm test:unit --coverage
        env:
          CI: true

      - name: Run integration tests
        run: pnpm test:integration
        env:
          CI: true
          DATABASE_URL: postgresql://test:test@localhost:5432/summit_test
          REDIS_URL: redis://localhost:6379

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: false

      - name: Run security scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # ===========================================================================
  # Build Docker Image
  # ===========================================================================
  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: always() && (needs.build-and-test.result == 'success' || inputs.skip_tests)
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_SHA=${{ github.sha }}

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.version }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ===========================================================================
  # Deploy Infrastructure
  # ===========================================================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-image]
    environment: production
    outputs:
      cluster_endpoint: ${{ steps.terraform.outputs.cluster_endpoint }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: infrastructure/terraform
        run: |
          terraform init \
            -backend-config="bucket=summit-terraform-state" \
            -backend-config="key=production/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true" \
            -backend-config="dynamodb_table=summit-terraform-locks"

      - name: Terraform Plan
        working-directory: infrastructure/terraform
        run: |
          terraform plan \
            -var="environment=production" \
            -var="route53_zone_id=${{ secrets.ROUTE53_ZONE_ID }}" \
            -out=tfplan

      - name: Terraform Apply
        id: terraform
        working-directory: infrastructure/terraform
        run: |
          terraform apply -auto-approve tfplan
          echo "cluster_endpoint=$(terraform output -raw cluster_endpoint)" >> $GITHUB_OUTPUT

  # ===========================================================================
  # Deploy Application
  # ===========================================================================
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [build-image, deploy-infrastructure]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.KUBERNETES_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Kubernetes manifests
        run: |
          # Apply base manifests
          kubectl apply -f infrastructure/kubernetes/base/namespace.yaml
          kubectl apply -f infrastructure/kubernetes/base/configmap.yaml
          kubectl apply -f infrastructure/kubernetes/base/database.yaml
          kubectl apply -f infrastructure/kubernetes/base/api-deployment.yaml
          kubectl apply -f infrastructure/kubernetes/base/ingress.yaml

      - name: Update deployment image
        run: |
          kubectl set image deployment/summit-api \
            summit-api=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-image.outputs.image_tag }} \
            -n ${{ env.KUBERNETES_NAMESPACE }}

      - name: Wait for deployment rollout
        run: |
          kubectl rollout status deployment/summit-api \
            -n ${{ env.KUBERNETES_NAMESPACE }} \
            --timeout=600s

      - name: Verify deployment
        run: |
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod \
            -l app=summit-api \
            -n ${{ env.KUBERNETES_NAMESPACE }} \
            --timeout=300s

          # Get deployment status
          kubectl get deployment summit-api -n ${{ env.KUBERNETES_NAMESPACE }}
          kubectl get pods -l app=summit-api -n ${{ env.KUBERNETES_NAMESPACE }}

  # ===========================================================================
  # Post-Deployment Verification
  # ===========================================================================
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-application]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Run health checks
        run: |
          API_URL="https://api.summit.io"

          echo "Checking API health..."
          for i in {1..10}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/health/ready")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Health check passed!"
              break
            fi
            echo "Attempt $i: HTTP Status $HTTP_STATUS, retrying..."
            sleep 10
          done

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Health check failed!"
            exit 1
          fi

      - name: Run smoke tests
        run: |
          API_URL="https://api.summit.io"

          echo "Running smoke tests..."

          # Test API version endpoint
          VERSION=$(curl -s "$API_URL/api/version" | jq -r '.version')
          echo "API Version: $VERSION"

          # Test v4 features
          echo "Testing v4 feature flags..."
          FEATURES=$(curl -s "$API_URL/api/v4/features")
          echo "Features: $FEATURES"

      - name: Verify metrics endpoint
        run: |
          kubectl port-forward svc/summit-api 9090:9090 -n ${{ env.KUBERNETES_NAMESPACE }} &
          sleep 5
          curl -s http://localhost:9090/metrics | head -50

  # ===========================================================================
  # Notify
  # ===========================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    if: always()

    steps:
      - name: Notify Slack on success
        if: needs.verify-deployment.result == 'success'
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Summit v4.0 Deployed to Production"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ needs.build-image.outputs.image_tag }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\n:white_check_mark: Success"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "<https://api.summit.io/health|View API Health> | <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: needs.verify-deployment.result == 'failure'
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Production Deployment Failed"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ needs.build-image.outputs.image_tag }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\n:x: Failed"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow Logs>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ===========================================================================
  # Rollback (Manual Trigger)
  # ===========================================================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: failure()
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Rollback deployment
        run: |
          echo "Rolling back deployment..."
          kubectl rollout undo deployment/summit-api -n ${{ env.KUBERNETES_NAMESPACE }}
          kubectl rollout status deployment/summit-api -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s

      - name: Notify rollback
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": ":warning: Summit v4.0 deployment rolled back due to failure. Please investigate."
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
