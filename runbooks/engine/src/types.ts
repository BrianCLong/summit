/**
 * Core type definitions for the Runbook Engine
 *
 * The Runbook Engine executes workflows as DAGs (Directed Acyclic Graphs)
 * with typed inputs/outputs, retry policies, and comprehensive logging.
 */

/**
 * Status of a runbook execution or individual step
 */
export enum ExecutionStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  RETRYING = 'retrying',
  CANCELLED = 'cancelled',
  PAUSED = 'paused',
  AWAITING_APPROVAL = 'awaiting_approval',
  AWAITING_EVENT = 'awaiting_event',
}

/**
 * Retry policy configuration for steps
 */
export interface RetryPolicy {
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Initial delay in milliseconds */
  initialDelayMs: number;
  /** Maximum delay in milliseconds */
  maxDelayMs: number;
  /** Backoff multiplier (for exponential backoff) */
  backoffMultiplier: number;
  /** Whether to retry on specific error types only */
  retryableErrors?: string[];
}

/**
 * Legal and compliance context for runbook execution
 */
export interface LegalBasis {
  /** Legal authority or justification (e.g., "TOS_VIOLATION", "COURT_ORDER") */
  authority: string;
  /** Case or investigation ID */
  caseId?: string;
  /** Data retention period in days */
  retentionDays?: number;
  /** Data handling classification (e.g., "SENSITIVE", "PUBLIC") */
  classification: string;
  /** Authorized investigators/analysts */
  authorizedUsers: string[];
}

/**
 * Data scope and assumptions for a runbook execution
 */
export interface ExecutionContext {
  /** Legal basis for this execution */
  legalBasis: LegalBasis;
  /** Time range for data analysis */
  timeRange?: {
    startTime: Date;
    endTime: Date;
  };
  /** Geographic scope (if applicable) */
  geographicScope?: string[];
  /** Tenant or organization ID */
  tenantId: string;
  /** User who initiated the runbook */
  initiatedBy: string;
  /** Explicit assumptions made for this execution */
  assumptions: string[];
}

/**
 * Typed input/output for steps
 */
export interface StepIO {
  /** Input data schema (JSON Schema compatible) */
  schema: Record<string, any>;
  /** Actual data */
  data: Record<string, any>;
}

/**
 * Evidence link for traceability
 */
export interface Evidence {
  /** Unique evidence identifier */
  id: string;
  /** Type of evidence (e.g., "entity", "relationship", "document") */
  type: string;
  /** Reference to source data */
  sourceRef: string;
  /** Timestamp when evidence was collected */
  timestamp: Date;
  /** Confidence score (0-1) */
  confidence: number;
}

/**
 * Structured log entry for runbook execution
 */
export interface RunbookLogEntry {
  /** Unique log entry ID */
  id: string;
  /** Timestamp */
  timestamp: Date;
  /** Log level */
  level: 'debug' | 'info' | 'warn' | 'error';
  /** Step ID that generated this log */
  stepId: string;
  /** Runbook execution ID */
  executionId: string;
  /** Log message */
  message: string;
  /** Additional metadata */
  metadata?: Record<string, any>;
  /** Related evidence IDs */
  evidenceIds?: string[];
  /** Assumptions logged at this point */
  assumptions?: string[];
  /** Data scope at this point */
  dataScope?: string;
}

/**
 * Approval decision
 */
export interface ApprovalDecision {
  /** Approver user ID */
  approverId: string;
  /** Decision: approved or rejected */
  decision: 'approved' | 'rejected';
  /** Timestamp */
  timestamp: Date;
  /** Comments */
  comments?: string;
}

/**
 * Step execution result
 */
export interface StepResult {
  /** Step ID */
  stepId: string;
  /** Execution status */
  status: ExecutionStatus;
  /** Output data */
  output?: StepIO;
  /** Error if failed */
  error?: Error;
  /** Start time */
  startTime: Date;
  /** End time */
  endTime?: Date;
  /** Duration in milliseconds */
  durationMs?: number;
  /** Retry attempt number */
  attemptNumber: number;
  /** Evidence generated by this step */
  evidence: Evidence[];
  /** Logs generated during execution */
  logs: RunbookLogEntry[];
  /** Approval decisions (for approval steps) */
  approvals?: ApprovalDecision[];
  /** Was conditional execution skipped */
  skipped?: boolean;
  /** Reason for skip */
  skipReason?: string;
}

/**
 * Condition for conditional execution
 */
export interface Condition {
  /** Field to evaluate (JSONPath or step output reference) */
  field: string;
  /** Operator (eq, ne, gt, lt, gte, lte, in, contains, exists) */
  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte' | 'in' | 'contains' | 'exists';
  /** Value to compare against */
  value?: any;
}

/**
 * Approval configuration for human-in-the-loop steps
 */
export interface ApprovalConfig {
  /** Required approvers (user IDs or roles) */
  approvers: string[];
  /** Minimum number of approvals required */
  minApprovals: number;
  /** Timeout in milliseconds */
  timeoutMs: number;
  /** Action on timeout: 'fail', 'approve', 'reject' */
  timeoutAction: 'fail' | 'approve' | 'reject';
  /** Approval prompt/instructions */
  prompt?: string;
}

/**
 * Loop configuration
 */
export interface LoopConfig {
  /** Maximum iterations allowed */
  maxIterations: number;
  /** Current iteration (runtime tracking) */
  currentIteration?: number;
  /** Loop over this field (array or iterator) */
  iterateOver?: string;
  /** Condition to continue looping */
  continueWhile?: Condition;
}

/**
 * Definition of a single step in a runbook
 */
export interface StepDefinition {
  /** Unique step identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Step description */
  description?: string;
  /** Step type (determines which executor to use) */
  type: string;
  /** Input schema */
  inputSchema: Record<string, any>;
  /** Output schema */
  outputSchema: Record<string, any>;
  /** Dependencies - IDs of steps that must complete first */
  dependsOn: string[];
  /** Configuration for this step */
  config: Record<string, any>;
  /** Retry policy */
  retryPolicy: RetryPolicy;
  /** Timeout in milliseconds */
  timeoutMs?: number;
  /** Conditional execution - only run if condition is true */
  condition?: Condition;
  /** Approval configuration (for human-approval steps) */
  approvalConfig?: ApprovalConfig;
  /** Loop configuration (for iterative steps) */
  loopConfig?: LoopConfig;
}

/**
 * Runbook template (reusable definition)
 */
export interface RunbookTemplate {
  /** Unique template identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Version */
  version: string;
  /** Description */
  description: string;
  /** List of steps forming the DAG */
  steps: StepDefinition[];
  /** Default retry policy for steps */
  defaultRetryPolicy: RetryPolicy;
  /** Global timeout in milliseconds */
  globalTimeoutMs?: number;
  /** Metadata */
  metadata?: Record<string, any>;
  /** Maximum execution depth (for nested runbooks) */
  maxDepth?: number;
  /** Created timestamp */
  createdAt?: Date;
  /** Updated timestamp */
  updatedAt?: Date;
  /** Created by user */
  createdBy?: string;
}

/**
 * Complete runbook definition (DAG) - alias for backward compatibility
 */
export type RunbookDefinition = RunbookTemplate;

/**
 * Runbook execution instance (runtime state)
 */
export interface RunbookExecution {
  /** Unique execution ID */
  id: string;
  /** Runbook template/definition ID */
  runbookId: string;
  /** Runbook version */
  runbookVersion: string;
  /** Overall status */
  status: ExecutionStatus;
  /** Execution context */
  context: ExecutionContext;
  /** Initial input parameters */
  input: Record<string, any>;
  /** Final output (when completed) */
  output?: Record<string, any>;
  /** Step results */
  stepResults: Map<string, StepResult>;
  /** Start time */
  startTime: Date;
  /** End time */
  endTime?: Date;
  /** Duration in milliseconds */
  durationMs?: number;
  /** All logs */
  logs: RunbookLogEntry[];
  /** All evidence collected */
  evidence: Evidence[];
  /** Error if failed */
  error?: Error;
  /** Whether this is a replay of a previous execution */
  isReplay: boolean;
  /** Original execution ID if this is a replay */
  originalExecutionId?: string;
  /** Paused at step ID */
  pausedAtStep?: string;
  /** Paused at timestamp */
  pausedAt?: Date;
  /** Cancelled by user */
  cancelledBy?: string;
  /** Cancellation reason */
  cancellationReason?: string;
  /** Execution depth (for nested runbooks) */
  depth?: number;
  /** Parent execution ID (if nested) */
  parentExecutionId?: string;
}

/**
 * Step executor interface - implement this for each step type
 */
export interface StepExecutor {
  /** Step type this executor handles */
  readonly type: string;

  /**
   * Execute a step
   * @param step Step definition
   * @param input Input data
   * @param context Execution context
   * @returns Step result
   */
  execute(
    step: StepDefinition,
    input: StepIO,
    context: ExecutionContext
  ): Promise<StepResult>;

  /**
   * Validate step configuration
   * @param step Step definition
   * @returns true if valid, throws error otherwise
   */
  validate(step: StepDefinition): boolean;
}

/**
 * Runbook engine configuration
 */
export interface EngineConfig {
  /** Maximum concurrent steps */
  maxConcurrentSteps: number;
  /** Default retry policy */
  defaultRetryPolicy: RetryPolicy;
  /** Storage backend for state persistence */
  storageBackend: 'memory' | 'postgres' | 'redis';
  /** Storage connection config */
  storageConfig?: Record<string, any>;
  /** Enable detailed execution logging */
  detailedLogging: boolean;
}

/**
 * Query parameters for fetching logs
 */
export interface LogQuery {
  /** Execution ID */
  executionId: string;
  /** Filter by step ID */
  stepId?: string;
  /** Filter by log level */
  level?: string;
  /** Start time */
  startTime?: Date;
  /** End time */
  endTime?: Date;
  /** Limit results */
  limit?: number;
  /** Offset for pagination */
  offset?: number;
}
