/**
 * Core type definitions for the Runbook Engine
 *
 * The Runbook Engine executes workflows as DAGs (Directed Acyclic Graphs)
 * with typed inputs/outputs, retry policies, and comprehensive logging.
 */

/**
 * Status of a runbook execution or individual step
 */
export enum ExecutionStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  RETRYING = 'retrying',
  CANCELLED = 'cancelled',
}

/**
 * Retry policy configuration for steps
 */
export interface RetryPolicy {
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Initial delay in milliseconds */
  initialDelayMs: number;
  /** Maximum delay in milliseconds */
  maxDelayMs: number;
  /** Backoff multiplier (for exponential backoff) */
  backoffMultiplier: number;
  /** Whether to retry on specific error types only */
  retryableErrors?: string[];
}

/**
 * Legal and compliance context for runbook execution
 */
export interface LegalBasis {
  /** Legal authority or justification (e.g., "TOS_VIOLATION", "COURT_ORDER") */
  authority: string;
  /** Case or investigation ID */
  caseId?: string;
  /** Data retention period in days */
  retentionDays?: number;
  /** Data handling classification (e.g., "SENSITIVE", "PUBLIC") */
  classification: string;
  /** Authorized investigators/analysts */
  authorizedUsers: string[];
}

/**
 * Data scope and assumptions for a runbook execution
 */
export interface ExecutionContext {
  /** Legal basis for this execution */
  legalBasis: LegalBasis;
  /** Time range for data analysis */
  timeRange?: {
    startTime: Date;
    endTime: Date;
  };
  /** Geographic scope (if applicable) */
  geographicScope?: string[];
  /** Tenant or organization ID */
  tenantId: string;
  /** User who initiated the runbook */
  initiatedBy: string;
  /** Explicit assumptions made for this execution */
  assumptions: string[];
}

/**
 * Typed input/output for steps
 */
export interface StepIO {
  /** Input data schema (JSON Schema compatible) */
  schema: Record<string, any>;
  /** Actual data */
  data: Record<string, any>;
}

/**
 * Evidence link for traceability
 */
export interface Evidence {
  /** Unique evidence identifier */
  id: string;
  /** Type of evidence (e.g., "entity", "relationship", "document") */
  type: string;
  /** Reference to source data */
  sourceRef: string;
  /** Timestamp when evidence was collected */
  timestamp: Date;
  /** Confidence score (0-1) */
  confidence: number;
}

/**
 * Structured log entry for runbook execution
 */
export interface RunbookLogEntry {
  /** Unique log entry ID */
  id: string;
  /** Timestamp */
  timestamp: Date;
  /** Log level */
  level: 'debug' | 'info' | 'warn' | 'error';
  /** Step ID that generated this log */
  stepId: string;
  /** Runbook execution ID */
  executionId: string;
  /** Log message */
  message: string;
  /** Additional metadata */
  metadata?: Record<string, any>;
  /** Related evidence IDs */
  evidenceIds?: string[];
  /** Assumptions logged at this point */
  assumptions?: string[];
  /** Data scope at this point */
  dataScope?: string;
}

/**
 * Step execution result
 */
export interface StepResult {
  /** Step ID */
  stepId: string;
  /** Execution status */
  status: ExecutionStatus;
  /** Output data */
  output?: StepIO;
  /** Error if failed */
  error?: Error;
  /** Start time */
  startTime: Date;
  /** End time */
  endTime?: Date;
  /** Duration in milliseconds */
  durationMs?: number;
  /** Retry attempt number */
  attemptNumber: number;
  /** Evidence generated by this step */
  evidence: Evidence[];
  /** Logs generated during execution */
  logs: RunbookLogEntry[];
}

/**
 * Definition of a single step in a runbook
 */
export interface StepDefinition {
  /** Unique step identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Step description */
  description?: string;
  /** Step type (determines which executor to use) */
  type: string;
  /** Input schema */
  inputSchema: Record<string, any>;
  /** Output schema */
  outputSchema: Record<string, any>;
  /** Dependencies - IDs of steps that must complete first */
  dependsOn: string[];
  /** Configuration for this step */
  config: Record<string, any>;
  /** Retry policy */
  retryPolicy: RetryPolicy;
  /** Timeout in milliseconds */
  timeoutMs?: number;
}

/**
 * Complete runbook definition (DAG)
 */
export interface RunbookDefinition {
  /** Unique runbook identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Version */
  version: string;
  /** Description */
  description: string;
  /** List of steps forming the DAG */
  steps: StepDefinition[];
  /** Default retry policy for steps */
  defaultRetryPolicy: RetryPolicy;
  /** Global timeout in milliseconds */
  globalTimeoutMs?: number;
  /** Metadata */
  metadata?: Record<string, any>;
}

/**
 * Runbook execution state
 */
export interface RunbookExecution {
  /** Unique execution ID */
  id: string;
  /** Runbook definition ID */
  runbookId: string;
  /** Runbook version */
  runbookVersion: string;
  /** Overall status */
  status: ExecutionStatus;
  /** Execution context */
  context: ExecutionContext;
  /** Initial input parameters */
  input: Record<string, any>;
  /** Final output (when completed) */
  output?: Record<string, any>;
  /** Step results */
  stepResults: Map<string, StepResult>;
  /** Start time */
  startTime: Date;
  /** End time */
  endTime?: Date;
  /** Duration in milliseconds */
  durationMs?: number;
  /** All logs */
  logs: RunbookLogEntry[];
  /** All evidence collected */
  evidence: Evidence[];
  /** Error if failed */
  error?: Error;
  /** Whether this is a replay of a previous execution */
  isReplay: boolean;
  /** Original execution ID if this is a replay */
  originalExecutionId?: string;
}

/**
 * Step executor interface - implement this for each step type
 */
export interface StepExecutor {
  /** Step type this executor handles */
  readonly type: string;

  /**
   * Execute a step
   * @param step Step definition
   * @param input Input data
   * @param context Execution context
   * @returns Step result
   */
  execute(
    step: StepDefinition,
    input: StepIO,
    context: ExecutionContext
  ): Promise<StepResult>;

  /**
   * Validate step configuration
   * @param step Step definition
   * @returns true if valid, throws error otherwise
   */
  validate(step: StepDefinition): boolean;
}

/**
 * Runbook engine configuration
 */
export interface EngineConfig {
  /** Maximum concurrent steps */
  maxConcurrentSteps: number;
  /** Default retry policy */
  defaultRetryPolicy: RetryPolicy;
  /** Storage backend for state persistence */
  storageBackend: 'memory' | 'postgres' | 'redis';
  /** Storage connection config */
  storageConfig?: Record<string, any>;
  /** Enable detailed execution logging */
  detailedLogging: boolean;
}

/**
 * Query parameters for fetching logs
 */
export interface LogQuery {
  /** Execution ID */
  executionId: string;
  /** Filter by step ID */
  stepId?: string;
  /** Filter by log level */
  level?: string;
  /** Start time */
  startTime?: Date;
  /** End time */
  endTime?: Date;
  /** Limit results */
  limit?: number;
  /** Offset for pagination */
  offset?: number;
}
