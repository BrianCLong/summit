/**
 * Core type definitions for the Runbook Engine
 *
 * The Runbook Engine executes workflows as DAGs (Directed Acyclic Graphs)
 * with typed inputs/outputs, retry policies, and comprehensive logging.
 */

/**
 * Status of a runbook execution or individual step
 */
export enum ExecutionStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  RETRYING = 'retrying',
  CANCELLED = 'cancelled',
  PAUSED = 'paused',
  WAITING_APPROVAL = 'waiting_approval',
  WAITING_EVENT = 'waiting_event',
  SKIPPED = 'skipped',
}

/**
 * Retry policy configuration for steps
 */
export interface RetryPolicy {
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Initial delay in milliseconds */
  initialDelayMs: number;
  /** Maximum delay in milliseconds */
  maxDelayMs: number;
  /** Backoff multiplier (for exponential backoff) */
  backoffMultiplier: number;
  /** Whether to retry on specific error types only */
  retryableErrors?: string[];
}

/**
 * Legal and compliance context for runbook execution
 */
export interface LegalBasis {
  /** Legal authority or justification (e.g., "TOS_VIOLATION", "COURT_ORDER") */
  authority: string;
  /** Case or investigation ID */
  caseId?: string;
  /** Data retention period in days */
  retentionDays?: number;
  /** Data handling classification (e.g., "SENSITIVE", "PUBLIC") */
  classification: string;
  /** Authorized investigators/analysts */
  authorizedUsers: string[];
}

/**
 * Data scope and assumptions for a runbook execution
 */
export interface ExecutionContext {
  /** Legal basis for this execution */
  legalBasis: LegalBasis;
  /** Time range for data analysis */
  timeRange?: {
    startTime: Date;
    endTime: Date;
  };
  /** Geographic scope (if applicable) */
  geographicScope?: string[];
  /** Tenant or organization ID */
  tenantId: string;
  /** User who initiated the runbook */
  initiatedBy: string;
  /** Explicit assumptions made for this execution */
  assumptions: string[];
}

/**
 * Typed input/output for steps
 */
export interface StepIO {
  /** Input data schema (JSON Schema compatible) */
  schema: Record<string, any>;
  /** Actual data */
  data: Record<string, any>;
}

/**
 * Evidence link for traceability
 */
export interface Evidence {
  /** Unique evidence identifier */
  id: string;
  /** Type of evidence (e.g., "entity", "relationship", "document") */
  type: string;
  /** Reference to source data */
  sourceRef: string;
  /** Timestamp when evidence was collected */
  timestamp: Date;
  /** Confidence score (0-1) */
  confidence: number;
}

/**
 * Structured log entry for runbook execution
 */
export interface RunbookLogEntry {
  /** Unique log entry ID */
  id: string;
  /** Timestamp */
  timestamp: Date;
  /** Log level */
  level: 'debug' | 'info' | 'warn' | 'error';
  /** Step ID that generated this log */
  stepId: string;
  /** Runbook execution ID */
  executionId: string;
  /** Log message */
  message: string;
  /** Additional metadata */
  metadata?: Record<string, any>;
  /** Related evidence IDs */
  evidenceIds?: string[];
  /** Assumptions logged at this point */
  assumptions?: string[];
  /** Data scope at this point */
  dataScope?: string;
}

/**
 * Step execution result
 */
export interface StepResult {
  /** Step ID */
  stepId: string;
  /** Execution status */
  status: ExecutionStatus;
  /** Output data */
  output?: StepIO;
  /** Error if failed */
  error?: Error;
  /** Start time */
  startTime: Date;
  /** End time */
  endTime?: Date;
  /** Duration in milliseconds */
  durationMs?: number;
  /** Retry attempt number */
  attemptNumber: number;
  /** Evidence generated by this step */
  evidence: Evidence[];
  /** Logs generated during execution */
  logs: RunbookLogEntry[];
}

/**
 * Definition of a single step in a runbook
 */
export interface StepDefinition {
  /** Unique step identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Step description */
  description?: string;
  /** Step type (determines which executor to use) */
  type: string;
  /** Input schema */
  inputSchema: Record<string, any>;
  /** Output schema */
  outputSchema: Record<string, any>;
  /** Dependencies - IDs of steps that must complete first */
  dependsOn: string[];
  /** Configuration for this step */
  config: Record<string, any>;
  /** Retry policy */
  retryPolicy: RetryPolicy;
  /** Timeout in milliseconds */
  timeoutMs?: number;
}

/**
 * Complete runbook definition (DAG)
 */
export interface RunbookDefinition {
  /** Unique runbook identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Version */
  version: string;
  /** Description */
  description: string;
  /** List of steps forming the DAG */
  steps: StepDefinition[];
  /** Default retry policy for steps */
  defaultRetryPolicy: RetryPolicy;
  /** Global timeout in milliseconds */
  globalTimeoutMs?: number;
  /** Metadata */
  metadata?: Record<string, any>;
}

/**
 * Runbook execution state
 */
export interface RunbookExecution {
  /** Unique execution ID */
  id: string;
  /** Runbook definition ID */
  runbookId: string;
  /** Runbook version */
  runbookVersion: string;
  /** Overall status */
  status: ExecutionStatus;
  /** Execution context */
  context: ExecutionContext;
  /** Initial input parameters */
  input: Record<string, any>;
  /** Final output (when completed) */
  output?: Record<string, any>;
  /** Step results */
  stepResults: Map<string, StepResult>;
  /** Start time */
  startTime: Date;
  /** End time */
  endTime?: Date;
  /** Duration in milliseconds */
  durationMs?: number;
  /** All logs */
  logs: RunbookLogEntry[];
  /** All evidence collected */
  evidence: Evidence[];
  /** Error if failed */
  error?: Error;
  /** Whether this is a replay of a previous execution */
  isReplay: boolean;
  /** Original execution ID if this is a replay */
  originalExecutionId?: string;
}

/**
 * Step executor interface - implement this for each step type
 */
export interface StepExecutor {
  /** Step type this executor handles */
  readonly type: string;

  /**
   * Execute a step
   * @param step Step definition
   * @param input Input data
   * @param context Execution context
   * @returns Step result
   */
  execute(
    step: StepDefinition,
    input: StepIO,
    context: ExecutionContext
  ): Promise<StepResult>;

  /**
   * Validate step configuration
   * @param step Step definition
   * @returns true if valid, throws error otherwise
   */
  validate(step: StepDefinition): boolean;
}

/**
 * Runbook engine configuration
 */
export interface EngineConfig {
  /** Maximum concurrent steps */
  maxConcurrentSteps: number;
  /** Default retry policy */
  defaultRetryPolicy: RetryPolicy;
  /** Storage backend for state persistence */
  storageBackend: 'memory' | 'postgres' | 'redis';
  /** Storage connection config */
  storageConfig?: Record<string, any>;
  /** Enable detailed execution logging */
  detailedLogging: boolean;
}

/**
 * Query parameters for fetching logs
 */
export interface LogQuery {
  /** Execution ID */
  executionId: string;
  /** Filter by step ID */
  stepId?: string;
  /** Filter by log level */
  level?: string;
  /** Start time */
  startTime?: Date;
  /** End time */
  endTime?: Date;
  /** Limit results */
  limit?: number;
  /** Offset for pagination */
  offset?: number;
}

/**
 * Condition for conditional branching
 */
export interface Condition {
  /** Left operand (can be a reference to previous step output) */
  left: string;
  /** Comparison operator */
  operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'not_in' | 'exists' | 'not_exists';
  /** Right operand */
  right?: any;
}

/**
 * Conditional branch definition
 */
export interface ConditionalBranch {
  /** Condition to evaluate */
  condition: Condition;
  /** Steps to execute if condition is true */
  steps: StepDefinition[];
}

/**
 * Loop configuration
 */
export interface LoopConfig {
  /** Type of loop */
  type: 'for_each' | 'while' | 'count';
  /** For for_each: array to iterate over */
  collection?: string;
  /** For while: condition to check */
  condition?: Condition;
  /** For count: number of iterations */
  count?: number;
  /** Maximum iterations (safety limit) */
  maxIterations: number;
  /** Steps to execute in each iteration */
  steps: StepDefinition[];
}

/**
 * Approval request
 */
export interface ApprovalRequest {
  /** Unique approval ID */
  id: string;
  /** Execution ID */
  executionId: string;
  /** Step ID */
  stepId: string;
  /** Approval message/prompt */
  message: string;
  /** Required approvers (user IDs or roles) */
  requiredApprovers: string[];
  /** Minimum number of approvals required */
  minApprovals: number;
  /** Timeout in milliseconds */
  timeoutMs?: number;
  /** Requested at */
  requestedAt: Date;
  /** Expires at */
  expiresAt?: Date;
  /** Approvals received */
  approvals: Approval[];
  /** Status */
  status: 'pending' | 'approved' | 'rejected' | 'timeout';
}

/**
 * Individual approval
 */
export interface Approval {
  /** Approver user ID */
  approverId: string;
  /** Approval decision */
  decision: 'approve' | 'reject';
  /** Comment */
  comment?: string;
  /** Approved at */
  approvedAt: Date;
}

/**
 * Event to wait for
 */
export interface EventConfig {
  /** Event source (service name) */
  source: string;
  /** Event type */
  type: string;
  /** Correlation ID to match events */
  correlationId: string;
  /** Timeout in milliseconds */
  timeoutMs: number;
  /** Filter conditions for event payload */
  filter?: Record<string, any>;
}

/**
 * Service call configuration
 */
export interface ServiceCallConfig {
  /** Service name or URL */
  service: string;
  /** HTTP method or gRPC method */
  method: string;
  /** Request payload */
  payload?: Record<string, any>;
  /** Headers (for HTTP) */
  headers?: Record<string, string>;
  /** Timeout in milliseconds */
  timeoutMs: number;
  /** Idempotency key (for safe retries) */
  idempotencyKey?: string;
  /** Expected response status codes */
  expectedStatusCodes?: number[];
}

/**
 * Extended step definition with control flow support
 */
export interface ExtendedStepDefinition extends StepDefinition {
  /** Conditional branches (if/else) */
  branches?: ConditionalBranch[];
  /** Loop configuration */
  loop?: LoopConfig;
  /** Approval configuration */
  approval?: {
    message: string;
    requiredApprovers: string[];
    minApprovals?: number;
    timeoutMs?: number;
  };
  /** Event configuration */
  event?: EventConfig;
  /** Service call configuration */
  serviceCall?: ServiceCallConfig;
}

/**
 * Runbook template (reusable definition)
 */
export interface RunbookTemplate {
  /** Template ID */
  id: string;
  /** Template name */
  name: string;
  /** Template version */
  version: string;
  /** Description */
  description: string;
  /** Author */
  author?: string;
  /** Tags for categorization */
  tags?: string[];
  /** Template definition */
  definition: RunbookDefinition;
  /** Created at */
  createdAt: Date;
  /** Updated at */
  updatedAt: Date;
  /** Is active */
  isActive: boolean;
}

/**
 * Runbook instance (specific execution)
 */
export interface RunbookInstance {
  /** Instance ID (same as execution ID) */
  id: string;
  /** Template ID */
  templateId: string;
  /** Execution state */
  execution: RunbookExecution;
  /** Control operations */
  control: {
    canPause: boolean;
    canResume: boolean;
    canCancel: boolean;
  };
}
