/**
 * Zero Trust Vulnerability Scanner
 *
 * Automated security scanning and vulnerability detection
 * for the IntelGraph zero-trust architecture.
 */

import { EventEmitter } from 'events';
import * as crypto from 'crypto';

// Types
interface Vulnerability {
  id: string;
  cveId?: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  cvssScore?: number;
  cvssVector?: string;
  affectedComponent: string;
  affectedVersions: string[];
  fixedVersions?: string[];
  references: string[];
  detectedAt: Date;
  status: 'open' | 'mitigated' | 'false-positive' | 'accepted';
  zeroTrustImpact: ZeroTrustImpact;
}

interface ZeroTrustImpact {
  affectsIdentity: boolean;
  affectsNetwork: boolean;
  affectsData: boolean;
  affectsPolicy: boolean;
  breachRisk: 'critical' | 'high' | 'medium' | 'low';
  lateralMovementRisk: boolean;
  privilegeEscalationRisk: boolean;
}

interface ScanTarget {
  type: 'container' | 'policy' | 'config' | 'network' | 'secret' | 'code';
  name: string;
  location: string;
  metadata: Record<string, string>;
}

interface ScanResult {
  id: string;
  scanType: string;
  target: ScanTarget;
  startTime: Date;
  endTime: Date;
  vulnerabilities: Vulnerability[];
  misconfigurations: Misconfiguration[];
  secrets: SecretFinding[];
  summary: ScanSummary;
}

interface Misconfiguration {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  category: string;
  resource: string;
  remediation: string;
  zeroTrustViolation: boolean;
}

interface SecretFinding {
  id: string;
  type: string;
  location: string;
  lineNumber?: number;
  severity: 'critical' | 'high' | 'medium' | 'low';
  redactedValue: string;
}

interface ScanSummary {
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  misconfigurationCount: number;
  secretsFound: number;
  zeroTrustScore: number;
}

interface ScanPolicy {
  id: string;
  name: string;
  enabled: boolean;
  scanTypes: string[];
  schedule?: string;
  thresholds: {
    failOnCritical: boolean;
    failOnHigh: boolean;
    maxCritical: number;
    maxHigh: number;
    minZeroTrustScore: number;
  };
  excludePatterns: string[];
}

// Configuration
const config = {
  scanInterval: 6 * 60 * 60 * 1000, // 6 hours
  concurrentScans: 5,
  scanTimeout: 30 * 60 * 1000, // 30 minutes
  retentionDays: 90,
};

/**
 * Container Scanner
 * Scans container images for vulnerabilities
 */
class ContainerScanner {
  async scan(target: ScanTarget): Promise<{
    vulnerabilities: Vulnerability[];
    misconfigurations: Misconfiguration[];
  }> {
    console.log(`[ContainerScanner] Scanning ${target.name}`);

    const vulnerabilities: Vulnerability[] = [];
    const misconfigurations: Misconfiguration[] = [];

    // Simulate Trivy-like container scanning
    // In production, this would integrate with actual scanning tools

    // Check for common container vulnerabilities
    const commonVulns = this.checkCommonVulnerabilities(target);
    vulnerabilities.push(...commonVulns);

    // Check for misconfigurations
    const configIssues = this.checkContainerConfigurations(target);
    misconfigurations.push(...configIssues);

    return { vulnerabilities, misconfigurations };
  }

  private checkCommonVulnerabilities(target: ScanTarget): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Simulate vulnerability findings
    if (target.metadata.baseImage?.includes('alpine')) {
      // Example: Check for known Alpine vulnerabilities
      vulnerabilities.push({
        id: crypto.randomUUID(),
        cveId: 'CVE-2023-XXXX',
        title: 'Example Alpine Vulnerability',
        description: 'Simulated vulnerability for demonstration',
        severity: 'medium',
        cvssScore: 5.5,
        affectedComponent: 'alpine-base',
        affectedVersions: ['3.18.0'],
        fixedVersions: ['3.18.5'],
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-XXXX'],
        detectedAt: new Date(),
        status: 'open',
        zeroTrustImpact: {
          affectsIdentity: false,
          affectsNetwork: false,
          affectsData: false,
          affectsPolicy: false,
          breachRisk: 'low',
          lateralMovementRisk: false,
          privilegeEscalationRisk: false,
        },
      });
    }

    return vulnerabilities;
  }

  private checkContainerConfigurations(target: ScanTarget): Misconfiguration[] {
    const misconfigurations: Misconfiguration[] = [];

    // Check for running as root
    if (target.metadata.runAsRoot === 'true') {
      misconfigurations.push({
        id: crypto.randomUUID(),
        title: 'Container Running as Root',
        description: 'Container is configured to run as root user, violating least privilege',
        severity: 'high',
        category: 'security',
        resource: target.name,
        remediation: 'Configure container to run as non-root user using securityContext.runAsNonRoot: true',
        zeroTrustViolation: true,
      });
    }

    // Check for privileged mode
    if (target.metadata.privileged === 'true') {
      misconfigurations.push({
        id: crypto.randomUUID(),
        title: 'Privileged Container',
        description: 'Container is running in privileged mode, bypassing security controls',
        severity: 'critical',
        category: 'security',
        resource: target.name,
        remediation: 'Remove privileged: true from container security context',
        zeroTrustViolation: true,
      });
    }

    // Check for missing resource limits
    if (!target.metadata.resourceLimits) {
      misconfigurations.push({
        id: crypto.randomUUID(),
        title: 'Missing Resource Limits',
        description: 'Container has no resource limits defined',
        severity: 'medium',
        category: 'reliability',
        resource: target.name,
        remediation: 'Define resource requests and limits for CPU and memory',
        zeroTrustViolation: false,
      });
    }

    return misconfigurations;
  }
}

/**
 * Policy Scanner
 * Scans zero-trust policies for security issues
 */
class PolicyScanner {
  async scan(target: ScanTarget): Promise<{
    vulnerabilities: Vulnerability[];
    misconfigurations: Misconfiguration[];
  }> {
    console.log(`[PolicyScanner] Scanning ${target.name}`);

    const misconfigurations: Misconfiguration[] = [];

    // Check network policies
    if (target.type === 'policy') {
      const issues = this.checkNetworkPolicies(target);
      misconfigurations.push(...issues);
    }

    return { vulnerabilities: [], misconfigurations };
  }

  private checkNetworkPolicies(target: ScanTarget): Misconfiguration[] {
    const misconfigurations: Misconfiguration[] = [];

    // Check for overly permissive policies
    if (target.metadata.allowAll === 'true') {
      misconfigurations.push({
        id: crypto.randomUUID(),
        title: 'Overly Permissive Network Policy',
        description: 'Network policy allows all traffic, violating zero-trust principles',
        severity: 'critical',
        category: 'zero-trust',
        resource: target.name,
        remediation: 'Implement explicit allow rules for required traffic only',
        zeroTrustViolation: true,
      });
    }

    // Check for missing default deny
    if (!target.metadata.defaultDeny) {
      misconfigurations.push({
        id: crypto.randomUUID(),
        title: 'Missing Default Deny Policy',
        description: 'Namespace lacks default deny network policy',
        severity: 'high',
        category: 'zero-trust',
        resource: target.name,
        remediation: 'Add default deny ingress and egress network policy',
        zeroTrustViolation: true,
      });
    }

    // Check for missing mTLS
    if (target.metadata.mtlsMode !== 'STRICT') {
      misconfigurations.push({
        id: crypto.randomUUID(),
        title: 'mTLS Not Strictly Enforced',
        description: 'Service mesh mTLS is not in strict mode',
        severity: 'high',
        category: 'zero-trust',
        resource: target.name,
        remediation: 'Configure PeerAuthentication with mtls.mode: STRICT',
        zeroTrustViolation: true,
      });
    }

    return misconfigurations;
  }
}

/**
 * Secret Scanner
 * Detects exposed secrets and credentials
 */
class SecretScanner {
  private patterns: Array<{ name: string; regex: RegExp; severity: SecretFinding['severity'] }> = [
    { name: 'AWS Access Key', regex: /AKIA[0-9A-Z]{16}/, severity: 'critical' },
    { name: 'AWS Secret Key', regex: /[A-Za-z0-9/+=]{40}/, severity: 'critical' },
    { name: 'GitHub Token', regex: /ghp_[a-zA-Z0-9]{36}/, severity: 'critical' },
    { name: 'Private Key', regex: /-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----/, severity: 'critical' },
    { name: 'API Key', regex: /api[_-]?key[=:]["']?[a-zA-Z0-9]{32,}/, severity: 'high' },
    { name: 'Password in URL', regex: /[a-zA-Z]+:\/\/[^:]+:[^@]+@/, severity: 'high' },
    { name: 'JWT Token', regex: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/, severity: 'high' },
    { name: 'Generic Secret', regex: /(password|secret|token|key)\s*[=:]\s*["'][^"']+["']/, severity: 'medium' },
  ];

  async scan(target: ScanTarget, content?: string): Promise<SecretFinding[]> {
    console.log(`[SecretScanner] Scanning ${target.name}`);

    const findings: SecretFinding[] = [];

    if (!content) {
      // In production, would read actual file content
      return findings;
    }

    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      for (const pattern of this.patterns) {
        if (pattern.regex.test(line)) {
          findings.push({
            id: crypto.randomUUID(),
            type: pattern.name,
            location: target.location,
            lineNumber: i + 1,
            severity: pattern.severity,
            redactedValue: this.redact(line, pattern.regex),
          });
        }
      }
    }

    return findings;
  }

  private redact(line: string, pattern: RegExp): string {
    return line.replace(pattern, '[REDACTED]');
  }
}

/**
 * Configuration Scanner
 * Scans Kubernetes and infrastructure configurations
 */
class ConfigurationScanner {
  async scan(target: ScanTarget): Promise<{
    misconfigurations: Misconfiguration[];
  }> {
    console.log(`[ConfigurationScanner] Scanning ${target.name}`);

    const misconfigurations: Misconfiguration[] = [];

    // Check for security context issues
    misconfigurations.push(...this.checkSecurityContext(target));

    // Check for RBAC issues
    misconfigurations.push(...this.checkRBAC(target));

    // Check for service account issues
    misconfigurations.push(...this.checkServiceAccounts(target));

    return { misconfigurations };
  }

  private checkSecurityContext(target: ScanTarget): Misconfiguration[] {
    const issues: Misconfiguration[] = [];

    // Check for missing security context
    if (!target.metadata.securityContext) {
      issues.push({
        id: crypto.randomUUID(),
        title: 'Missing Security Context',
        description: 'Workload lacks security context configuration',
        severity: 'medium',
        category: 'security',
        resource: target.name,
        remediation: 'Add security context with appropriate restrictions',
        zeroTrustViolation: false,
      });
    }

    // Check for capability additions
    if (target.metadata.capabilities?.includes('SYS_ADMIN')) {
      issues.push({
        id: crypto.randomUUID(),
        title: 'Dangerous Capability Added',
        description: 'SYS_ADMIN capability grants excessive privileges',
        severity: 'critical',
        category: 'security',
        resource: target.name,
        remediation: 'Remove SYS_ADMIN capability or use more specific capabilities',
        zeroTrustViolation: true,
      });
    }

    return issues;
  }

  private checkRBAC(target: ScanTarget): Misconfiguration[] {
    const issues: Misconfiguration[] = [];

    // Check for cluster-admin bindings
    if (target.metadata.rbacRole === 'cluster-admin') {
      issues.push({
        id: crypto.randomUUID(),
        title: 'Cluster Admin Binding',
        description: 'Service account has cluster-admin privileges',
        severity: 'critical',
        category: 'rbac',
        resource: target.name,
        remediation: 'Use least-privilege role with only required permissions',
        zeroTrustViolation: true,
      });
    }

    // Check for wildcard permissions
    if (target.metadata.rbacWildcard === 'true') {
      issues.push({
        id: crypto.randomUUID(),
        title: 'Wildcard Permissions',
        description: 'RBAC role uses wildcard (*) permissions',
        severity: 'high',
        category: 'rbac',
        resource: target.name,
        remediation: 'Replace wildcards with explicit resource and verb lists',
        zeroTrustViolation: true,
      });
    }

    return issues;
  }

  private checkServiceAccounts(target: ScanTarget): Misconfiguration[] {
    const issues: Misconfiguration[] = [];

    // Check for default service account usage
    if (target.metadata.serviceAccount === 'default') {
      issues.push({
        id: crypto.randomUUID(),
        title: 'Default Service Account',
        description: 'Workload uses default service account',
        severity: 'medium',
        category: 'identity',
        resource: target.name,
        remediation: 'Create and assign dedicated service account',
        zeroTrustViolation: true,
      });
    }

    // Check for automounted tokens
    if (target.metadata.automountToken !== 'false') {
      issues.push({
        id: crypto.randomUUID(),
        title: 'Token Auto-mount Enabled',
        description: 'Service account token automatically mounted',
        severity: 'low',
        category: 'identity',
        resource: target.name,
        remediation: 'Set automountServiceAccountToken: false unless needed',
        zeroTrustViolation: false,
      });
    }

    return issues;
  }
}

/**
 * Zero Trust Score Calculator
 * Calculates overall zero trust security score
 */
class ZeroTrustScoreCalculator {
  calculate(
    vulnerabilities: Vulnerability[],
    misconfigurations: Misconfiguration[],
    secrets: SecretFinding[],
  ): number {
    let score = 100;

    // Deduct for vulnerabilities
    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case 'critical':
          score -= 15;
          break;
        case 'high':
          score -= 10;
          break;
        case 'medium':
          score -= 5;
          break;
        case 'low':
          score -= 2;
          break;
      }

      // Additional deduction for ZT impact
      if (vuln.zeroTrustImpact.lateralMovementRisk) {
        score -= 5;
      }
      if (vuln.zeroTrustImpact.privilegeEscalationRisk) {
        score -= 5;
      }
    }

    // Deduct for misconfigurations
    for (const misconfig of misconfigurations) {
      if (misconfig.zeroTrustViolation) {
        switch (misconfig.severity) {
          case 'critical':
            score -= 20;
            break;
          case 'high':
            score -= 15;
            break;
          case 'medium':
            score -= 8;
            break;
          case 'low':
            score -= 3;
            break;
        }
      } else {
        switch (misconfig.severity) {
          case 'critical':
            score -= 10;
            break;
          case 'high':
            score -= 7;
            break;
          case 'medium':
            score -= 3;
            break;
          case 'low':
            score -= 1;
            break;
        }
      }
    }

    // Deduct for secrets
    for (const secret of secrets) {
      switch (secret.severity) {
        case 'critical':
          score -= 25;
          break;
        case 'high':
          score -= 15;
          break;
        case 'medium':
          score -= 8;
          break;
        case 'low':
          score -= 3;
          break;
      }
    }

    return Math.max(0, Math.min(100, score));
  }
}

/**
 * Vulnerability Scanner Controller
 * Main controller orchestrating all scanning
 */
export class VulnerabilityScannerController extends EventEmitter {
  private containerScanner: ContainerScanner;
  private policyScanner: PolicyScanner;
  private secretScanner: SecretScanner;
  private configScanner: ConfigurationScanner;
  private scoreCalculator: ZeroTrustScoreCalculator;
  private scanPolicies: Map<string, ScanPolicy> = new Map();
  private scanResults: Map<string, ScanResult[]> = new Map();
  private running: boolean = false;
  private scanInterval?: NodeJS.Timeout;

  constructor() {
    super();
    this.containerScanner = new ContainerScanner();
    this.policyScanner = new PolicyScanner();
    this.secretScanner = new SecretScanner();
    this.configScanner = new ConfigurationScanner();
    this.scoreCalculator = new ZeroTrustScoreCalculator();
  }

  /**
   * Register a scan policy
   */
  registerPolicy(policy: ScanPolicy): void {
    this.scanPolicies.set(policy.id, policy);
    console.log(`[VulnerabilityScanner] Registered policy: ${policy.name}`);
  }

  /**
   * Start continuous scanning
   */
  async start(): Promise<void> {
    if (this.running) {
      console.warn('[VulnerabilityScanner] Already running');
      return;
    }

    this.running = true;
    console.log('[VulnerabilityScanner] Starting continuous scanning...');

    // Run initial scan
    await this.runFullScan();

    // Schedule periodic scans
    this.scanInterval = setInterval(async () => {
      await this.runFullScan();
    }, config.scanInterval);

    this.emit('started');
  }

  /**
   * Stop continuous scanning
   */
  async stop(): Promise<void> {
    if (!this.running) return;

    this.running = false;
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
    }

    this.emit('stopped');
    console.log('[VulnerabilityScanner] Stopped');
  }

  /**
   * Run a full scan of all targets
   */
  async runFullScan(): Promise<ScanResult[]> {
    console.log('[VulnerabilityScanner] Running full scan...');

    const targets = this.discoverTargets();
    const results: ScanResult[] = [];

    for (const target of targets) {
      try {
        const result = await this.scanTarget(target);
        results.push(result);

        // Store result
        const existing = this.scanResults.get(target.name) || [];
        existing.push(result);
        this.scanResults.set(target.name, existing);

        // Check policies
        await this.evaluatePolicies(result);
      } catch (error) {
        console.error(
          `[VulnerabilityScanner] Failed to scan ${target.name}:`,
          error,
        );
      }
    }

    this.emit('scan_completed', { results });
    return results;
  }

  /**
   * Scan a specific target
   */
  async scanTarget(target: ScanTarget): Promise<ScanResult> {
    const startTime = new Date();

    let vulnerabilities: Vulnerability[] = [];
    let misconfigurations: Misconfiguration[] = [];
    let secrets: SecretFinding[] = [];

    // Run appropriate scanners based on target type
    switch (target.type) {
      case 'container': {
        const containerResult = await this.containerScanner.scan(target);
        vulnerabilities = containerResult.vulnerabilities;
        misconfigurations = containerResult.misconfigurations;
        break;
      }
      case 'policy': {
        const policyResult = await this.policyScanner.scan(target);
        misconfigurations = policyResult.misconfigurations;
        break;
      }
      case 'config': {
        const configResult = await this.configScanner.scan(target);
        misconfigurations = configResult.misconfigurations;
        break;
      }
      case 'secret': {
        secrets = await this.secretScanner.scan(target);
        break;
      }
    }

    const endTime = new Date();

    // Calculate zero trust score
    const zeroTrustScore = this.scoreCalculator.calculate(
      vulnerabilities,
      misconfigurations,
      secrets,
    );

    const summary: ScanSummary = {
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: vulnerabilities.filter((v) => v.severity === 'critical').length,
      highCount: vulnerabilities.filter((v) => v.severity === 'high').length,
      mediumCount: vulnerabilities.filter((v) => v.severity === 'medium').length,
      lowCount: vulnerabilities.filter((v) => v.severity === 'low').length,
      misconfigurationCount: misconfigurations.length,
      secretsFound: secrets.length,
      zeroTrustScore,
    };

    return {
      id: crypto.randomUUID(),
      scanType: target.type,
      target,
      startTime,
      endTime,
      vulnerabilities,
      misconfigurations,
      secrets,
      summary,
    };
  }

  /**
   * Discover scan targets
   */
  private discoverTargets(): ScanTarget[] {
    // In production, this would dynamically discover targets
    return [
      {
        type: 'container',
        name: 'api-server',
        location: 'intelgraph/api-server:latest',
        metadata: {
          baseImage: 'node:18-alpine',
          runAsRoot: 'false',
          privileged: 'false',
        },
      },
      {
        type: 'container',
        name: 'graph-service',
        location: 'intelgraph/graph-service:latest',
        metadata: {
          baseImage: 'alpine:3.18',
          runAsRoot: 'false',
          resourceLimits: 'true',
        },
      },
      {
        type: 'policy',
        name: 'network-policies',
        location: 'zero-trust/policies/network',
        metadata: {
          defaultDeny: 'true',
          mtlsMode: 'STRICT',
        },
      },
      {
        type: 'config',
        name: 'api-deployment',
        location: 'k8s/deployments/api.yaml',
        metadata: {
          securityContext: 'true',
          serviceAccount: 'api-server',
          automountToken: 'false',
        },
      },
    ];
  }

  /**
   * Evaluate scan policies
   */
  private async evaluatePolicies(result: ScanResult): Promise<void> {
    for (const policy of this.scanPolicies.values()) {
      if (!policy.enabled) continue;

      const violations: string[] = [];

      if (policy.thresholds.failOnCritical && result.summary.criticalCount > 0) {
        violations.push(
          `Critical vulnerabilities found: ${result.summary.criticalCount}`,
        );
      }

      if (
        policy.thresholds.failOnHigh &&
        result.summary.highCount > policy.thresholds.maxHigh
      ) {
        violations.push(
          `High vulnerabilities exceed threshold: ${result.summary.highCount} > ${policy.thresholds.maxHigh}`,
        );
      }

      if (result.summary.zeroTrustScore < policy.thresholds.minZeroTrustScore) {
        violations.push(
          `Zero Trust score below threshold: ${result.summary.zeroTrustScore} < ${policy.thresholds.minZeroTrustScore}`,
        );
      }

      if (violations.length > 0) {
        this.emit('policy_violation', {
          policy: policy.name,
          result,
          violations,
        });
      }
    }
  }

  /**
   * Get latest scan results
   */
  getLatestResults(): Map<string, ScanResult> {
    const latest = new Map<string, ScanResult>();

    for (const [name, results] of this.scanResults) {
      if (results.length > 0) {
        latest.set(name, results[results.length - 1]);
      }
    }

    return latest;
  }

  /**
   * Get all vulnerabilities
   */
  getAllVulnerabilities(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    for (const results of this.scanResults.values()) {
      for (const result of results) {
        vulnerabilities.push(...result.vulnerabilities);
      }
    }

    return vulnerabilities;
  }

  /**
   * Get zero trust score summary
   */
  getZeroTrustScoreSummary(): {
    overall: number;
    byComponent: Map<string, number>;
  } {
    const latest = this.getLatestResults();
    const scores: number[] = [];
    const byComponent = new Map<string, number>();

    for (const [name, result] of latest) {
      scores.push(result.summary.zeroTrustScore);
      byComponent.set(name, result.summary.zeroTrustScore);
    }

    const overall =
      scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 100;

    return { overall, byComponent };
  }
}

// Factory function
export function createVulnerabilityScannerController(): VulnerabilityScannerController {
  const controller = new VulnerabilityScannerController();

  // Register default scan policy
  controller.registerPolicy({
    id: 'default-policy',
    name: 'Default Zero Trust Security Policy',
    enabled: true,
    scanTypes: ['container', 'policy', 'config', 'secret'],
    thresholds: {
      failOnCritical: true,
      failOnHigh: false,
      maxCritical: 0,
      maxHigh: 5,
      minZeroTrustScore: 80,
    },
    excludePatterns: ['**/test/**', '**/mock/**'],
  });

  // Register strict policy for production
  controller.registerPolicy({
    id: 'production-policy',
    name: 'Production Zero Trust Policy',
    enabled: true,
    scanTypes: ['container', 'policy', 'config', 'secret'],
    thresholds: {
      failOnCritical: true,
      failOnHigh: true,
      maxCritical: 0,
      maxHigh: 0,
      minZeroTrustScore: 95,
    },
    excludePatterns: [],
  });

  return controller;
}

export default VulnerabilityScannerController;
