# Generated by Consent-Constraint Compiler. Do not edit manually.
from __future__ import annotations

from collections.abc import Callable
from typing import Any

from .policy_data import POLICY

_TELEMETRY: list[dict[str, str]] = []


class ConsentViolation(Exception):
    """Raised when an action does not have consent for the requested purpose."""


class Guard:  # pragma: no cover - thin wrapper for type hinting
    def __init__(self, scope: str, purpose: str, lawful_basis: str):
        self.scope = scope
        self.purpose = purpose
        self.lawful_basis = lawful_basis

    def execute(self, action: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:
        _TELEMETRY.append(
            {
                "scope": self.scope,
                "purpose": self.purpose,
                "lawful_basis": self.lawful_basis,
            }
        )
        return action(*args, **kwargs)


def getTelemetry() -> list[dict[str, str]]:
    return list(_TELEMETRY)


def resetTelemetry() -> None:
    _TELEMETRY.clear()


def withConsent(scope: str, purpose: str) -> Guard:
    allowed = POLICY.get(scope)
    if not allowed or purpose not in allowed:
        raise ConsentViolation(f"Purpose '{purpose}' is not permitted within scope '{scope}'")
    return Guard(scope, purpose, allowed[purpose])


with_consent = withConsent
