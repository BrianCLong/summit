// Generated by Consent-Constraint Compiler. Do not edit manually.
package consentguard

import (
  "fmt"
  "sync"
)

var telemetryMu sync.Mutex
var telemetry []TelemetryEntry

// TelemetryEntry captures every successful consent check.
type TelemetryEntry struct {
  Scope       string
  Purpose     string
  LawfulBasis string
}

// ConsentViolation represents a failure to match consent for a purpose.
type ConsentViolation struct {
  Scope   string
  Purpose string
}

func (e ConsentViolation) Error() string {
  return fmt.Sprintf("purpose %s is not permitted within scope %s", e.Purpose, e.Scope)
}

// Guard defines a callable that executes the provided action when consent is valid.
type Guard func(func() (any, error)) (any, error)

// WithConsent exposes the Go shim.
func WithConsent(scope, purpose string) (Guard, error) {
  allowed, ok := policy[scope]
  if !ok {
    return nil, ConsentViolation{Scope: scope, Purpose: purpose}
  }
  lawful, ok := allowed[purpose]
  if !ok {
    return nil, ConsentViolation{Scope: scope, Purpose: purpose}
  }

  guard := func(action func() (any, error)) (any, error) {
    telemetryMu.Lock()
    telemetry = append(telemetry, TelemetryEntry{
      Scope:       scope,
      Purpose:     purpose,
      LawfulBasis: lawful,
    })
    telemetryMu.Unlock()
    return action()
  }
  return guard, nil
}

// WithConsentFunc preserves the lowercase naming expectation via an exported alias.
var WithConsentFunc = WithConsent

// ResetTelemetry clears recorded telemetry entries.
func ResetTelemetry() {
  telemetryMu.Lock()
  defer telemetryMu.Unlock()
  telemetry = telemetry[:0]
}

// GetTelemetry returns a copy of telemetry entries.
func GetTelemetry() []TelemetryEntry {
  telemetryMu.Lock()
  defer telemetryMu.Unlock()
  out := make([]TelemetryEntry, len(telemetry))
  copy(out, telemetry)
  return out
}
