/**
 * Comment drafting module
 * Drafts comments for deduplicated clusters
 */

import { IssueCluster, TriageItem } from '../types.js';

export interface CommentDraft {
  issueId: string;
  comment: string;
  relatedIssues: string[];
  action: 'duplicate' | 'cluster-summary' | 'auto-triage';
}

/**
 * Draft deduplication comments for clustered issues
 */
export function draftDeduplicationComments(cluster: IssueCluster): CommentDraft[] {
  if (cluster.items.length < 2) {
    return [];
  }

  const drafts: CommentDraft[] = [];

  // Find the "primary" issue (highest impact or oldest)
  const sortedItems = [...cluster.items].sort(
    (a, b) => b.impactScore - a.impactScore || a.id.localeCompare(b.id),
  );
  const primaryIssue = sortedItems[0];
  const duplicates = sortedItems.slice(1);

  // Draft comment for primary issue (cluster summary)
  const primaryComment = `## ðŸ”— Related Issues Detected

This issue appears to be part of a cluster of ${cluster.items.length} related issues around the theme: **${cluster.theme}**

**Related issues**:
${duplicates
  .map((item) => {
    const impactEmoji = getImpactEmoji(item.impact);
    return `- ${impactEmoji} ${formatIssueReference(item)} - ${item.title}`;
  })
  .join('\n')}

**Common areas**: ${cluster.area.join(', ') || 'N/A'}

Consider consolidating these issues or creating an epic to track the overall theme.

---
*This comment was auto-generated by the autotriage engine*`;

  drafts.push({
    issueId: primaryIssue.id,
    comment: primaryComment,
    relatedIssues: duplicates.map((i) => i.id),
    action: 'cluster-summary',
  });

  // Draft comments for duplicate issues
  duplicates.forEach((item) => {
    const duplicateComment = `## ðŸ”„ Potential Duplicate Detected

This issue may be a duplicate or closely related to ${formatIssueReference(primaryIssue)}.

**Primary issue**: ${primaryIssue.title}

Both issues share the theme: **${cluster.theme}**

Please review and consider closing as duplicate or linking the issues.

---
*This comment was auto-generated by the autotriage engine*`;

    drafts.push({
      issueId: item.id,
      comment: duplicateComment,
      relatedIssues: [primaryIssue.id],
      action: 'duplicate',
    });
  });

  return drafts;
}

/**
 * Draft auto-triage comments with classification results
 */
export function draftAutoTriageComment(item: TriageItem): CommentDraft {
  const comment = `## ðŸ¤– Auto-Triage Results

This issue has been automatically analyzed:

**Classification**:
- **Impact**: ${getImpactEmoji(item.impact)} ${item.impact.toUpperCase()} (score: ${item.impactScore.toFixed(0)})
- **Type**: ${item.type}
- **Areas**: ${item.area.join(', ')}
- **Complexity**: ${item.complexityScore.toFixed(0)}

${item.isGoodFirstIssue ? '**âœ¨ This issue is tagged as a good first issue for new contributors!**\n\n' : ''}
${item.clusterTheme ? `**Theme**: ${item.clusterTheme}\n\n` : ''}

**Suggested labels**: ${generateLabelList(item)}

---
*This comment was auto-generated by the autotriage engine. Please review and adjust as needed.*`;

  return {
    issueId: item.id,
    comment,
    relatedIssues: [],
    action: 'auto-triage',
  };
}

/**
 * Draft batch comments for all issues
 */
export function draftBatchComments(items: TriageItem[], clusters: IssueCluster[]): CommentDraft[] {
  const drafts: CommentDraft[] = [];

  // Draft deduplication comments for clusters
  clusters.forEach((cluster) => {
    drafts.push(...draftDeduplicationComments(cluster));
  });

  return drafts;
}

function formatIssueReference(item: TriageItem): string {
  if (item.source === 'github') {
    return `#${item.sourceId}`;
  }
  return `${item.id}`;
}

function getImpactEmoji(impact: string): string {
  switch (impact) {
    case 'blocker':
      return 'ðŸš¨';
    case 'high':
      return 'ðŸ”´';
    case 'medium':
      return 'ðŸŸ¡';
    case 'low':
      return 'ðŸŸ¢';
    default:
      return 'âšª';
  }
}

function generateLabelList(item: TriageItem): string {
  const labels: string[] = [];

  item.area.forEach((area) => {
    if (area !== 'uncategorized') labels.push(`area:${area}`);
  });

  labels.push(`priority:${item.impact}`);
  labels.push(`type:${item.type}`);

  if (item.isGoodFirstIssue) {
    labels.push('good-first-issue');
  }

  return labels.join(', ');
}
