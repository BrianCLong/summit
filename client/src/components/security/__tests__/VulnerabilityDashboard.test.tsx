/**
 * VulnerabilityDashboard Tests
 * @module client/src/components/security/__tests__/VulnerabilityDashboard.test
 */

import React from 'react';
import { render, screen, fireEvent, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { VulnerabilityDashboard } from '../VulnerabilityDashboard';

// Mock fetch
const mockFetch = jest.fn();
global.fetch = mockFetch;

// Mock dashboard data
const mockDashboardData = {
  summary: {
    totalScans: 150,
    totalVulnerabilities: 45,
    criticalCount: 3,
    highCount: 12,
    mediumCount: 20,
    lowCount: 10,
    fixableCount: 35,
    sbomCount: 8,
    attestationCount: 6,
    lastScanTime: '2025-01-15T10:30:00Z',
    policyPassRate: 87.5,
  },
  recentScans: [
    {
      id: 'scan-1',
      timestamp: '2025-01-15T10:30:00Z',
      target: 'intelgraph-server:latest',
      scanner: 'trivy',
      status: 'success' as const,
      duration: 45000,
      summary: {
        total: 15,
        critical: 1,
        high: 3,
        medium: 8,
        low: 3,
        fixable: 12,
      },
      policyPassed: false,
    },
    {
      id: 'scan-2',
      timestamp: '2025-01-15T09:00:00Z',
      target: 'analytics-engine:v2.1.0',
      scanner: 'trivy',
      status: 'success' as const,
      duration: 32000,
      summary: {
        total: 8,
        critical: 0,
        high: 2,
        medium: 4,
        low: 2,
        fixable: 6,
      },
      policyPassed: true,
    },
  ],
  sboms: [
    {
      id: 'sbom-1',
      name: 'intelgraph-server',
      version: '1.5.0',
      timestamp: '2025-01-15T10:00:00Z',
      componentCount: 342,
      digest: 'sha256:abc123',
      signatureValid: true,
      attestationId: 'att-1',
      vulnerabilities: {
        critical: 1,
        high: 3,
        medium: 8,
        low: 5,
      },
    },
    {
      id: 'sbom-2',
      name: 'analytics-engine',
      version: '2.1.0',
      timestamp: '2025-01-14T15:00:00Z',
      componentCount: 256,
      digest: 'sha256:def456',
      signatureValid: true,
      attestationId: null,
      vulnerabilities: {
        critical: 0,
        high: 2,
        medium: 4,
        low: 2,
      },
    },
  ],
  topVulnerabilities: [
    {
      id: 'CVE-2025-1234',
      severity: 'critical' as const,
      title: 'Critical RCE in Package X',
      affectedPackages: ['package-x'],
      cvssScore: 9.8,
      fixedVersions: { 'package-x': '2.0.1' },
      exploitAvailable: true,
      cisaKev: true,
    },
    {
      id: 'CVE-2025-5678',
      severity: 'high' as const,
      title: 'SQL Injection in Library Y',
      affectedPackages: ['library-y'],
      cvssScore: 8.5,
      fixedVersions: { 'library-y': '1.5.0' },
      exploitAvailable: false,
      cisaKev: false,
    },
  ],
  trendData: [
    { date: '2025-01-14', critical: 2, high: 10, medium: 18, low: 8 },
    { date: '2025-01-15', critical: 3, high: 12, medium: 20, low: 10 },
  ],
};

const mockSearchResults = [
  {
    id: 'CVE-2025-9999',
    severity: 'high' as const,
    title: 'Vulnerability in searched-package',
    affectedPackages: ['searched-package'],
    cvssScore: 7.5,
    fixedVersions: { 'searched-package': '3.0.0' },
    exploitAvailable: false,
    cisaKev: false,
  },
];

describe('VulnerabilityDashboard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockDashboardData),
    });
  });

  describe('Initial Render', () => {
    it('should show loading state initially', () => {
      render(<VulnerabilityDashboard />);
      expect(screen.getByRole('progressbar')).toBeInTheDocument();
    });

    it('should render dashboard after loading', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('Vulnerability Management')).toBeInTheDocument();
      });

      expect(screen.getByText('Air-Gapped Security Dashboard')).toBeInTheDocument();
    });

    it('should display summary statistics', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('Critical Vulnerabilities')).toBeInTheDocument();
      });

      expect(screen.getByText('3')).toBeInTheDocument(); // Critical count
      expect(screen.getByText('High Vulnerabilities')).toBeInTheDocument();
      expect(screen.getByText('12')).toBeInTheDocument(); // High count
      expect(screen.getByText('87.5%')).toBeInTheDocument(); // Policy pass rate
      expect(screen.getByText('8')).toBeInTheDocument(); // SBOM count
    });
  });

  describe('Tabs Navigation', () => {
    it('should display top vulnerabilities by default', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('CVE-2025-1234')).toBeInTheDocument();
      });

      expect(screen.getByText('Critical RCE in Package X')).toBeInTheDocument();
    });

    it('should switch to Recent Scans tab', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'Recent Scans' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'Recent Scans' }));

      await waitFor(() => {
        expect(screen.getByText('intelgraph-server:latest')).toBeInTheDocument();
      });
    });

    it('should switch to SBOMs tab', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'SBOMs' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'SBOMs' }));

      await waitFor(() => {
        expect(screen.getByText('intelgraph-server')).toBeInTheDocument();
      });

      expect(screen.getByText('342')).toBeInTheDocument(); // Component count
    });

    it('should switch to Search tab', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'Search' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'Search' }));

      await waitFor(() => {
        expect(screen.getByPlaceholderText('Search by package name...')).toBeInTheDocument();
      });
    });
  });

  describe('Search Functionality', () => {
    it('should search for vulnerabilities', async () => {
      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockDashboardData),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ vulnerabilities: mockSearchResults }),
        });

      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'Search' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'Search' }));

      const searchInput = screen.getByPlaceholderText('Search by package name...');
      await userEvent.type(searchInput, 'searched-package{enter}');

      await waitFor(() => {
        expect(screen.getByText('CVE-2025-9999')).toBeInTheDocument();
      });
    });

    it('should show no results message when search returns empty', async () => {
      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockDashboardData),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ vulnerabilities: [] }),
        });

      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'Search' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'Search' }));

      const searchInput = screen.getByPlaceholderText('Search by package name...');
      await userEvent.type(searchInput, 'nonexistent{enter}');

      await waitFor(() => {
        expect(screen.getByText('No vulnerabilities found')).toBeInTheDocument();
      });
    });
  });

  describe('Error Handling', () => {
    it('should display error message on fetch failure', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('Network error')).toBeInTheDocument();
      });

      expect(screen.getByRole('button', { name: 'Retry' })).toBeInTheDocument();
    });

    it('should retry loading on retry button click', async () => {
      mockFetch
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockDashboardData),
        });

      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('Network error')).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('button', { name: 'Retry' }));

      await waitFor(() => {
        expect(screen.getByText('Vulnerability Management')).toBeInTheDocument();
      });
    });
  });

  describe('Refresh Functionality', () => {
    it('should refresh data on refresh button click', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('Vulnerability Management')).toBeInTheDocument();
      });

      const refreshButton = screen.getByRole('button', { name: 'Refresh' });
      fireEvent.click(refreshButton);

      expect(mockFetch).toHaveBeenCalledTimes(2);
    });
  });

  describe('Export Functionality', () => {
    it('should export compliance report', async () => {
      const mockReport = {
        generatedAt: '2025-01-15T12:00:00Z',
        summary: mockDashboardData.summary,
      };

      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockDashboardData),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockReport),
        });

      // Mock URL.createObjectURL and document.createElement
      const mockCreateObjectURL = jest.fn(() => 'blob:test');
      const mockRevokeObjectURL = jest.fn();
      global.URL.createObjectURL = mockCreateObjectURL;
      global.URL.revokeObjectURL = mockRevokeObjectURL;

      const mockClick = jest.fn();
      const mockAnchor = { click: mockClick, href: '', download: '' };
      jest.spyOn(document, 'createElement').mockReturnValue(mockAnchor as any);

      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('Vulnerability Management')).toBeInTheDocument();
      });

      const exportButton = screen.getByRole('button', { name: 'Export Compliance Report' });
      fireEvent.click(exportButton);

      await waitFor(() => {
        expect(mockFetch).toHaveBeenCalledWith('/api/security/compliance-report');
      });
    });
  });

  describe('Severity Display', () => {
    it('should display severity chips with correct colors', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('CRITICAL: 3')).toBeInTheDocument();
      });

      expect(screen.getByText('HIGH: 12')).toBeInTheDocument();
      expect(screen.getByText('MEDIUM: 20')).toBeInTheDocument();
      expect(screen.getByText('LOW: 10')).toBeInTheDocument();
    });

    it('should show vulnerability flags (Exploit, KEV, Fix Available)', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByText('CVE-2025-1234')).toBeInTheDocument();
      });

      expect(screen.getByText('Exploit')).toBeInTheDocument();
      expect(screen.getByText('KEV')).toBeInTheDocument();
      expect(screen.getAllByText('Fix Available').length).toBeGreaterThan(0);
    });
  });

  describe('SBOM Information', () => {
    it('should display SBOM details correctly', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'SBOMs' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'SBOMs' }));

      await waitFor(() => {
        expect(screen.getByText('intelgraph-server')).toBeInTheDocument();
      });

      expect(screen.getByText('1.5.0')).toBeInTheDocument();
      expect(screen.getByText('Signed')).toBeInTheDocument();
      expect(screen.getByText('Attested')).toBeInTheDocument();
    });
  });

  describe('Scan History', () => {
    it('should display scan history with correct status', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tab', { name: 'Recent Scans' })).toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('tab', { name: 'Recent Scans' }));

      await waitFor(() => {
        expect(screen.getByText('intelgraph-server:latest')).toBeInTheDocument();
      });

      // Check policy status indicators
      expect(screen.getByText('Failed')).toBeInTheDocument();
      expect(screen.getByText('Passed')).toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    it('should have accessible tab navigation', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('tablist')).toBeInTheDocument();
      });

      const tabs = screen.getAllByRole('tab');
      expect(tabs).toHaveLength(4);

      tabs.forEach((tab) => {
        expect(tab).toHaveAttribute('aria-selected');
      });
    });

    it('should have proper table structure', async () => {
      render(<VulnerabilityDashboard />);

      await waitFor(() => {
        expect(screen.getByRole('table')).toBeInTheDocument();
      });

      const tables = screen.getAllByRole('table');
      tables.forEach((table) => {
        expect(within(table).getByRole('rowgroup')).toBeInTheDocument();
      });
    });
  });
});

describe('VulnerabilityDashboard Edge Cases', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should handle empty dashboard data', async () => {
    const emptyData = {
      summary: {
        totalScans: 0,
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        fixableCount: 0,
        sbomCount: 0,
        attestationCount: 0,
        policyPassRate: 100,
      },
      recentScans: [],
      sboms: [],
      topVulnerabilities: [],
      trendData: [],
    };

    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(emptyData),
    });

    render(<VulnerabilityDashboard />);

    await waitFor(() => {
      expect(screen.getByText('0')).toBeInTheDocument();
    });

    expect(screen.getByText('100.0%')).toBeInTheDocument();
  });

  it('should handle missing optional fields', async () => {
    const dataWithMissingFields = {
      ...mockDashboardData,
      summary: {
        ...mockDashboardData.summary,
        lastScanTime: undefined,
      },
    };

    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(dataWithMissingFields),
    });

    render(<VulnerabilityDashboard />);

    await waitFor(() => {
      expect(screen.getByText('Last Scan: Never')).toBeInTheDocument();
    });
  });
});
