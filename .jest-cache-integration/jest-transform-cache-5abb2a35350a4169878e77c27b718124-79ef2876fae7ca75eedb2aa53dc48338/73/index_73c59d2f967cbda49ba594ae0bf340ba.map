{"file":"/Users/brianlong/Developer/summit/src/memory/index.ts","mappings":"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","names":[],"sources":["/Users/brianlong/Developer/summit/src/memory/index.ts"],"sourcesContent":["import { SemanticMemory } from './semanticMemory';\nimport { PromptCache } from './promptCache';\n\nexport interface MemorySystem {\n  semantic: SemanticMemory;\n  cache: PromptCache;\n}\n\nexport class MaestroMemory {\n  private static instance: MaestroMemory;\n  public semantic: SemanticMemory;\n  public cache: PromptCache;\n  private projectRoot: string;\n\n  private constructor(projectRoot: string = process.cwd()) {\n    this.projectRoot = projectRoot;\n    this.semantic = new SemanticMemory(projectRoot);\n    this.cache = new PromptCache(projectRoot);\n  }\n\n  static getInstance(projectRoot?: string): MaestroMemory {\n    if (!MaestroMemory.instance) {\n      MaestroMemory.instance = new MaestroMemory(projectRoot);\n    }\n    return MaestroMemory.instance;\n  }\n\n  async initialize(): Promise<void> {\n    console.log('🧠 Initializing Maestro Memory System...');\n    \n    const start = Date.now();\n    \n    await Promise.all([\n      this.semantic.initialize(),\n      this.cache.initialize()\n    ]);\n\n    const duration = Date.now() - start;\n    console.log(`✅ Memory system ready (${duration}ms)`);\n    \n    // Log stats\n    const [semanticStats, cacheStats] = await Promise.all([\n      this.semantic.getStats(),\n      this.cache.getStats()\n    ]);\n\n    console.log(`📊 Semantic Memory: ${semanticStats.totalEntries} entries, ${(semanticStats.memorySize / 1024).toFixed(1)}KB`);\n    console.log(`💾 Prompt Cache: ${cacheStats.size} entries, hit rate: ${(cacheStats.hitRate * 100).toFixed(1)}%`);\n  }\n\n  async storeExperience(\n    content: string,\n    type: 'code' | 'error' | 'solution' | 'pattern' | 'context',\n    success: boolean,\n    metadata: Record<string, any> = {}\n  ): Promise<string> {\n    const memoryId = await this.semantic.store(content, type, {\n      ...metadata,\n      success\n    });\n\n    // Also cache if it's a solution or pattern that worked\n    if (success && (type === 'solution' || type === 'pattern')) {\n      const cacheId = await this.cache.set(\n        metadata.prompt || content,\n        content,\n        metadata.model || 'default',\n        {\n          success: true,\n          cost: metadata.cost || 0,\n          tokens: metadata.tokens || { input: 0, output: 0 },\n          latency: metadata.latency || 0,\n          context: metadata.context || {}\n        },\n        metadata.context || {}\n      );\n      \n      console.log(`💾 Cached successful ${type}: ${cacheId}`);\n    }\n\n    return memoryId;\n  }\n\n  async recall(\n    query: string,\n    type?: string[],\n    useCache: boolean = true\n  ): Promise<{\n    cached?: any;\n    semantic: any[];\n    recommendations: string[];\n  }> {\n    const results = {\n      cached: undefined,\n      semantic: [],\n      recommendations: []\n    };\n\n    // Try cache first\n    if (useCache) {\n      const cached = await this.cache.get(query);\n      if (cached) {\n        results.cached = cached;\n        results.recommendations.push('Found exact cached solution');\n      }\n    }\n\n    // Search semantic memory\n    const semanticResults = await this.semantic.retrieve({\n      query,\n      type,\n      limit: 5,\n      similarity: 0.6\n    });\n\n    results.semantic = semanticResults;\n\n    // Generate recommendations based on what we found\n    if (semanticResults.length > 0) {\n      const successfulResults = semanticResults.filter(r => r.entry.metadata.success);\n      const failedResults = semanticResults.filter(r => !r.entry.metadata.success);\n\n      if (successfulResults.length > 0) {\n        results.recommendations.push(`Found ${successfulResults.length} successful similar experiences`);\n      }\n      \n      if (failedResults.length > 0) {\n        results.recommendations.push(`⚠️ Found ${failedResults.length} failed attempts - avoid these patterns`);\n      }\n\n      // Pattern analysis\n      const patterns = semanticResults\n        .filter(r => r.entry.type === 'pattern')\n        .map(r => r.entry.metadata.tags)\n        .flat();\n      \n      if (patterns.length > 0) {\n        const uniquePatterns = [...new Set(patterns)];\n        results.recommendations.push(`Related patterns: ${uniquePatterns.join(', ')}`);\n      }\n    } else {\n      results.recommendations.push('No similar experiences found - exploring new territory');\n    }\n\n    return results;\n  }\n\n  async learn(\n    originalQuery: string,\n    solution: string,\n    success: boolean,\n    metadata: Record<string, any> = {}\n  ): Promise<void> {\n    // Store the learning experience\n    await this.storeExperience(\n      solution,\n      success ? 'solution' : 'error',\n      success,\n      {\n        ...metadata,\n        originalQuery\n      }\n    );\n\n    // If this was successful, update related semantic memories\n    if (success) {\n      const relatedMemories = await this.semantic.retrieve({\n        query: originalQuery,\n        limit: 3,\n        similarity: 0.7\n      });\n\n      const solutionId = await this.semantic.store(solution, 'solution', {\n        ...metadata,\n        success: true\n      });\n\n      // Create relations between the solution and related memories\n      for (const memory of relatedMemories) {\n        await this.semantic.addRelation(solutionId, memory.entry.id);\n      }\n    }\n  }\n\n  async cleanup(options: {\n    semanticOlderThanDays?: number;\n    cacheCleanup?: boolean;\n    optimize?: boolean;\n  } = {}): Promise<{\n    semantic: { removed: number };\n    cache: { expired: number; invalidated: number; optimized?: { removed: number; compacted: number } };\n  }> {\n    console.log('🧹 Cleaning up memory system...');\n\n    const results = {\n      semantic: { removed: 0 },\n      cache: { expired: 0, invalidated: 0, optimized: undefined as any }\n    };\n\n    // Cleanup semantic memory\n    if (options.semanticOlderThanDays !== undefined) {\n      results.semantic.removed = await this.semantic.cleanup(options.semanticOlderThanDays);\n    }\n\n    // Cleanup cache\n    if (options.cacheCleanup) {\n      const cacheCleanup = await this.cache.cleanup();\n      results.cache.expired = cacheCleanup.expired;\n      results.cache.invalidated = cacheCleanup.invalidated;\n    }\n\n    // Optimize cache\n    if (options.optimize) {\n      results.cache.optimized = await this.cache.optimizeCache();\n    }\n\n    console.log(`🧹 Cleanup complete: ${results.semantic.removed} semantic entries, ${results.cache.expired + results.cache.invalidated} cache entries removed`);\n\n    return results;\n  }\n\n  async exportMemory(): Promise<{\n    semantic: any[];\n    cache: any[];\n    stats: {\n      semantic: any;\n      cache: any;\n    };\n  }> {\n    const [semanticStats, cacheStats] = await Promise.all([\n      this.semantic.getStats(),\n      this.cache.getStats()\n    ]);\n\n    // This is a simplified export - in a real implementation,\n    // you'd want to be more careful about sensitive data\n    return {\n      semantic: [], // Would export non-sensitive semantic memories\n      cache: [], // Would export non-sensitive cache entries\n      stats: {\n        semantic: semanticStats,\n        cache: cacheStats\n      }\n    };\n  }\n}\n\n// Utility functions for integration with agents\nexport async function withMemory<T>(\n  operation: (memory: MaestroMemory) => Promise<T>,\n  projectRoot?: string\n): Promise<T> {\n  const memory = MaestroMemory.getInstance(projectRoot);\n  await memory.initialize();\n  return await operation(memory);\n}\n\nexport async function cacheableOperation<T>(\n  key: string,\n  operation: () => Promise<T>,\n  ttl: number = 3600,\n  projectRoot?: string\n): Promise<T> {\n  const memory = MaestroMemory.getInstance(projectRoot);\n  await memory.initialize();\n\n  // Check cache first\n  const cached = await memory.cache.get(key);\n  if (cached) {\n    try {\n      return JSON.parse(cached.response);\n    } catch {\n      return cached.response as any;\n    }\n  }\n\n  // Execute operation\n  const result = await operation();\n\n  // Cache the result\n  await memory.cache.set(\n    key,\n    JSON.stringify(result),\n    'operation',\n    { success: true },\n    {},\n    ttl\n  );\n\n  return result;\n}\n\nexport { SemanticMemory, PromptCache };"],"version":3}