{"file":"/Users/brianlong/Developer/summit/src/memory/semanticMemory.ts","mappings":"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","names":[],"sources":["/Users/brianlong/Developer/summit/src/memory/semanticMemory.ts"],"sourcesContent":["import { createHash } from 'crypto';\nimport { readFile, writeFile, mkdir, access } from 'fs/promises';\nimport { join } from 'path';\nimport { promisify } from 'util';\nimport { exec } from 'child_process';\n\nconst execAsync = promisify(exec);\n\ninterface MemoryEntry {\n  id: string;\n  type: 'code' | 'error' | 'solution' | 'pattern' | 'context';\n  content: string;\n  embedding?: number[];\n  metadata: {\n    timestamp: string;\n    project: string;\n    file?: string;\n    tags: string[];\n    frequency: number;\n    lastAccessed: string;\n    success: boolean;\n  };\n  relations: string[];\n}\n\ninterface SemanticQuery {\n  query: string;\n  type?: string[];\n  tags?: string[];\n  similarity?: number;\n  limit?: number;\n}\n\ninterface SemanticResult {\n  entry: MemoryEntry;\n  similarity: number;\n  rank: number;\n}\n\nexport class SemanticMemory {\n  private memoryPath: string;\n  private indexPath: string;\n  private entries: Map<string, MemoryEntry>;\n  private vectorDimension: number = 1536; // OpenAI embedding dimension\n  private maxEntries: number = 10000;\n\n  constructor(projectRoot: string = process.cwd()) {\n    this.memoryPath = join(projectRoot, '.maestro', 'memory');\n    this.indexPath = join(this.memoryPath, 'index.json');\n    this.entries = new Map();\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      await mkdir(this.memoryPath, { recursive: true });\n      await this.loadMemory();\n    } catch (error) {\n      console.warn('Failed to initialize semantic memory:', error.message);\n    }\n  }\n\n  async store(\n    content: string, \n    type: MemoryEntry['type'],\n    metadata: Partial<MemoryEntry['metadata']> = {}\n  ): Promise<string> {\n    const id = this.generateId(content, type);\n    const existing = this.entries.get(id);\n\n    if (existing) {\n      // Update existing entry\n      existing.metadata.frequency += 1;\n      existing.metadata.lastAccessed = new Date().toISOString();\n      await this.persistMemory();\n      return id;\n    }\n\n    // Create new entry\n    const entry: MemoryEntry = {\n      id,\n      type,\n      content: this.normalizeContent(content),\n      metadata: {\n        timestamp: new Date().toISOString(),\n        project: this.extractProjectName(),\n        frequency: 1,\n        lastAccessed: new Date().toISOString(),\n        success: true,\n        tags: [],\n        ...metadata\n      },\n      relations: []\n    };\n\n    // Generate embedding for semantic search\n    try {\n      entry.embedding = await this.generateEmbedding(content);\n    } catch (error) {\n      console.warn(`Failed to generate embedding for ${id}:`, error.message);\n    }\n\n    // Extract tags automatically\n    entry.metadata.tags = [\n      ...entry.metadata.tags,\n      ...this.extractTags(content, type)\n    ];\n\n    this.entries.set(id, entry);\n\n    // Enforce memory limits\n    await this.enforceMemoryLimits();\n    await this.persistMemory();\n\n    return id;\n  }\n\n  async retrieve(query: SemanticQuery): Promise<SemanticResult[]> {\n    let candidates = Array.from(this.entries.values());\n\n    // Filter by type\n    if (query.type && query.type.length > 0) {\n      candidates = candidates.filter(entry => query.type!.includes(entry.type));\n    }\n\n    // Filter by tags\n    if (query.tags && query.tags.length > 0) {\n      candidates = candidates.filter(entry => \n        query.tags!.some(tag => entry.metadata.tags.includes(tag))\n      );\n    }\n\n    // Semantic similarity search\n    const results: SemanticResult[] = [];\n    \n    if (candidates.length === 0) {\n      return results;\n    }\n\n    try {\n      const queryEmbedding = await this.generateEmbedding(query.query);\n      \n      for (const entry of candidates) {\n        if (!entry.embedding) continue;\n        \n        const similarity = this.cosineSimilarity(queryEmbedding, entry.embedding);\n        \n        if (similarity >= (query.similarity || 0.7)) {\n          results.push({\n            entry,\n            similarity,\n            rank: 0 // Will be set after sorting\n          });\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to perform semantic search, falling back to text search');\n      \n      // Fallback to text-based search\n      const queryLower = query.query.toLowerCase();\n      for (const entry of candidates) {\n        const contentLower = entry.content.toLowerCase();\n        \n        if (contentLower.includes(queryLower)) {\n          const similarity = this.textSimilarity(queryLower, contentLower);\n          results.push({\n            entry,\n            similarity,\n            rank: 0\n          });\n        }\n      }\n    }\n\n    // Sort by similarity and frequency\n    results.sort((a, b) => {\n      const scoreA = a.similarity * 0.7 + (a.entry.metadata.frequency / 100) * 0.3;\n      const scoreB = b.similarity * 0.7 + (b.entry.metadata.frequency / 100) * 0.3;\n      return scoreB - scoreA;\n    });\n\n    // Set ranks and limit results\n    results.forEach((result, index) => {\n      result.rank = index + 1;\n      // Update access time\n      result.entry.metadata.lastAccessed = new Date().toISOString();\n    });\n\n    const limited = results.slice(0, query.limit || 10);\n    \n    // Persist updated access times\n    if (limited.length > 0) {\n      await this.persistMemory();\n    }\n\n    return limited;\n  }\n\n  async addRelation(fromId: string, toId: string): Promise<void> {\n    const fromEntry = this.entries.get(fromId);\n    const toEntry = this.entries.get(toId);\n\n    if (fromEntry && toEntry) {\n      if (!fromEntry.relations.includes(toId)) {\n        fromEntry.relations.push(toId);\n      }\n      if (!toEntry.relations.includes(fromId)) {\n        toEntry.relations.push(fromId);\n      }\n      await this.persistMemory();\n    }\n  }\n\n  async recordSuccess(id: string, success: boolean): Promise<void> {\n    const entry = this.entries.get(id);\n    if (entry) {\n      entry.metadata.success = success;\n      entry.metadata.frequency += success ? 1 : -0.5;\n      entry.metadata.lastAccessed = new Date().toISOString();\n      await this.persistMemory();\n    }\n  }\n\n  async forget(id: string): Promise<void> {\n    this.entries.delete(id);\n    await this.persistMemory();\n  }\n\n  async cleanup(olderThanDays: number = 90): Promise<number> {\n    const cutoff = new Date();\n    cutoff.setDate(cutoff.getDate() - olderThanDays);\n    \n    let removed = 0;\n    for (const [id, entry] of this.entries.entries()) {\n      const lastAccessed = new Date(entry.metadata.lastAccessed);\n      \n      if (lastAccessed < cutoff && entry.metadata.frequency < 2) {\n        this.entries.delete(id);\n        removed++;\n      }\n    }\n\n    if (removed > 0) {\n      await this.persistMemory();\n    }\n\n    return removed;\n  }\n\n  async getStats(): Promise<{\n    totalEntries: number;\n    typeDistribution: Record<string, number>;\n    averageFrequency: number;\n    memorySize: number;\n  }> {\n    const typeDistribution: Record<string, number> = {};\n    let totalFrequency = 0;\n\n    for (const entry of this.entries.values()) {\n      typeDistribution[entry.type] = (typeDistribution[entry.type] || 0) + 1;\n      totalFrequency += entry.metadata.frequency;\n    }\n\n    return {\n      totalEntries: this.entries.size,\n      typeDistribution,\n      averageFrequency: totalFrequency / this.entries.size || 0,\n      memorySize: JSON.stringify(Array.from(this.entries.values())).length\n    };\n  }\n\n  private generateId(content: string, type: string): string {\n    return createHash('sha256')\n      .update(content + type)\n      .digest('hex')\n      .substring(0, 16);\n  }\n\n  private normalizeContent(content: string): string {\n    return content\n      .trim()\n      .replace(/\\s+/g, ' ')\n      .substring(0, 10000); // Limit content size\n  }\n\n  private extractProjectName(): string {\n    try {\n      const packageJson = require(join(process.cwd(), 'package.json'));\n      return packageJson.name || 'unknown';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private extractTags(content: string, type: string): string[] {\n    const tags: string[] = [];\n    \n    // Language/framework tags\n    const patterns = {\n      typescript: /\\.ts|interface|type|export/i,\n      javascript: /\\.js|function|const|let|var/i,\n      react: /jsx|tsx|useEffect|useState|Component/i,\n      node: /require|module\\.exports|process\\./i,\n      git: /git|commit|branch|merge/i,\n      test: /test|spec|describe|it\\(/i,\n      error: /error|exception|fail|throw/i,\n      api: /api|endpoint|route|express/i,\n      database: /sql|query|database|db\\./i,\n      security: /auth|token|password|security/i\n    };\n\n    for (const [tag, pattern] of Object.entries(patterns)) {\n      if (pattern.test(content)) {\n        tags.push(tag);\n      }\n    }\n\n    // Add type as tag\n    tags.push(type);\n\n    return [...new Set(tags)]; // Remove duplicates\n  }\n\n  private async generateEmbedding(text: string): Promise<number[]> {\n    // This would normally call OpenAI API or similar\n    // For now, we'll use a simple hash-based approach\n    const hash = createHash('sha256').update(text).digest();\n    const embedding: number[] = [];\n    \n    for (let i = 0; i < Math.min(this.vectorDimension, hash.length * 8); i++) {\n      const byteIndex = Math.floor(i / 8);\n      const bitIndex = i % 8;\n      const bit = (hash[byteIndex] >> bitIndex) & 1;\n      embedding.push(bit * 2 - 1); // Convert to -1 or 1\n    }\n\n    // Pad if necessary\n    while (embedding.length < this.vectorDimension) {\n      embedding.push(0);\n    }\n\n    return embedding.slice(0, this.vectorDimension);\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    if (a.length !== b.length) return 0;\n\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);\n    return magnitude === 0 ? 0 : dotProduct / magnitude;\n  }\n\n  private textSimilarity(query: string, content: string): number {\n    const queryWords = query.split(/\\s+/);\n    const contentWords = content.split(/\\s+/);\n    \n    const querySet = new Set(queryWords);\n    const contentSet = new Set(contentWords);\n    \n    const intersection = new Set([...querySet].filter(x => contentSet.has(x)));\n    const union = new Set([...querySet, ...contentSet]);\n    \n    return intersection.size / union.size; // Jaccard similarity\n  }\n\n  private async loadMemory(): Promise<void> {\n    try {\n      await access(this.indexPath);\n      const data = await readFile(this.indexPath, 'utf8');\n      const entries: MemoryEntry[] = JSON.parse(data);\n      \n      this.entries.clear();\n      for (const entry of entries) {\n        this.entries.set(entry.id, entry);\n      }\n    } catch (error) {\n      // File doesn't exist or is corrupted, start fresh\n      this.entries.clear();\n    }\n  }\n\n  private async persistMemory(): Promise<void> {\n    try {\n      const data = JSON.stringify(Array.from(this.entries.values()), null, 2);\n      await writeFile(this.indexPath, data);\n    } catch (error) {\n      console.warn('Failed to persist memory:', error.message);\n    }\n  }\n\n  private async enforceMemoryLimits(): Promise<void> {\n    if (this.entries.size <= this.maxEntries) return;\n\n    // Remove least frequently used entries\n    const sortedEntries = Array.from(this.entries.values())\n      .sort((a, b) => {\n        const scoreA = a.metadata.frequency + (Date.now() - new Date(a.metadata.lastAccessed).getTime()) / (1000 * 60 * 60 * 24);\n        const scoreB = b.metadata.frequency + (Date.now() - new Date(b.metadata.lastAccessed).getTime()) / (1000 * 60 * 60 * 24);\n        return scoreA - scoreB;\n      });\n\n    const toRemove = sortedEntries.slice(0, this.entries.size - this.maxEntries);\n    for (const entry of toRemove) {\n      this.entries.delete(entry.id);\n    }\n  }\n}"],"version":3}