5fc9c0a57ec591a101f49efcccae62b3
"use strict";
/**
 * Token counting utility for multi-provider LLM budgeting
 * Supports OpenAI, Anthropic, and Gemini models with pluggable counting
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.countOpenAITokens = countOpenAITokens;
exports.countAnthropicTokens = countAnthropicTokens;
exports.countGeminiTokens = countGeminiTokens;
exports.countTokens = countTokens;
exports.getModelFamily = getModelFamily;
exports.validateTokenBudget = validateTokenBudget;
exports.countVertexTokensExact = countVertexTokensExact;
// Model pricing per 1K tokens (input/output)
const MODEL_PRICING = {
    // OpenAI GPT-4 family
    "gpt-4o": { input: 0.0025, output: 0.01 },
    "gpt-4o-mini": { input: 0.00015, output: 0.0006 },
    "gpt-4-turbo": { input: 0.01, output: 0.03 },
    "gpt-3.5-turbo": { input: 0.0005, output: 0.0015 },
    // Anthropic Claude family
    "claude-3-5-sonnet-20241022": { input: 0.003, output: 0.015 },
    "claude-3-opus": { input: 0.015, output: 0.075 },
    "claude-3-haiku": { input: 0.00025, output: 0.00125 },
    // Gemini family
    "gemini-1.5-pro": { input: 0.00125, output: 0.005 },
    "gemini-1.5-flash": { input: 0.000075, output: 0.0003 },
};
function countOpenAITokens(model, text) {
    try {
        // Use gpt-tokenizer for accurate OpenAI counts
        const { encode } = require("gpt-tokenizer");
        return encode(text, model).length;
    }
    catch (error) {
        // Fallback estimation: ~4 chars per token
        return Math.max(1, Math.round(text.length / 4));
    }
}
function countAnthropicTokens(text) {
    // Anthropic estimation: ~3.5 chars per token (slightly more efficient than GPT)
    return Math.max(1, Math.round(text.length / 3.5));
}
function countGeminiTokens(text) {
    // Gemini estimation: ~4 chars per token
    return Math.max(1, Math.round(text.length / 4));
}
async function countTokens(provider, model, prompt, completion) {
    let promptTokens = 0;
    let completionTokens = 0;
    switch (provider) {
        case "openai":
            promptTokens = countOpenAITokens(model, prompt);
            completionTokens = completion ? countOpenAITokens(model, completion) : 0;
            break;
        case "anthropic":
            promptTokens = countAnthropicTokens(prompt);
            completionTokens = completion ? countAnthropicTokens(completion) : 0;
            break;
        case "gemini":
            promptTokens = countGeminiTokens(prompt);
            completionTokens = completion ? countGeminiTokens(completion) : 0;
            break;
        default:
            throw new Error(`Unsupported provider: ${provider}`);
    }
    const total = promptTokens + completionTokens;
    // Calculate estimated cost
    let estimatedCostUSD = 0;
    const pricing = MODEL_PRICING[model];
    if (pricing) {
        estimatedCostUSD = (promptTokens * pricing.input / 1000) + (completionTokens * pricing.output / 1000);
    }
    return {
        model,
        prompt: promptTokens,
        completion: completionTokens,
        total,
        estimatedCostUSD: Number(estimatedCostUSD.toFixed(6))
    };
}
function getModelFamily(model) {
    if (model.startsWith("gpt-") || model.includes("openai"))
        return "openai";
    if (model.startsWith("claude-") || model.includes("anthropic"))
        return "anthropic";
    if (model.startsWith("gemini-") || model.includes("google"))
        return "gemini";
    // Default to openai for unknown models
    return "openai";
}
function validateTokenBudget(tokens, budgetLimit = 120000) {
    const percentUsed = (tokens / budgetLimit) * 100;
    let recommendAction = 'proceed';
    if (percentUsed >= 100)
        recommendAction = 'block';
    else if (percentUsed >= 80)
        recommendAction = 'warn';
    return {
        withinBudget: tokens <= budgetLimit,
        percentUsed: Number(percentUsed.toFixed(2)),
        recommendAction
    };
}
async function countVertexTokensExact(model, text) {
    // For production: exact token count from Vertex AI
    // This would call the actual Vertex Count Tokens API
    // For now, fallback to estimation
    return countGeminiTokens(text);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2JyaWFubG9uZy9EZXZlbG9wZXIvc3VtbWl0L3NlcnZlci9zcmMvbGliL3Rva2NvdW50LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBNkJILDhDQVNDO0FBRUQsb0RBR0M7QUFFRCw4Q0FHQztBQUVELGtDQTZDQztBQUVELHdDQU9DO0FBRUQsa0RBZ0JDO0FBRUQsd0RBS0M7QUF0SEQsNkNBQTZDO0FBQzdDLE1BQU0sYUFBYSxHQUFzRDtJQUN2RSxzQkFBc0I7SUFDdEIsUUFBUSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0lBQ3pDLGFBQWEsRUFBRSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTtJQUNqRCxhQUFhLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7SUFDNUMsZUFBZSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0lBRWxELDBCQUEwQjtJQUMxQiw0QkFBNEIsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUM3RCxlQUFlLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDaEQsZ0JBQWdCLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUU7SUFFckQsZ0JBQWdCO0lBQ2hCLGdCQUFnQixFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0lBQ25ELGtCQUFrQixFQUFFLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0NBQ3hELENBQUM7QUFFRixTQUFnQixpQkFBaUIsQ0FBQyxLQUFhLEVBQUUsSUFBWTtJQUMzRCxJQUFJLENBQUM7UUFDSCwrQ0FBK0M7UUFDL0MsTUFBTSxFQUFF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LENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUFFLE9BQU8sUUFBUSxDQUFDO0lBQzFFLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUFFLE9BQU8sV0FBVyxDQUFDO0lBQ25GLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUFFLE9BQU8sUUFBUSxDQUFDO0lBRTdFLHVDQUF1QztJQUN2QyxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsU0FBZ0IsbUJBQW1CLENBQUMsTUFBYyxFQUFFLGNBQXNCLE1BQU07SUFLOUUsTUFBTSxXQUFXLEdBQUcsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBRWpELElBQUksZUFBZSxHQUFpQyxTQUFTLENBQUM7SUFDOUQsSUFBSSxXQUFXLElBQUksR0FBRztRQUFFLGVBQWUsR0FBRyxPQUFPLENBQUM7U0FDN0MsSUFBSSxXQUFXLElBQUksRUFBRTtRQUFFLGVBQWUsR0FBRyxNQUFNLENBQUM7SUFFckQsT0FBTztRQUNMLFlBQVksRUFBRSxNQUFNLElBQUksV0FBVztRQUNuQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0MsZUFBZTtLQUNoQixDQUFDO0FBQ0osQ0FBQztBQUVNLEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxLQUFhLEVBQUUsSUFBWTtJQUN0RSxtREFBbUQ7SUFDbkQscURBQXFEO0lBQ3JELGtDQUFrQztJQUNsQyxPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2JyaWFubG9uZy9EZXZlbG9wZXIvc3VtbWl0L3NlcnZlci9zcmMvbGliL3Rva2NvdW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG9rZW4gY291bnRpbmcgdXRpbGl0eSBmb3IgbXVsdGktcHJvdmlkZXIgTExNIGJ1ZGdldGluZ1xuICogU3VwcG9ydHMgT3BlbkFJLCBBbnRocm9waWMsIGFuZCBHZW1pbmkgbW9kZWxzIHdpdGggcGx1Z2dhYmxlIGNvdW50aW5nXG4gKi9cblxuZXhwb3J0IHR5cGUgTW9kZWxGYW1pbHkgPSBcIm9wZW5haVwiIHwgXCJhbnRocm9waWNcIiB8IFwiZ2VtaW5pXCI7XG5leHBvcnQgdHlwZSBUb2tDb3VudFJlc3VsdCA9IHsgXG4gIG1vZGVsOiBzdHJpbmc7IFxuICBwcm9tcHQ6IG51bWJlcjsgXG4gIGNvbXBsZXRpb24/OiBudW1iZXI7IFxuICB0b3RhbDogbnVtYmVyO1xuICBlc3RpbWF0ZWRDb3N0VVNEPzogbnVtYmVyO1xufTtcblxuLy8gTW9kZWwgcHJpY2luZyBwZXIgMUsgdG9rZW5zIChpbnB1dC9vdXRwdXQpXG5jb25zdCBNT0RFTF9QUklDSU5HOiBSZWNvcmQ8c3RyaW5nLCB7IGlucHV0OiBudW1iZXI7IG91dHB1dDogbnVtYmVyIH0+ID0ge1xuICAvLyBPcGVuQUkgR1BULTQgZmFtaWx5XG4gIFwiZ3B0LTRvXCI6IHsgaW5wdXQ6IDAuMDAyNSwgb3V0cHV0OiAwLjAxIH0sXG4gIFwiZ3B0LTRvLW1pbmlcIjogeyBpbnB1dDogMC4wMDAxNSwgb3V0cHV0OiAwLjAwMDYgfSxcbiAgXCJncHQtNC10dXJib1wiOiB7IGlucHV0OiAwLjAxLCBvdXRwdXQ6IDAuMDMgfSxcbiAgXCJncHQtMy41LXR1cmJvXCI6IHsgaW5wdXQ6IDAuMDAwNSwgb3V0cHV0OiAwLjAwMTUgfSxcbiAgXG4gIC8vIEFudGhyb3BpYyBDbGF1ZGUgZmFtaWx5XG4gIFwiY2xhdWRlLTMtNS1zb25uZXQtMjAyNDEwMjJcIjogeyBpbnB1dDogMC4wMDMsIG91dHB1dDogMC4wMTUgfSxcbiAgXCJjbGF1ZGUtMy1vcHVzXCI6IHsgaW5wdXQ6IDAuMDE1LCBvdXRwdXQ6IDAuMDc1IH0sXG4gIFwiY2xhdWRlLTMtaGFpa3VcIjogeyBpbnB1dDogMC4wMDAyNSwgb3V0cHV0OiAwLjAwMTI1IH0sXG4gIFxuICAvLyBHZW1pbmkgZmFtaWx5XG4gIFwiZ2VtaW5pLTEuNS1wcm9cIjogeyBpbnB1dDogMC4wMDEyNSwgb3V0cHV0OiAwLjAwNSB9LFxuICBcImdlbWluaS0xLjUtZmxhc2hcIjogeyBpbnB1dDogMC4wMDAwNzUsIG91dHB1dDogMC4wMDAzIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY291bnRPcGVuQUlUb2tlbnMobW9kZWw6IHN0cmluZywgdGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgZ3B0LXRva2VuaXplciBmb3IgYWNjdXJhdGUgT3BlbkFJIGNvdW50c1xuICAgIGNvbnN0IHsgZW5jb2RlIH0gPSByZXF1aXJlKFwiZ3B0LXRva2VuaXplclwiKTtcbiAgICByZXR1cm4gZW5jb2RlKHRleHQsIG1vZGVsKS5sZW5ndGg7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRmFsbGJhY2sgZXN0aW1hdGlvbjogfjQgY2hhcnMgcGVyIHRva2VuXG4gICAgcmV0dXJuIE1hdGgubWF4KDEsIE1hdGgucm91bmQodGV4dC5sZW5ndGggLyA0KSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50QW50aHJvcGljVG9rZW5zKHRleHQ6IHN0cmluZyk6IG51bWJlciB7XG4gIC8vIEFudGhyb3BpYyBlc3RpbWF0aW9uOiB+My41IGNoYXJzIHBlciB0b2tlbiAoc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgdGhhbiBHUFQpXG4gIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHRleHQubGVuZ3RoIC8gMy41KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudEdlbWluaVRva2Vucyh0ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICAvLyBHZW1pbmkgZXN0aW1hdGlvbjogfjQgY2hhcnMgcGVyIHRva2VuXG4gIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHRleHQubGVuZ3RoIC8gNCkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY291bnRUb2tlbnMoXG4gIHByb3ZpZGVyOiBNb2RlbEZhbWlseSxcbiAgbW9kZWw6IHN0cmluZyxcbiAgcHJvbXB0OiBzdHJpbmcsXG4gIGNvbXBsZXRpb24/OiBzdHJpbmdcbik6IFByb21pc2U8VG9rQ291bnRSZXN1bHQ+IHtcbiAgbGV0IHByb21wdFRva2VucyA9IDA7XG4gIGxldCBjb21wbGV0aW9uVG9rZW5zID0gMDtcblxuICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgY2FzZSBcIm9wZW5haVwiOlxuICAgICAgcHJvbXB0VG9rZW5zID0gY291bnRPcGVuQUlUb2tlbnMobW9kZWwsIHByb21wdCk7XG4gICAgICBjb21wbGV0aW9uVG9rZW5zID0gY29tcGxldGlvbiA/IGNvdW50T3BlbkFJVG9rZW5zKG1vZGVsLCBjb21wbGV0aW9uKSA6IDA7XG4gICAgICBicmVhaztcbiAgICBcbiAgICBjYXNlIFwiYW50aHJvcGljXCI6XG4gICAgICBwcm9tcHRUb2tlbnMgPSBjb3VudEFudGhyb3BpY1Rva2Vucyhwcm9tcHQpO1xuICAgICAgY29tcGxldGlvblRva2VucyA9IGNvbXBsZXRpb24gPyBjb3VudEFudGhyb3BpY1Rva2Vucyhjb21wbGV0aW9uKSA6IDA7XG4gICAgICBicmVhaztcbiAgICBcbiAgICBjYXNlIFwiZ2VtaW5pXCI6XG4gICAgICBwcm9tcHRUb2tlbnMgPSBjb3VudEdlbWluaVRva2Vucyhwcm9tcHQpO1xuICAgICAgY29tcGxldGlvblRva2VucyA9IGNvbXBsZXRpb24gPyBjb3VudEdlbWluaVRva2Vucyhjb21wbGV0aW9uKSA6IDA7XG4gICAgICBicmVhaztcbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gKTtcbiAgfVxuXG4gIGNvbnN0IHRvdGFsID0gcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2VucztcbiAgXG4gIC8vIENhbGN1bGF0ZSBlc3RpbWF0ZWQgY29zdFxuICBsZXQgZXN0aW1hdGVkQ29zdFVTRCA9IDA7XG4gIGNvbnN0IHByaWNpbmcgPSBNT0RFTF9QUklDSU5HW21vZGVsXTtcbiAgaWYgKHByaWNpbmcpIHtcbiAgICBlc3RpbWF0ZWRDb3N0VVNEID0gKHByb21wdFRva2VucyAqIHByaWNpbmcuaW5wdXQgLyAxMDAwKSArIChjb21wbGV0aW9uVG9rZW5zICogcHJpY2luZy5vdXRwdXQgLyAxMDAwKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbW9kZWwsXG4gICAgcHJvbXB0OiBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvbjogY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbCxcbiAgICBlc3RpbWF0ZWRDb3N0VVNEOiBOdW1iZXIoZXN0aW1hdGVkQ29zdFVTRC50b0ZpeGVkKDYpKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kZWxGYW1pbHkobW9kZWw6IHN0cmluZyk6IE1vZGVsRmFtaWx5IHtcbiAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoXCJncHQtXCIpIHx8IG1vZGVsLmluY2x1ZGVzKFwib3BlbmFpXCIpKSByZXR1cm4gXCJvcGVuYWlcIjtcbiAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoXCJjbGF1ZGUtXCIpIHx8IG1vZGVsLmluY2x1ZGVzKFwiYW50aHJvcGljXCIpKSByZXR1cm4gXCJhbnRocm9waWNcIjtcbiAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoXCJnZW1pbmktXCIpIHx8IG1vZGVsLmluY2x1ZGVzKFwiZ29vZ2xlXCIpKSByZXR1cm4gXCJnZW1pbmlcIjtcbiAgXG4gIC8vIERlZmF1bHQgdG8gb3BlbmFpIGZvciB1bmtub3duIG1vZGVsc1xuICByZXR1cm4gXCJvcGVuYWlcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5CdWRnZXQodG9rZW5zOiBudW1iZXIsIGJ1ZGdldExpbWl0OiBudW1iZXIgPSAxMjAwMDApOiB7XG4gIHdpdGhpbkJ1ZGdldDogYm9vbGVhbjtcbiAgcGVyY2VudFVzZWQ6IG51bWJlcjtcbiAgcmVjb21tZW5kQWN0aW9uOiAncHJvY2VlZCcgfCAnd2FybicgfCAnYmxvY2snO1xufSB7XG4gIGNvbnN0IHBlcmNlbnRVc2VkID0gKHRva2VucyAvIGJ1ZGdldExpbWl0KSAqIDEwMDtcbiAgXG4gIGxldCByZWNvbW1lbmRBY3Rpb246ICdwcm9jZWVkJyB8ICd3YXJuJyB8ICdibG9jaycgPSAncHJvY2VlZCc7XG4gIGlmIChwZXJjZW50VXNlZCA+PSAxMDApIHJlY29tbWVuZEFjdGlvbiA9ICdibG9jayc7XG4gIGVsc2UgaWYgKHBlcmNlbnRVc2VkID49IDgwKSByZWNvbW1lbmRBY3Rpb24gPSAnd2Fybic7XG4gIFxuICByZXR1cm4ge1xuICAgIHdpdGhpbkJ1ZGdldDogdG9rZW5zIDw9IGJ1ZGdldExpbWl0LFxuICAgIHBlcmNlbnRVc2VkOiBOdW1iZXIocGVyY2VudFVzZWQudG9GaXhlZCgyKSksXG4gICAgcmVjb21tZW5kQWN0aW9uXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3VudFZlcnRleFRva2Vuc0V4YWN0KG1vZGVsOiBzdHJpbmcsIHRleHQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gIC8vIEZvciBwcm9kdWN0aW9uOiBleGFjdCB0b2tlbiBjb3VudCBmcm9tIFZlcnRleCBBSVxuICAvLyBUaGlzIHdvdWxkIGNhbGwgdGhlIGFjdHVhbCBWZXJ0ZXggQ291bnQgVG9rZW5zIEFQSVxuICAvLyBGb3Igbm93LCBmYWxsYmFjayB0byBlc3RpbWF0aW9uXG4gIHJldHVybiBjb3VudEdlbWluaVRva2Vucyh0ZXh0KTtcbn0iXSwidmVyc2lvbiI6M30=