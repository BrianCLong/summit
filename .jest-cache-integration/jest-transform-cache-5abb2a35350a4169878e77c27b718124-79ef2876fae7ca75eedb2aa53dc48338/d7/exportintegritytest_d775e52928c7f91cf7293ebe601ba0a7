ce0e66f4bc2457771f4b7ce34e7d4252
// Proper Jest mock setup
jest.mock('archiver');
describe('export integrity', () => {
    const archiver = require('archiver');
    beforeEach(() => {
        // Reset the mock before each test
        jest.clearAllMocks();
    });
    it('bundles expected files and finalizes', async () => {
        // Create a mock archiver instance  
        const zipMock = {
            calls: { append: [], file: [], directory: [] },
            pipe: jest.fn(),
            append: jest.fn((x) => void zipMock.calls.append.push(x)),
            file: jest.fn((x) => void zipMock.calls.file.push(x)),
            directory: jest.fn((x) => void zipMock.calls.directory.push(x)),
            on: jest.fn(),
            finalize: jest.fn(async () => {
                // Find all 'finish' listeners and call them
                const finishListeners = zipMock.on.mock.calls
                    .filter(call => call[0] === 'finish')
                    .map(call => call[1]);
                for (const listener of finishListeners) {
                    listener();
                }
            })
        };
        // Mock the archiver.create method to return our mock
        archiver.create.mockReturnValue(zipMock);
        const zip = archiver.create('zip');
        // Simulate adding content to the archive
        zip.append('readme content', { name: 'README.md' });
        zip.file('path/to/data.json');
        zip.directory('assets/', 'assets');
        // Flag to track if finish event was triggered
        let finishCalled = false;
        zip.on('finish', () => {
            finishCalled = true;
        });
        // Finalize the archive (this should trigger the finish event)
        await zip.finalize();
        // Assert that operations were recorded
        expect(zip.calls.append.length + zip.calls.file.length + zip.calls.directory.length).toBeGreaterThan(0);
        expect(zip.calls.append).toContainEqual('readme content');
        expect(zip.calls.file).toContainEqual('path/to/data.json');
        expect(zip.calls.directory).toContainEqual('assets/');
        // Assert that finish event was called
        expect(finishCalled).toBe(true);
        // Verify archiver was called with correct format
        expect(archiver.create).toHaveBeenCalledWith('zip');
    });
    it('handles export failure gracefully', () => {
        const zipMock = {
            calls: { append: [], file: [], directory: [] },
            pipe: jest.fn(),
            append: jest.fn((x) => void zipMock.calls.append.push(x)),
            file: jest.fn((x) => void zipMock.calls.file.push(x)),
            directory: jest.fn((x) => void zipMock.calls.directory.push(x)),
            on: jest.fn(),
            finalize: jest.fn(async () => {
                // Find all 'finish' listeners and call them
                const finishListeners = zipMock.on.mock.calls
                    .filter(call => call[0] === 'finish')
                    .map(call => call[1]);
                for (const listener of finishListeners) {
                    listener();
                }
            })
        };
        // Mock the archiver.create method to return our mock
        archiver.create.mockReturnValue(zipMock);
        const zip = archiver.create('zip');
        // Don't call finalize, so finish event should not be triggered
        let finishCalled = false;
        zip.on('finish', () => {
            finishCalled = true;
        });
        // Only add some content but don't finalize
        zip.append('content', { name: 'file.txt' });
        // Assert operations were recorded but finish was not called (since finalize() wasn't called)
        expect(zip.calls.append).toContainEqual('content');
        expect(finishCalled).toBe(false); // This should be false because finalize() wasn't called
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2JyaWFubG9uZy9EZXZlbG9wZXIvc3VtbWl0L3Rlc3RzL2ludGVncmF0aW9uL2V4cG9ydC1pbnRlZ3JpdHkudGVzdC50cyIsIm1hcHBpbmdzIjoiQUFBQSx5QkFBeUI7QUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUV0QixRQUFRLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxFQUFFO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVyQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2Qsa0NBQWtDO1FBQ2xDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyxzQ0FBc0MsRUFBRSxLQUFLLElBQUksRUFBRTtRQUNwRCxvQ0FBb0M7UUFDcEMsTUFBTSxPQUFPLEdBQUc7WUFDZCxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRTtZQUM5QyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNmLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6RCxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckQsU0FBUyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9ELEVBQUUsRUFBRSxJQUFJ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QUUsQ0FBQyxDQUFDO1FBRTVDLDZGQUE2RjtRQUM3RixNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkQsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLHdEQUF3RDtJQUM1RixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmlhbmxvbmcvRGV2ZWxvcGVyL3N1bW1pdC90ZXN0cy9pbnRlZ3JhdGlvbi9leHBvcnQtaW50ZWdyaXR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvcGVyIEplc3QgbW9jayBzZXR1cFxuamVzdC5tb2NrKCdhcmNoaXZlcicpO1xuXG5kZXNjcmliZSgnZXhwb3J0IGludGVncml0eScsICgpID0+IHtcbiAgY29uc3QgYXJjaGl2ZXIgPSByZXF1aXJlKCdhcmNoaXZlcicpO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIFJlc2V0IHRoZSBtb2NrIGJlZm9yZSBlYWNoIHRlc3RcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ2J1bmRsZXMgZXhwZWN0ZWQgZmlsZXMgYW5kIGZpbmFsaXplcycsIGFzeW5jICgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtb2NrIGFyY2hpdmVyIGluc3RhbmNlICBcbiAgICBjb25zdCB6aXBNb2NrID0ge1xuICAgICAgY2FsbHM6IHsgYXBwZW5kOiBbXSwgZmlsZTogW10sIGRpcmVjdG9yeTogW10gfSxcbiAgICAgIHBpcGU6IGplc3QuZm4oKSxcbiAgICAgIGFwcGVuZDogamVzdC5mbigoeCkgPT4gdm9pZCB6aXBNb2NrLmNhbGxzLmFwcGVuZC5wdXNoKHgpKSxcbiAgICAgIGZpbGU6IGplc3QuZm4oKHgpID0+IHZvaWQgemlwTW9jay5jYWxscy5maWxlLnB1c2goeCkpLFxuICAgICAgZGlyZWN0b3J5OiBqZXN0LmZuKCh4KSA9PiB2b2lkIHppcE1vY2suY2FsbHMuZGlyZWN0b3J5LnB1c2goeCkpLFxuICAgICAgb246IGplc3QuZm4oKSxcbiAgICAgIGZpbmFsaXplOiBqZXN0LmZuKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gRmluZCBhbGwgJ2ZpbmlzaCcgbGlzdGVuZXJzIGFuZCBjYWxsIHRoZW1cbiAgICAgICAgY29uc3QgZmluaXNoTGlzdGVuZXJzID0gemlwTW9jay5vbi5tb2NrLmNhbGxzXG4gICAgICAgICAgLmZpbHRlcihjYWxsID0+IGNhbGxbMF0gPT09ICdmaW5pc2gnKVxuICAgICAgICAgIC5tYXAoY2FsbCA9PiBjYWxsWzFdKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgZmluaXNoTGlzdGVuZXJzKSB7XG4gICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuXG4gICAgLy8gTW9jayB0aGUgYXJjaGl2ZXIuY3JlYXRlIG1ldGhvZCB0byByZXR1cm4gb3VyIG1vY2tcbiAgICBhcmNoaXZlci5jcmVhdGUubW9ja1JldHVyblZhbHVlKHppcE1vY2spO1xuXG4gICAgY29uc3QgemlwID0gYXJjaGl2ZXIuY3JlYXRlKCd6aXAnKTtcbiAgICBcbiAgICAvLyBTaW11bGF0ZSBhZGRpbmcgY29udGVudCB0byB0aGUgYXJjaGl2ZVxuICAgIHppcC5hcHBlbmQoJ3JlYWRtZSBjb250ZW50JywgeyBuYW1lOiAnUkVBRE1FLm1kJyB9KTtcbiAgICB6aXAuZmlsZSgncGF0aC90by9kYXRhLmpzb24nKTtcbiAgICB6aXAuZGlyZWN0b3J5KCdhc3NldHMvJywgJ2Fzc2V0cycpO1xuICAgIFxuICAgIC8vIEZsYWcgdG8gdHJhY2sgaWYgZmluaXNoIGV2ZW50IHdhcyB0cmlnZ2VyZWRcbiAgICBsZXQgZmluaXNoQ2FsbGVkID0gZmFsc2U7XG4gICAgemlwLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBmaW5pc2hDYWxsZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEZpbmFsaXplIHRoZSBhcmNoaXZlICh0aGlzIHNob3VsZCB0cmlnZ2VyIHRoZSBmaW5pc2ggZXZlbnQpXG4gICAgYXdhaXQgemlwLmZpbmFsaXplKCk7XG4gICAgXG4gICAgLy8gQXNzZXJ0IHRoYXQgb3BlcmF0aW9ucyB3ZXJlIHJlY29yZGVkXG4gICAgZXhwZWN0KHppcC5jYWxscy5hcHBlbmQubGVuZ3RoICsgemlwLmNhbGxzLmZpbGUubGVuZ3RoICsgemlwLmNhbGxzLmRpcmVjdG9yeS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICBleHBlY3QoemlwLmNhbGxzLmFwcGVuZCkudG9Db250YWluRXF1YWwoJ3JlYWRtZSBjb250ZW50Jyk7XG4gICAgZXhwZWN0KHppcC5jYWxscy5maWxlKS50b0NvbnRhaW5FcXVhbCgncGF0aC90by9kYXRhLmpzb24nKTtcbiAgICBleHBlY3QoemlwLmNhbGxzLmRpcmVjdG9yeSkudG9Db250YWluRXF1YWwoJ2Fzc2V0cy8nKTtcbiAgICBcbiAgICAvLyBBc3NlcnQgdGhhdCBmaW5pc2ggZXZlbnQgd2FzIGNhbGxlZFxuICAgIGV4cGVjdChmaW5pc2hDYWxsZWQpLnRvQmUodHJ1ZSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IGFyY2hpdmVyIHdhcyBjYWxsZWQgd2l0aCBjb3JyZWN0IGZvcm1hdFxuICAgIGV4cGVjdChhcmNoaXZlci5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd6aXAnKTtcbiAgfSk7XG4gIFxuICBpdCgnaGFuZGxlcyBleHBvcnQgZmFpbHVyZSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgIGNvbnN0IHppcE1vY2sgPSB7XG4gICAgICBjYWxsczogeyBhcHBlbmQ6IFtdLCBmaWxlOiBbXSwgZGlyZWN0b3J5OiBbXSB9LFxuICAgICAgcGlwZTogamVzdC5mbigpLFxuICAgICAgYXBwZW5kOiBqZXN0LmZuKCh4KSA9PiB2b2lkIHppcE1vY2suY2FsbHMuYXBwZW5kLnB1c2goeCkpLFxuICAgICAgZmlsZTogamVzdC5mbigoeCkgPT4gdm9pZCB6aXBNb2NrLmNhbGxzLmZpbGUucHVzaCh4KSksXG4gICAgICBkaXJlY3Rvcnk6IGplc3QuZm4oKHgpID0+IHZvaWQgemlwTW9jay5jYWxscy5kaXJlY3RvcnkucHVzaCh4KSksXG4gICAgICBvbjogamVzdC5mbigpLFxuICAgICAgZmluYWxpemU6IGplc3QuZm4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBGaW5kIGFsbCAnZmluaXNoJyBsaXN0ZW5lcnMgYW5kIGNhbGwgdGhlbVxuICAgICAgICBjb25zdCBmaW5pc2hMaXN0ZW5lcnMgPSB6aXBNb2NrLm9uLm1vY2suY2FsbHNcbiAgICAgICAgICAuZmlsdGVyKGNhbGwgPT4gY2FsbFswXSA9PT0gJ2ZpbmlzaCcpXG4gICAgICAgICAgLm1hcChjYWxsID0+IGNhbGxbMV0pO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBmaW5pc2hMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG5cbiAgICAvLyBNb2NrIHRoZSBhcmNoaXZlci5jcmVhdGUgbWV0aG9kIHRvIHJldHVybiBvdXIgbW9ja1xuICAgIGFyY2hpdmVyLmNyZWF0ZS5tb2NrUmV0dXJuVmFsdWUoemlwTW9jayk7XG5cbiAgICBjb25zdCB6aXAgPSBhcmNoaXZlci5jcmVhdGUoJ3ppcCcpO1xuICAgIFxuICAgIC8vIERvbid0IGNhbGwgZmluYWxpemUsIHNvIGZpbmlzaCBldmVudCBzaG91bGQgbm90IGJlIHRyaWdnZXJlZFxuICAgIGxldCBmaW5pc2hDYWxsZWQgPSBmYWxzZTtcbiAgICB6aXAub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIGZpbmlzaENhbGxlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gT25seSBhZGQgc29tZSBjb250ZW50IGJ1dCBkb24ndCBmaW5hbGl6ZVxuICAgIHppcC5hcHBlbmQoJ2NvbnRlbnQnLCB7IG5hbWU6ICdmaWxlLnR4dCcgfSk7XG4gICAgXG4gICAgLy8gQXNzZXJ0IG9wZXJhdGlvbnMgd2VyZSByZWNvcmRlZCBidXQgZmluaXNoIHdhcyBub3QgY2FsbGVkIChzaW5jZSBmaW5hbGl6ZSgpIHdhc24ndCBjYWxsZWQpXG4gICAgZXhwZWN0KHppcC5jYWxscy5hcHBlbmQpLnRvQ29udGFpbkVxdWFsKCdjb250ZW50Jyk7XG4gICAgZXhwZWN0KGZpbmlzaENhbGxlZCkudG9CZShmYWxzZSk7IC8vIFRoaXMgc2hvdWxkIGJlIGZhbHNlIGJlY2F1c2UgZmluYWxpemUoKSB3YXNuJ3QgY2FsbGVkXG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=