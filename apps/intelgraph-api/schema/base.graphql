# Entities & Relationships (SDL)

type Organization {
  id: ID!
  name: String!
  region: String
  createdAt: String!
}
type Tenant {
  id: ID!
  orgId: ID!
  name: String!
  createdAt: String!
}
type User {
  id: ID!
  tenantId: ID!
  email: String!
  roles: [Role!]!
  createdAt: String!
} # Updated to link to Role
type Role {
  id: ID!
  name: String!
  permissions: [Permission!]!
  createdAt: String!
} # New Role type
type Permission {
  id: ID!
  name: String!
  description: String
  createdAt: String!
} # New Permission type
type Policy {
  id: ID!
  tenantId: ID!
  name: String!
  version: String!
  body: String!
  createdAt: String!
} # Added tenantId for scoping
type Asset {
  id: ID!
  tenantId: ID!
  kind: String!
  uri: String
  labels: [String!]
  createdAt: String!
}
type DataSet {
  id: ID!
  tenantId: ID!
  name: String!
  source: String
  createdAt: String!
}
type Model {
  id: ID!
  tenantId: ID!
  name: String!
  version: String!
  createdAt: String!
}
type Eval {
  id: ID!
  tenantId: ID!
  modelId: ID!
  name: String!
  score: Float
  reportURI: String
  createdAt: String!
} # Added tenantId for scoping
type Task {
  id: ID!
  tenantId: ID!
  planId: ID!
  name: String!
  status: String!
  createdAt: String!
  updatedAt: String
} # Added tenantId for scoping
type Plan {
  id: ID!
  tenantId: ID!
  name: String!
  status: String!
  createdAt: String!
  updatedAt: String
} # Added tenantId for scoping
type Artifact {
  id: ID!
  tenantId: ID!
  planId: ID!
  kind: String!
  uri: String!
  hash: String
  signature: String
  createdAt: String!
} # Added tenantId for scoping
type Incident {
  id: ID!
  tenantId: ID!
  severity: String!
  description: String!
  createdAt: String!
}
type Risk {
  id: ID!
  tenantId: ID!
  category: String!
  level: String!
  createdAt: String!
}
type Control {
  id: ID!
  tenantId: ID!
  name: String!
  evidenceURI: String
  createdAt: String!
}
type KPI {
  id: ID!
  tenantId: ID!
  name: String!
  value: Float!
  ts: String!
}
type OKR {
  id: ID!
  tenantId: ID!
  objective: String!
  keyResults: [String!]!
  ts: String!
}

type Provenance {
  who: String!
  when: String!
  tool: String!
  model: String
  data_lineage: String
  hash: String
  signature: String
  user_id: ID # New field
  service_account_id: ID # New field
  artifact_hash: String # New field for artifact content hash
}

enum CommunityDetectionAlgorithm {
  LOUVAIN
  LABEL_PROPAGATION
}

enum CentralityAlgorithm {
  PAGERANK
  BETWEENNESS
}

enum RelationshipDirection {
  OUTGOING
  INCOMING
  UNDIRECTED
}

enum TemporalEntityType {
  NODE
  RELATIONSHIP
}

enum TemporalInterval {
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
  YEAR
}

type AnalyticsMetadata {
  generatedAt: String!
  nodeCount: Int!
  edgeCount: Int!
  runtimeMs: Float!
}

type CommunityDetectionCommunity {
  communityId: Int!
  nodes: [ID!]!
  size: Int!
  score: Float!
}

type CommunityDetectionResult {
  algorithm: CommunityDetectionAlgorithm!
  communities: [CommunityDetectionCommunity!]!
  metadata: AnalyticsMetadata!
}

input CommunityDetectionInput {
  algorithm: CommunityDetectionAlgorithm!
  nodeLabels: [String!]
  relationshipTypes: [String!]
  minCommunitySize: Int
  maxIterations: Int
  weightProperty: String
  maxEdges: Int
}

type CentralityScore {
  nodeId: ID!
  score: Float!
  rank: Int!
}

input CentralityInput {
  algorithm: CentralityAlgorithm!
  nodeLabels: [String!]
  relationshipTypes: [String!]
  maxResults: Int
  dampingFactor: Float
  tolerance: Float
  maxIterations: Int
  direction: RelationshipDirection
  weightProperty: String
  maxEdges: Int
}

type PathNode {
  id: ID!
  labels: [String!]!
}

type PathEdge {
  id: ID
  type: String!
  weight: Float!
}

type PathResult {
  sourceId: ID!
  targetId: ID!
  hops: Int!
  totalCost: Float
  nodes: [PathNode!]!
  edges: [PathEdge!]!
}

input ShortestPathInput {
  sourceId: ID!
  targetId: ID!
  relationshipTypes: [String!]
  maxDepth: Int
  direction: RelationshipDirection
  weightProperty: String
}

type AnomalyMetric {
  key: String!
  value: Float!
}

type GraphAnomaly {
  nodeId: ID!
  score: Float!
  reason: String!
  metrics: [AnomalyMetric!]!
}

input GraphAnomalyInput {
  nodeLabels: [String!]
  relationshipTypes: [String!]
  weightProperty: String
  sensitivity: Float
  minScore: Float
  maxEdges: Int
}

type TemporalMetric {
  bucket: String!
  count: Int!
  avgDegree: Float!
}

input TemporalPatternInput {
  entity: TemporalEntityType!
  nodeLabels: [String!]
  relationshipTypes: [String!]
  timestampProperty: String!
  interval: TemporalInterval!
  maxEntries: Int
  since: String
  until: String
}

type Query {
  org(id: ID!): Organization
  tenant(id: ID!): Tenant
  user(id: ID!): User
  roles: [Role!]! # New query for roles
  permissions: [Permission!]! # New query for permissions
  graphCommunityDetection(input: CommunityDetectionInput!): CommunityDetectionResult!
  graphCentrality(input: CentralityInput!): [CentralityScore!]!
  graphShortestPath(input: ShortestPathInput!): PathResult
  graphAnomalies(input: GraphAnomalyInput!): [GraphAnomaly!]!
  graphTemporalPatterns(input: TemporalPatternInput!): [TemporalMetric!]!
}

type Mutation {
  upsertPolicy(
    tenantId: ID!
    name: String!
    version: String!
    body: String!
  ): Policy! # Added tenantId for scoping
  recordArtifact(
    tenantId: ID!
    planId: ID!
    kind: String!
    uri: String!
    hash: String
    signature: String
    userId: ID
    serviceAccountId: ID
    artifactHash: String
  ): Artifact! # Added tenantId and provenance fields
  assignRoleToUser(userId: ID!, roleId: ID!): User! # New mutation
  createRole(name: String!, permissionIds: [ID!]): Role! # New mutation
  createPermission(name: String!, description: String): Permission! # New mutation
}
