import { promises as fs } from 'node:fs';
import path from 'node:path';
import { parseSimpleYaml } from './simple-yaml.js';

const HEADER_JS = '// Generated by Consent-Constraint Compiler. Do not edit manually.\n';
const HEADER_PY = '# Generated by Consent-Constraint Compiler. Do not edit manually.\n';
const HEADER_GO = '// Generated by Consent-Constraint Compiler. Do not edit manually.\n';

/**
 * @param {string} content
 */
export function parsePolicy(content) {
  const data = parseSimpleYaml(content);
  if (!data || typeof data !== 'object') {
    throw new Error('Invalid policy file: root must be an object');
  }

  const root = /** @type {Record<string, unknown>} */ (data);
  const version = typeof root.version === 'string' ? root.version : '1.0.0';

  const clausesRaw = root.clauses;
  if (!Array.isArray(clausesRaw)) {
    throw new Error('Invalid policy file: `clauses` must be an array');
  }

  const clauses = clausesRaw.map((item, index) => {
    if (!item || typeof item !== 'object') {
      throw new Error(`Clause at index ${index} must be an object`);
    }
    const clause = /** @type {Record<string, unknown>} */ (item);
    const scope = clause.scope;
    if (typeof scope !== 'string' || !scope.trim()) {
      throw new Error(`Clause at index ${index} is missing a scope`);
    }
    const allowRaw = clause.allow;
    if (!Array.isArray(allowRaw)) {
      throw new Error(`Clause ${scope} is missing allow rules`);
    }
    const allow = allowRaw.map((entry, allowIndex) => {
      if (!entry || typeof entry !== 'object') {
        throw new Error(`Clause ${scope} allow entry ${allowIndex} must be an object`);
      }
      const allowEntry = /** @type {Record<string, unknown>} */ (entry);
      const purpose = allowEntry.purpose;
      const lawfulBasis = allowEntry.lawful_basis ?? allowEntry.lawfulBasis;
      if (typeof purpose !== 'string' || !purpose.trim()) {
        throw new Error(`Clause ${scope} allow entry ${allowIndex} missing purpose`);
      }
      if (typeof lawfulBasis !== 'string' || !lawfulBasis.trim()) {
        throw new Error(`Clause ${scope} allow entry ${allowIndex} missing lawful basis`);
      }
      return {
        purpose: purpose.trim(),
        lawfulBasis: lawfulBasis.trim(),
        notes: typeof allowEntry.notes === 'string' ? allowEntry.notes.trim() : undefined,
      };
    });

    const deny = clause.deny;
    if (deny && !Array.isArray(deny)) {
      throw new Error(`Clause ${scope} deny must be an array of purposes`);
    }

    return {
      scope: scope.trim(),
      description: typeof clause.description === 'string' ? clause.description.trim() : undefined,
      allow,
      deny: deny ? deny.map((purpose) => String(purpose).trim()).filter(Boolean) : undefined,
      fallback: clause.fallback === 'allow' ? 'allow' : 'deny',
    };
  });

  return {
    version,
    clauses,
  };
}

/**
 * @param {{ version: string; clauses: Array<any> }} document
 */
export function compilePolicy(document) {
  const scopes = {};

  for (const clause of document.clauses) {
    if (!clause.allow.length) {
      continue;
    }
    const allowedPurposes = {};
    for (const entry of clause.allow) {
      if (!allowedPurposes[entry.purpose]) {
        allowedPurposes[entry.purpose] = entry.lawfulBasis;
      }
    }
    scopes[clause.scope] = allowedPurposes;
  }

  return {
    version: document.version,
    generatedAt: new Date().toISOString(),
    scopes,
  };
}

function renderPythonModule(compiled) {
  const policyJson = JSON.stringify(compiled.scopes, null, 2).replace(/"/g, "'");
  const policy = `POLICY = ${policyJson}\n`;

  const guard = `from __future__ import annotations\n\nfrom typing import Any, Callable, Dict, List\n\nfrom .policy_data import POLICY\n\n_TELEMETRY: List[Dict[str, str]] = []\n\n\nclass ConsentViolation(Exception):\n  \"\"\"Raised when an action does not have consent for the requested purpose.\"\"\"\n\n\nclass Guard:  # pragma: no cover - thin wrapper for type hinting\n  def __init__(self, scope: str, purpose: str, lawful_basis: str):\n    self.scope = scope\n    self.purpose = purpose\n    self.lawful_basis = lawful_basis\n\n  def execute(self, action: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:\n    _TELEMETRY.append(\n      {\n        'scope': self.scope,\n        'purpose': self.purpose,\n        'lawful_basis': self.lawful_basis,\n      }\n    )\n    return action(*args, **kwargs)\n\n\ndef getTelemetry() -> List[Dict[str, str]]:\n  return list(_TELEMETRY)\n\n\ndef resetTelemetry() -> None:\n  _TELEMETRY.clear()\n\n\ndef withConsent(scope: str, purpose: str) -> Guard:\n  allowed = POLICY.get(scope)\n  if not allowed or purpose not in allowed:\n    raise ConsentViolation(f"Purpose '{purpose}' is not permitted within scope '{scope}'")\n  return Guard(scope, purpose, allowed[purpose])\n\n\nwith_consent = withConsent\n\n`;

  const init = `from .guard import ConsentViolation, Guard, getTelemetry, resetTelemetry, withConsent, with_consent\n\n__all__ = ['ConsentViolation', 'Guard', 'getTelemetry', 'resetTelemetry', 'withConsent', 'with_consent']\n`;

  return {
    'consent_guard/__init__.py': HEADER_PY + init,
    'consent_guard/policy_data.py': HEADER_PY + policy,
    'consent_guard/guard.py': HEADER_PY + guard,
  };
}

function renderJsModule(compiled) {
  const policyJson = JSON.stringify(compiled.scopes, null, 2);
  const policy = `export const POLICY = ${policyJson};\n`;

  const guard = `const telemetry = [];\n\nexport class ConsentViolation extends Error {\n  constructor(scope, purpose) {\n    super(\`Purpose "\${purpose}" is not permitted within scope "\${scope}"\`);\n    this.name = 'ConsentViolation';\n    this.scope = scope;\n    this.purpose = purpose;\n  }\n}\n\nexport function withConsent(scope, purpose) {\n  const allowed = POLICY[scope];\n  if (!allowed || !allowed[purpose]) {\n    throw new ConsentViolation(scope, purpose);\n  }\n  const lawfulBasis = allowed[purpose];\n  return (action, ...args) => {\n    telemetry.push({ scope, purpose, lawfulBasis });\n    return action(...args);\n  };\n}\n\nexport function getTelemetry() {\n  return [...telemetry];\n}\n\nexport function resetTelemetry() {\n  telemetry.length = 0;\n}\n`;

  const dts = `export interface TelemetryEntry {\n  scope: string;\n  purpose: string;\n  lawfulBasis: string;\n}\n\nexport declare const POLICY: Record<string, Record<string, string>>;\nexport declare class ConsentViolation extends Error {\n  scope: string;\n  purpose: string;\n  constructor(scope: string, purpose: string);\n}\nexport declare function withConsent(scope: string, purpose: string): <T>(action: (...args: unknown[]) => T, ...args: unknown[]) => T;\nexport declare function getTelemetry(): TelemetryEntry[];\nexport declare function resetTelemetry(): void;\n`;

  return {
    'index.js': HEADER_JS + policy + '\n' + guard,
    'index.d.ts': HEADER_JS + dts,
    'index.ts': HEADER_JS + `import { ConsentViolation, getTelemetry, resetTelemetry, withConsent } from './index.js';\n\nexport { ConsentViolation, getTelemetry, resetTelemetry, withConsent };\nexport { POLICY } from './index.js';\n`,
  };
}

function renderGoModule(compiled) {
  const entries = Object.entries(compiled.scopes)
    .map(([scope, purposes]) => {
      const inner = Object.entries(purposes)
        .map(([purpose, lawful]) => `      \"${purpose}\": \"${lawful}\",`)
        .join('\n');
      return `    \"${scope}\": map[string]string{\n${inner}\n    },`;
    })
    .join('\n');

  const policy = `package consentguard\n\nvar policy = map[string]map[string]string{\n${entries}\n}\n`;

  const guard = `package consentguard\n\nimport (\n  \"fmt\"\n  \"sync\"\n)\n\nvar telemetryMu sync.Mutex\nvar telemetry []TelemetryEntry\n\n// TelemetryEntry captures every successful consent check.\ntype TelemetryEntry struct {\n  Scope       string\n  Purpose     string\n  LawfulBasis string\n}\n\n// ConsentViolation represents a failure to match consent for a purpose.\ntype ConsentViolation struct {\n  Scope   string\n  Purpose string\n}\n\nfunc (e ConsentViolation) Error() string {\n  return fmt.Sprintf(\"purpose %s is not permitted within scope %s\", e.Purpose, e.Scope)\n}\n\n// Guard defines a callable that executes the provided action when consent is valid.\ntype Guard func(func() (any, error)) (any, error)\n\n// WithConsent exposes the Go shim.\nfunc WithConsent(scope, purpose string) (Guard, error) {\n  allowed, ok := policy[scope]\n  if !ok {\n    return nil, ConsentViolation{Scope: scope, Purpose: purpose}\n  }\n  lawful, ok := allowed[purpose]\n  if !ok {\n    return nil, ConsentViolation{Scope: scope, Purpose: purpose}\n  }\n\n  guard := func(action func() (any, error)) (any, error) {\n    telemetryMu.Lock()\n    telemetry = append(telemetry, TelemetryEntry{\n      Scope:       scope,\n      Purpose:     purpose,\n      LawfulBasis: lawful,\n    })\n    telemetryMu.Unlock()\n    return action()\n  }\n  return guard, nil\n}\n\n// WithConsentFunc preserves the lowercase naming expectation via an exported alias.\nvar WithConsentFunc = WithConsent\n\n// ResetTelemetry clears recorded telemetry entries.\nfunc ResetTelemetry() {\n  telemetryMu.Lock()\n  defer telemetryMu.Unlock()\n  telemetry = telemetry[:0]\n}\n\n// GetTelemetry returns a copy of telemetry entries.\nfunc GetTelemetry() []TelemetryEntry {\n  telemetryMu.Lock()\n  defer telemetryMu.Unlock()\n  out := make([]TelemetryEntry, len(telemetry))\n  copy(out, telemetry)\n  return out\n}\n`;

  const goMod = `module ccc/consentguard\n\ngo 1.21\n`;

  return {
    'consentguard/policy_data.go': HEADER_GO + policy,
    'consentguard/guard.go': HEADER_GO + guard,
    'consentguard/go.mod': goMod,
  };
}

/**
 * @param {string} outputDir
 * @param {{version: string; generatedAt: string; scopes: Record<string, Record<string, string>>}} compiled
 */
export async function writeArtifacts(outputDir, compiled) {
  const pythonFiles = renderPythonModule(compiled);
  const jsFiles = renderJsModule(compiled);
  const goFiles = renderGoModule(compiled);

  const files = [
    ...Object.entries(pythonFiles).map(([file, content]) => [path.join('python', file), content]),
    ...Object.entries(jsFiles).map(([file, content]) => [path.join('js', file), content]),
    ...Object.entries(goFiles).map(([file, content]) => [path.join('go', file), content]),
  ];

  await Promise.all(
    files.map(async ([relativePath, content]) => {
      const fullPath = path.join(outputDir, relativePath);
      await fs.mkdir(path.dirname(fullPath), { recursive: true });
      await fs.writeFile(fullPath, content, 'utf8');
    })
  );
}

export async function compileFromFile(policyPath, outputDir) {
  const raw = await fs.readFile(policyPath, 'utf8');
  const parsed = parsePolicy(raw);
  const compiled = compilePolicy(parsed);
  await writeArtifacts(outputDir, compiled);
  return compiled;
}
