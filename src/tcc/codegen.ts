import {
  TCCTransform,
  TCCInvariant,
  Expression,
  TypeRef,
} from "./types";

export type TargetLanguage = "python" | "javascript" | "scala";

interface StubArtifacts {
  filename: string;
  contents: string;
}

export interface GeneratedStubs {
  python: StubArtifacts;
  javascript: StubArtifacts;
  spark: StubArtifacts;
}

const SCALA_HEADER = [
  "// Generated by the Transformation Canon & Codegen (TCC)",
  "// Fill in implementation(...) and keep invariant checks intact.",
  "import scala.collection.immutable.Map",
  "import scala.math",
  "",
  "case class CanonViolation(stage: String, name: String, description: String)",
  "    extends RuntimeException(s\"$stage::$name failed - $description\")",
].join("\n");

const PYTHON_HEADER = [
  '"""Generated by the Transformation Canon & Codegen (TCC).',
  'Fill in implementation() and keep invariant checks intact."""',
  "from __future__ import annotations",
  "",
  "from typing import Any, Dict, Mapping, MutableMapping",
  "import math",
  "",
  "",
  "class CanonViolation(Exception):",
  '    """Raised when a TCC invariant is violated."""',
  "",
  "    def __init__(self, stage: str, name: str, description: str) -> None:",
  '        super().__init__(f"{stage}::{name} failed - {description}")',
  "        self.stage = stage",
  "        self.name = name",
  "        self.description = description",
  "",
  "",
  "def _ensure(condition: bool, stage: str, name: str, description: str) -> None:",
  "    if not condition:",
  "        raise CanonViolation(stage, name, description)",
  "",
  "",
  "def _len(value: Any) -> int:",
  "    if hasattr(value, \"__len__\"):",
  "        return len(value)  # type: ignore[arg-type]",
  '    raise TypeError(f"len() unsupported for value: {value!r}")',
  "",
  "",
  "def _sum(values: Any) -> float:",
  "    return float(sum(values))",
  "",
  "",
  "def _avg(values: Any) -> float:",
  "    values_list = list(values)",
  "    if not values_list:",
  "        return 0.0",
  "    return float(sum(values_list)) / len(values_list)",
].join("\n");

const JAVASCRIPT_HEADER = [
  "// Generated by the Transformation Canon & Codegen (TCC).",
  "// Fill in implementation() and keep invariant checks intact.",
  "",
  "export class CanonViolation extends Error {",
  "  constructor(stage, name, description) {",
  "    super(`${stage}::${name} failed - ${description}`);",
  "    this.stage = stage;",
  "    this.name = name;",
  "    this.description = description;",
  "  }",
  "}",
  "",
  "function ensure(condition, stage, name, description) {",
  "  if (!condition) {",
  "    throw new CanonViolation(stage, name, description);",
  "  }",
  "}",
  "",
  "function len(value) {",
  '  if (value == null) throw new TypeError("len() unsupported for nullish value");',
  '  if (typeof value === "string" || Array.isArray(value)) return value.length;',
  '  if (typeof value === "object") return Object.keys(value).length;',
  '  throw new TypeError(`len() unsupported for value: ${value}`);',
  "}",
  "",
  "function sumValues(values) {",
  "  if (!Array.isArray(values)) {",
  '    throw new TypeError("sum() invariants expect an array");',
  "  }",
  "  return values.reduce((acc, value) => acc + Number(value), 0);",
  "}",
  "",
  "function avg(values) {",
  "  if (!Array.isArray(values) || values.length === 0) return 0;",
  "  return sumValues(values) / values.length;",
  "}",
  "",
  "function includesValue(collection, value) {",
  "  if (Array.isArray(collection)) return collection.includes(value);",
  '  if (typeof collection === "string") return collection.includes(String(value));',
  "  if (collection && typeof collection === 'object') {",
  "    return Object.values(collection).includes(value);",
  "  }",
  "  return false;",
  "}",
].join("\n");

const SCALA_HELPERS = [
  "  private def ensure(condition: Boolean, stage: String, name: String, description: String): Unit = {",
  "    if (!condition) throw CanonViolation(stage, name, description)",
  "  }",
  "",
  "  private def len(value: Any): Int = value match {",
  "    case s: String       => s.length",
  "    case i: Iterable[_]  => i.size",
  "    case a: Array[_]     => a.length",
  "    case m: Map[_, _]    => m.size",
  "    case other           => throw new IllegalArgumentException(s\"len() unsupported for value: $other\")",
  "  }",
  "",
  "  private def sumValues(values: Any): Double = values match {",
  "    case seq: Iterable[_] => seq.map(_.toString.toDouble).sum",
  "    case arr: Array[_]    => arr.map(_.toString.toDouble).sum",
  "    case other            => throw new IllegalArgumentException(s\"sum() invariants expect a collection, received: $other\")",
  "  }",
  "",
  "  private def avg(values: Any): Double = {",
  "    val seq = values match {",
  "      case iterable: Iterable[_] => iterable.map(_.toString.toDouble).toSeq",
  "      case array: Array[_]       => array.map(_.toString.toDouble).toSeq",
  "      case other                 => throw new IllegalArgumentException(s\"avg() invariants expect a collection, received: $other\")",
  "    }",
  "    if (seq.isEmpty) 0.0 else seq.sum / seq.size",
  "  }",
  "",
  "  private def includesValue(collection: Any, value: Any): Boolean = collection match {",
  "    case seq: Iterable[_] => seq.exists(_ == value)",
  "    case arr: Array[_]    => arr.contains(value)",
  "    case s: String        => s.contains(value.toString)",
  "    case map: Map[_, _]   => map.values.exists(_ == value)",
  "    case _                => false",
  "  }",
].join("\n");

function toSnakeCase(value: string): string {
  return value
    .replace(/[^a-zA-Z0-9]+/g, "_")
    .replace(/([a-z0-9])([A-Z])/g, "$1_$2")
    .replace(/_+/g, "_")
    .replace(/^_|_$/g, "")
    .toLowerCase();
}

function toCamelCase(value: string): string {
  const parts = value
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .filter(Boolean)
    .map((segment) => segment.toLowerCase());
  if (parts.length === 0) return "transform";
  return parts[0] + parts.slice(1).map((segment) => segment[0].toUpperCase() + segment.slice(1)).join("");
}

function toPascalCase(value: string): string {
  const camel = toCamelCase(value);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function escapePythonString(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function escapeScalaString(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function renderPythonType(type: TypeRef): string {
  switch (type.kind) {
    case "scalar":
      switch (type.name) {
        case "string":
          return "str";
        case "integer":
          return "int";
        case "float":
        case "number":
          return "float";
        case "boolean":
          return "bool";
        case "date":
        case "timestamp":
          return "str";
        default:
          return "Any";
      }
    case "array":
      return `list[${renderPythonType(type.items)}]`;
    case "object":
      return "dict[str, Any]";
    default:
      return "Any";
  }
}

function renderPythonLiteral(value: unknown): string {
  if (value === null) return "None";
  if (typeof value === "boolean") return value ? "True" : "False";
  if (typeof value === "number") return Number.isFinite(value) ? value.toString() : "float('nan')";
  if (typeof value === "string") return `"${escapePythonString(value)}"`;
  if (Array.isArray(value)) return `[${value.map((item) => renderPythonLiteral(item)).join(", ")}]`;
  if (typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>)
      .map(([key, val]) => `"${escapePythonString(key)}": ${renderPythonLiteral(val)}`)
      .join(", ");
    return `{${entries}}`;
  }
  return "None";
}

function renderJavaScriptLiteral(value: unknown): string {
  if (typeof value === "string") return JSON.stringify(value);
  if (value === null) return "null";
  if (typeof value === "number" || typeof value === "boolean") return String(value);
  if (Array.isArray(value) || typeof value === "object") return JSON.stringify(value);
  return "undefined";
}

function renderScalaLiteral(value: unknown): string {
  if (value === null) return "null";
  if (typeof value === "boolean") return value ? "true" : "false";
  if (typeof value === "number") return value.toString();
  if (typeof value === "string") return `"${escapeScalaString(value)}"`;
  if (Array.isArray(value)) {
    return `Seq(${value.map((item) => renderScalaLiteral(item)).join(", ")})`;
  }
  if (typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>)
      .map(([key, val]) => `"${escapeScalaString(key)}" -> ${renderScalaLiteral(val)}`)
      .join(", ");
    return `Map(${entries})`;
  }
  return "null";
}

function renderRef(path: string, language: TargetLanguage): string {
  const segments = path.split(".");
  if (segments.length === 0) return path;
  const [root, ...rest] = segments;
  if (rest.length === 0) return root;
  switch (language) {
    case "python":
    case "javascript":
      return `${root}${rest.map((segment) => `["${segment}"]`).join("")}`;
    case "scala":
      return `${root}${rest.map((segment) => `("${segment}")`).join("")}`;
    default:
      return path;
  }
}

function renderCall(expression: Expression & { kind: "call" }, language: TargetLanguage): string {
  const args = expression.args.map((arg) => renderExpression(arg, language));
  switch (expression.fn) {
    case "len":
      return language === "scala" ? `len(${args[0]})` : language === "javascript" ? `len(${args[0]})` : `_len(${args[0]})`;
    case "abs":
      if (language === "python") return `abs(${args.join(", ")})`;
      if (language === "javascript") return `Math.abs(${args.join(", ")})`;
      return `math.abs(${args.join(", ")})`;
    case "ceil":
      if (language === "python") return `math.ceil(${args.join(", ")})`;
      if (language === "javascript") return `Math.ceil(${args.join(", ")})`;
      return `math.ceil(${args.join(", ")})`;
    case "floor":
      if (language === "python") return `math.floor(${args.join(", ")})`;
      if (language === "javascript") return `Math.floor(${args.join(", ")})`;
      return `math.floor(${args.join(", ")})`;
    case "max":
      if (language === "python") return `max(${args.join(", ")})`;
      if (language === "javascript") return `Math.max(${args.join(", ")})`;
      return `Seq(${args.join(", ")}).max`;
    case "min":
      if (language === "python") return `min(${args.join(", ")})`;
      if (language === "javascript") return `Math.min(${args.join(", ")})`;
      return `Seq(${args.join(", ")}).min`;
    case "sum":
      if (language === "python") return `_sum(${args[0]})`;
      if (language === "javascript") return `sumValues(${args[0]})`;
      return `sumValues(${args[0]})`;
    case "avg":
      if (language === "python") return `_avg(${args[0]})`;
      if (language === "javascript") return `avg(${args[0]})`;
      return `avg(${args[0]})`;
    default:
      throw new Error(`Unsupported call function: ${expression.fn}`);
  }
}

function renderBinary(expression: Expression & { kind: "binary" }, language: TargetLanguage): string {
  const left = renderExpression(expression.left, language);
  const right = renderExpression(expression.right, language);
  if (expression.op === "in") {
    if (language === "python") return `${left} in ${right}`;
    return `includesValue(${right}, ${left})`;
  }
  return `(${left} ${expression.op} ${right})`;
}

function renderLogical(expression: Expression & { kind: "logical" }, language: TargetLanguage): string {
  const rendered = expression.expressions.map((item) => renderExpression(item, language));
  const op = expression.op === "and" ? (language === "python" ? "and" : "&&") : language === "python" ? "or" : "||";
  return rendered.map((item) => `(${item})`).join(` ${op} `);
}

function renderNot(expression: Expression & { kind: "not" }, language: TargetLanguage): string {
  const inner = renderExpression(expression.expression, language);
  return language === "python" ? `not (${inner})` : `!(${inner})`;
}

export function renderExpression(expression: Expression, language: TargetLanguage): string {
  switch (expression.kind) {
    case "ref":
      return renderRef(expression.path, language);
    case "value":
      if (language === "python") return renderPythonLiteral(expression.value);
      if (language === "javascript") return renderJavaScriptLiteral(expression.value);
      return renderScalaLiteral(expression.value);
    case "call":
      return renderCall(expression, language);
    case "binary":
      return renderBinary(expression, language);
    case "logical":
      return renderLogical(expression, language);
    case "not":
      return renderNot(expression, language);
    default:
      throw new Error(`Unsupported expression kind: ${(expression as Expression).kind}`);
  }
}

function renderInvariantChecks(
  invariants: TCCInvariant[],
  language: TargetLanguage,
  stage: "pre" | "post"
): string {
  return invariants
    .map((invariant) => {
      const expression = renderExpression(invariant.expression, language);
      const description = invariant.description.replace(/"/g, '\\"');
      switch (language) {
        case "python":
          return `    _ensure(${expression}, "${stage}", "${invariant.name}", "${description}")`;
        case "javascript":
          return `  ensure(${expression}, "${stage}", "${invariant.name}", "${description}");`;
        case "scala":
          return `    ensure(${expression}, "${stage}", "${invariant.name}", "${description}")`;
        default:
          return "";
      }
    })
    .join("\n");
}

function generatePythonDoc(transform: TCCTransform): string {
  const inputs = transform.inputs
    .map((port) => `        ${port.name}: ${renderPythonType(port.type)}${port.optional ? " | None" : ""}`)
    .join("\n");
  const outputs = transform.outputs
    .map((port) => `        ${port.name}: ${renderPythonType(port.type)}`)
    .join("\n");
  const docLines = [
    `${transform.description}`,
    "",
    `Version: ${transform.version}`,
    `Stability: ${transform.stability.level} (${transform.stability.changePolicy})`,
    "",
    "Inputs:",
    inputs,
    "",
    "Outputs:",
    outputs,
  ];
  return docLines.join("\n");
}

function generatePythonStub(transform: TCCTransform): StubArtifacts {
  const functionName = toSnakeCase(transform.id || transform.name);
  const preInvariants = transform.invariants.filter((invariant) => invariant.stage === "pre");
  const postInvariants = transform.invariants.filter((invariant) => invariant.stage === "post");
  const docstring = generatePythonDoc(transform);
  const preChecks = renderInvariantChecks(preInvariants, "python", "pre");
  const postChecks = renderInvariantChecks(postInvariants, "python", "post");
  const contents = [
    PYTHON_HEADER,
    "",
    `def ${functionName}(inputs: Mapping[str, Any], parameters: Mapping[str, Any] | None = None) -> Dict[str, Any]:`,
    `    """${docstring}"""`,
    "    params: Mapping[str, Any] = parameters or {}",
    preChecks ? preChecks : undefined,
    "    outputs = implementation(inputs, params)",
    postChecks ? postChecks : undefined,
    "    return dict(outputs)",
    "",
    "",
    "def implementation(inputs: Mapping[str, Any], parameters: Mapping[str, Any]) -> MutableMapping[str, Any]:",
    '    """Override with the canonical transform implementation."""',
    '    raise NotImplementedError("Implement the transform logic here.")',
  ]
    .filter(Boolean)
    .join("\n");
  return {
    filename: `${functionName}.py`,
    contents,
  };
}

function generateJavaScriptStub(transform: TCCTransform): StubArtifacts {
  const functionName = toCamelCase(transform.id || transform.name);
  const implementationName = `apply${toPascalCase(transform.id || transform.name)}`;
  const preInvariants = transform.invariants.filter((invariant) => invariant.stage === "pre");
  const postInvariants = transform.invariants.filter((invariant) => invariant.stage === "post");
  const preChecks = renderInvariantChecks(preInvariants, "javascript", "pre");
  const postChecks = renderInvariantChecks(postInvariants, "javascript", "post");
  const contents = [
    JAVASCRIPT_HEADER,
    `export function ${functionName}(inputs, parameters = {}) {`,
    "  const params = parameters ?? {};",
    preChecks ? preChecks : undefined,
    `  const outputs = ${implementationName}(inputs, params);`,
    postChecks ? postChecks : undefined,
    "  return outputs;",
    "}",
    "",
    `export function ${implementationName}(inputs, parameters) {`,
    '  throw new Error("Implement the transform logic here.");',
    "}",
  ]
    .filter(Boolean)
    .join("\n");
  return {
    filename: `${functionName}.mjs`,
    contents,
  };
}

function generateScalaStub(transform: TCCTransform): StubArtifacts {
  const objectName = toPascalCase(transform.id || transform.name);
  const preInvariants = transform.invariants.filter((invariant) => invariant.stage === "pre");
  const postInvariants = transform.invariants.filter((invariant) => invariant.stage === "post");
  const preChecks = renderInvariantChecks(preInvariants, "scala", "pre");
  const postChecks = renderInvariantChecks(postInvariants, "scala", "post");
  const contents = [
    SCALA_HEADER,
    `object ${objectName} {`,
    SCALA_HELPERS,
    "",
    "  def apply(inputs: Map[String, Any], parameters: Map[String, Any] = Map.empty): Map[String, Any] = {",
    preChecks ? preChecks : undefined,
    "    val outputs = implementation(inputs, parameters)",
    postChecks ? postChecks : undefined,
    "    outputs",
    "  }",
    "",
    "  def implementation(inputs: Map[String, Any], parameters: Map[String, Any]): Map[String, Any] =",
    '    throw new NotImplementedError("Implement the transform logic here.")',
    "}",
  ]
    .filter(Boolean)
    .join("\n");
  return {
    filename: `${objectName}.scala`,
    contents,
  };
}

export function generateStubs(transform: TCCTransform): GeneratedStubs {
  return {
    python: generatePythonStub(transform),
    javascript: generateJavaScriptStub(transform),
    spark: generateScalaStub(transform),
  };
}
