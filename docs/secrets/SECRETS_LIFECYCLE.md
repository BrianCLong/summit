# Secrets Lifecycle Rules

**Status:** Enforced
**Owner:** Jules (Secrets Lifecycle Owner)

This document defines the strict lifecycle rules for all secrets identified in the [Secrets Inventory](./SECRETS_INVENTORY.md). These rules are designed to be bounded, explicit, and auditable.

## 1. Creation

*   **Production Secrets:** Must be generated by a cryptographically secure random number generator (CSPRNG).
    *   **Length:** Minimum 32 bytes (64 hex characters) for keys/secrets.
    *   **Source:** Cloud Provider KMS, Vault, or secure operator workstation (never generated by CI/CD logic itself unless ephemeral).
*   **Development Secrets:** May be auto-generated using `server/src/config/secrets.ts:generateSecrets()` for convenience.
*   **Prohibition:** No secrets may be "invented" by developers and hardcoded into source code.

## 2. Storage

*   **Repository (Code):** **STRICTLY PROHIBITED.** No real secrets shall ever be committed to git.
*   **Repository (Config):** **STRICTLY PROHIBITED.** Config files (`config.yaml`, `helm values.yaml`) must use placeholders (e.g., `${env:DATABASE_URL}`).
*   **Local Development:** Stored in `.env` files which are included in `.gitignore`.
*   **CI/CD:** Stored in GitHub Actions Secrets or repository-level Encrypted Secrets.
*   **Production:** Stored in Kubernetes Secrets, AWS Secrets Manager, or HashiCorp Vault. Injected as environment variables or mounted volumes at runtime.

## 3. Usage

*   **Injection:** Secrets must be injected into the application via Environment Variables or File Mounts.
*   **Access:** The application accesses secrets solely through the validated configuration layer (`server/src/config/secrets.ts`).
*   **Extension Boundaries:** Plugins and Extensions **must not** have direct access to raw environment variables. They must request capabilities via the Plugin SDK, which acts as a secure broker.

## 4. Rotation

*   **Trigger:** Rotation is triggered manually by the Operations team or automatically by the Cloud Provider (e.g., AWS IAM rotation).
*   **Frequency:**
    *   **Critical (DB/Signing):** On-demand (incident response) or quarterly.
    *   **API Keys:** Per provider policy or annually.
*   **Intent:** We support rotation by restarting services with new environment variables. The application is stateless regarding configuration and will pick up new secrets upon restart.
*   **Zero-Surprise:** Rotation must not happen "magicallly" inside the application code. It is an infrastructure-level operation.

## 5. Revocation

*   **Process:**
    1.  **Identify:** Determine the compromised or obsolete secret.
    2.  **Replace:** Generate and deploy the new secret (Rotation).
    3.  **Revoke:** Invalidate the old secret at the provider (e.g., Revoke API Key in OpenAI dashboard, Rotate DB password in RDS).
    4.  **Verify:** Confirm services are healthy with the new secret and denied with the old.

## 6. Logging & Observability

*   **Redaction:** All logs, traces, and error reports **must** redact secret values.
*   **Patterns:** The `detect_secrets.cjs` logic serves as a reference for patterns to scrub (e.g., `Bearer ey...`).
*   **Alerting:** Access to secrets storage (e.g., AWS Secrets Manager) should be audited and alerted on anomalous access patterns.

## 7. Audit

*   **Verification:** The "No Secrets in Repo" state is verified by `scripts/security/detect_secrets.cjs`.
*   **Compliance:** Presence of `validateProductionSecurity` in startup logic (`server/src/config/secrets.ts`) is the evidence of enforcement.
