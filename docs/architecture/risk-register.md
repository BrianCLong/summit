# Architecture Risk Register (Top 10)

| #   | Risk                                                                                                                    | Area          | Severity | Mitigation / Next Step                                                                                                                     | Owner |
| --- | ----------------------------------------------------------------------------------------------------------------------- | ------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ----- |
| 1   | GraphQL API is single control plane; outage blocks web and automation callers                                           | Availability  | High     | Enforce SLO budgets, autoscale API, keep graceful degradation via cache and read replicas; ensure HA deployment beyond single Compose node | TBD   |
| 2   | Neo4j is critical for graph reads/writes; failure blocks core use cases                                                 | Data Layer    | High     | Add backup/restore runbook, enable clustering or hot standby, monitor health via OTEL/Prometheus                                           | TBD   |
| 3   | PostgreSQL holds metadata/audit/embeddings; corruption impacts provenance                                               | Data Layer    | High     | Enable WAL archiving, automate migrations/rollbacks, include pgvector compatibility tests                                                  | TBD   |
| 4   | Redis underpins caching and BullMQ queues; exhaustion causes cascading failures                                         | Reliability   | High     | Configure eviction policies, alert on memory/connection saturation, add circuit breakers for queue producers/consumers                     | TBD   |
| 5   | Optional Kafka/AI profile introduces conditional dependencies that can fail silently                                    | Operability   | Medium   | Gate enablement behind health checks, document profile toggles, add consumer lag alerts before enabling in prod                            | TBD   |
| 6   | OPA policy engine is a runtime dependency; policy regressions could deny service                                        | Security      | Medium   | Add contract tests for policy bundles, enforce version pinning, include fallback mode for non-critical checks                              | TBD   |
| 7   | Observability stack (OTEL→Prometheus/Grafana/Jaeger) is required for SLOs; missing telemetry reduces incident detection | Observability | Medium   | Bake collectors into API/worker images, validate scrape targets in CI, enforce dashboard SLIs                                              | TBD   |
| 8   | Web assets are served from API in production path; misbuilds can serve stale UI                                         | Deployability | Medium   | Add asset digest checks, CDN-ready build path, smoke test that API serves index.html after deploy                                          | TBD   |
| 9   | Docker Compose is primary dev/CI topology; divergence from K8s manifests risks drift                                    | Deployment    | Medium   | Keep Compose and Kubernetes overlays aligned via automated diff checks and shared env vars                                                 | TBD   |
| 10  | Secrets bootstrap in API (vault/env) precedes service start; misconfiguration blocks startup                            | Security      | Medium   | Add preflight secret validation, fallback to safe defaults in dev, document required keys                                                  | TBD   |

## Evidence basis

- Core runtime dependencies and optional Kafka/AI profiles are enumerated in the architecture map, framing single points of failure and optional paths.【F:ARCHITECTURE_MAP.generated.yaml†L40-L440】
- The API process currently serves built client assets in production, linking availability of the UI to the API runtime.【F:server/src/index.ts†L136-L145】
