# Switchboard Skill Bundle Spec v0.1

## Goals

*   **Deterministic packaging**: identical inputs â†’ identical bundle hash
*   **Least privilege**: explicit, machine-enforced capability scopes
*   **Verifiable provenance**: who built it, from what source, with what deps
*   **Sandbox-first**: no ambient creds; scoped tokens minted per invocation
*   **Testable governance**: policy fixtures + "danger probes" required for Verified

---

## 1. Bundle Layout (Canonical)

The bundle is a directory structure that is zipped or tarballed for distribution, but hashed as a normalized directory tree.

```
skill-bundle/
  manifest.json         # Metadata, entrypoints, versioning
  permissions.json      # Capability requests & scopes
  policy/
    rules.rego          # Policy logic (OPA)
    defaults.json       # Default policy data
    fixtures/           # Test cases for policy
      allow_cases.jsonl
      deny_cases.jsonl
  src/
    index.ts            # Source code (or index.py, etc.)
    ...                 # Other source files
  tests/
    sandbox.spec.yaml   # Sandbox verification suite
    golden/
      receipts/         # Expected receipt outputs
        *.json
  build/
    lockfile.json       # Normalized dependency lock
    buildinfo.json      # Deterministic build inputs
  attestations/         # Signatures & Provenance (EXCLUDED from bundle digest)
    provenance.json
    signature.sig
    certificate.pem
  docs/                 # Human-readable docs (included in digest)
    README.md
```

---

## 2. Canonical Bundle Digest Algorithm

To ensure `bundle_digest` is deterministic across platforms and filesystems, the following normalization rules apply before hashing.

### 2.1 Algorithm Steps

1.  **Normalization**:
    *   **Filter**: Exclude `.git/`, `.DS_Store`, `attestations/`, `__pycache__/`, `node_modules/` (if present, deps should be bundled or locked), and any file ending in `.tmp` or `.log`.
    *   **Sorting**: Sort the file list by path name (case-sensitive, strictly ascending).
    *   **Content**: Read each file as bytes.
    *   **Path Normalization**: Use forward slashes `/`. Remove leading `./`.

2.  **Hashing**:
    *   Initialize a SHA-256 context.
    *   For each file in the sorted list:
        *   Feed `SHA256(path_relative_to_root)` (bytes).
        *   Feed `SHA256(file_content)` (bytes).
    *   Finalize SHA-256.

### 2.2 Pseudo-code

```python
def compute_bundle_digest(root_dir):
    files = []
    for root, dirs, filenames in os.walk(root_dir):
        # Sort dirs in-place to ensure traversal order (though we sort list later, good practice)
        dirs.sort()
        for filename in filenames:
            path = os.path.join(root, filename)
            rel_path = os.path.relpath(path, root_dir).replace("\\", "/")

            # 1. Filter
            if should_exclude(rel_path): continue

            files.append(rel_path)

    # 2. Sort
    files.sort()

    hasher = hashlib.sha256()

    for rel_path in files:
        # 3. Feed Path
        path_hash = hashlib.sha256(rel_path.encode('utf-8')).digest()
        hasher.update(path_hash)

        # 4. Feed Content
        with open(os.path.join(root_dir, rel_path), 'rb') as f:
            content_hash = hashlib.sha256(f.read()).digest()
            hasher.update(content_hash)

    return hasher.hexdigest()

def should_exclude(path):
    if path.startswith("attestations/"): return True
    if ".git" in path: return True
    if path.endswith(".DS_Store"): return True
    return False
```

---

## 3. Schemas

The following files must validate against their respective JSON Schemas (draft-07):

*   `manifest.json`: `schemas/skill.manifest.v0.1.json`
*   `permissions.json`: `schemas/skill.permissions.v0.1.json`
*   Receipts generated by the runtime: `schemas/receipt.v0.1.json`

---

## 4. Signing & Verification

### 4.1 Signing

*   Algorithm: **Ed25519**.
*   Payload: The **Canonical Bundle Digest** (hex string).
*   Output: Detached signature file `attestations/signature.sig` (base64 encoded).

### 4.2 Key Management

*   **Publisher Identity**: A registered `publisher_id` (e.g., `com.switchboard`) maps to a public key stored in the Skill Registry.
*   **Key Rotation**: The registry supports key versions. The manifest references the `publisher_id`, but the signature verification uses the currently active key for that ID (or the specific key ID if we implement that).

### 4.3 Verification Flow

1.  Download bundle.
2.  Extract `manifest.json` to get `publisher_id`.
3.  Fetch public key for `publisher_id` from trusted registry.
4.  Compute **Canonical Bundle Digest** locally using the algorithm above.
5.  Verify `attestations/signature.sig` against the computed digest using the public key.
6.  (Optional) Verify `attestations/provenance.json` matches the digest and is signed by the builder (if builder != publisher).

---

## 5. Sandbox Test Suite

Located at `tests/sandbox.spec.yaml`. This defines the contract for "Verified" skills.

```yaml
schema_version: switchboard.skill.sandboxspec.v0.1

expectations:
  - name: "No private network access"
    probe: network.private_ranges
    must: deny

  - name: "No shell execution"
    probe: shell.exec
    must: deny

danger_probes:
  - id: "exfiltrate_env"
    description: "Attempt to read env and POST to external domain"
    expected: deny

golden_receipts:
  - scenario: "triage_10_emails"
    receipt_shape: tests/golden/receipts/triage_10.json
```
