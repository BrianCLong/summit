*** a/conductor-ui/backend/server.js
--- b/conductor-ui/backend/server.js
@@
 const express = require('express');
 const app = express();
 app.use(express.json());
@@
 // ===== P1: EvalOps =====
+const __evalSuites = [
+  { id: 'intelgraph_core_v1', name: 'IntelGraph Core v1', metrics: ['exact_match','semantic_sim','tool_success','cost_per_task'], thresholds: { hallucination_rate_max: 0.01 } },
+  { id: 'orchestrator_regression', name: 'Orchestrator Regression', metrics: ['pass_rate','latency_p95','cost_per_task'], thresholds: { pass_rate_min: 0.95 } }
+];
+const __scorecards = [];
+app.get('/api/maestro/v1/evals/suites', (req,res)=> res.json(__evalSuites));
+app.post('/api/maestro/v1/evals/run', (req,res)=>{
+  const { suite='intelgraph_core_v1', baseline='baseline_000', candidate='candidate_'+Date.now() } = req.body||{};
+  const sc = {
+    id: 'sc_'+Date.now(),
+    suite, baseline, candidate,
+    startedAt: new Date().toISOString(),
+    metrics: {
+      exact_match: +(0.92 + Math.random()*0.06).toFixed(3),
+      semantic_sim: +(0.93 + Math.random()*0.05).toFixed(3),
+      tool_success: +(0.95 + Math.random()*0.03).toFixed(3),
+      hallucination_rate: +(Math.random()*0.01).toFixed(4),
+      cost_per_task: +(3 + Math.random()*2).toFixed(3)
+    },
+    deltas: {
+      exact_match: +(Math.random()*0.02-0.01).toFixed(4),
+      semantic_sim: +(Math.random()*0.02-0.01).toFixed(4),
+      tool_success: +(Math.random()*0.01-0.005).toFixed(4),
+      cost_per_task: +(Math.random()*0.3-0.15).toFixed(3)
+    },
+    status: 'passed'
+  };
+  __scorecards.push(sc);
+  res.json(sc);
+});
+app.get('/api/maestro/v1/evals/scorecards', (req,res)=>{
+  const { suite } = req.query;
+  const list = suite ? __scorecards.filter(s=>s.suite===suite) : __scorecards;
+  res.json(list.slice(-10));
+});
+app.post('/api/maestro/v1/gates/check', (req,res)=>{
+  const { scorecard, sloBurnForecast=0.1, thresholds } = req.body||{};
+  const thr = thresholds || { hallucination_rate_max: 0.01, cost_per_task_delta_max: 0.1 };
+  let allow = true; const reasons=[];
+  if (scorecard?.metrics?.hallucination_rate > thr.hallucination_rate_max) { allow=false; reasons.push('hallucination exceeds max'); }
+  if (Math.abs(scorecard?.deltas?.cost_per_task||0) > thr.cost_per_task_delta_max) { allow=false; reasons.push('cost delta exceeds max'); }
+  if (sloBurnForecast > 0.5) { allow=false; reasons.push('SLO burn forecast high'); }
+  res.json({ allow, reasons, checkedAt: new Date().toISOString() });
+});
@@
 // ===== P1: Agent/HITL stub =====
+const __agentRuns = {};
+function seedAgentRun() {
+  const id = 'ar_'+Date.now();
+  __agentRuns[id] = {
+    id, state: 'waiting_human',
+    steps: [
+      { id:'planner', role:'planner', output:'Plan: do A, then B with tool X', status:'done' },
+      { id:'critic', role:'critic', output:'OK but add validation', status:'pending' }
+    ],
+    pending: { stepId: 'critic', options: ['approve','request_changes','block'], suggestedChange: 'Add validation step C' },
+    artifacts: []
+  };
+  return __agentRuns[id];
+}
+app.post('/api/maestro/v1/agent/runs', (req,res)=> res.json(seedAgentRun()));
+app.get('/api/maestro/v1/agent/runs/:id', (req,res)=> {
+  const run = __agentRuns[req.params.id];
+  if (!run) return res.status(404).json({error:'not found'});
+  res.json(run);
+});
+app.post('/api/maestro/v1/agent/runs/:id/actions', (req,res)=>{
+  const run = __agentRuns[req.params.id];
+  if (!run) return res.status(404).json({error:'not found'});
+  const { action } = req.body||{};
+  if (run.pending?.stepId === 'critic') {
+    if (action==='approve') {
+      run.steps.find(s=>s.id==='critic').status='done';
+      run.steps.push({ id:'executor', role:'executor', output:'Executed A,B,C with tool X', status:'done' });
+      run.state='completed';
+      run.pending=null;
+    } else if (action==='request_changes') {
+      run.steps.find(s=>s.id==='critic').status='revised';
+      run.steps.unshift({ id:'planner2', role:'planner', output:'Revised plan: include C', status:'done' });
+      run.pending=null;
+      run.state='waiting_human';
+    } else if (action==='block') {
+      run.state='blocked'; run.pending=null;
+    }
+  }
+  run.lastAction = { action, at:new Date().toISOString() };
+  res.json(run);
+});
@@
 // ===== P1: Router decision per node =====
+app.get('/api/maestro/v1/routing/decision/:runId/:nodeId', (req,res)=>{
+  const { runId, nodeId } = req.params;
+  const candidates = [
+    { model:'gpt-4o', quality:0.97, p95_ms:900, cost_per_1k:0.005, reliability:0.999 },
+    { model:'claude-3.7-sonnet', quality:0.965, p95_ms:950, cost_per_1k:0.0048, reliability:0.999 },
+    { model:'ig-local-70b', quality:0.94, p95_ms:1200, cost_per_1k:0.001, reliability:0.995 }
+  ];
+  const selected = candidates[0];
+  const reasons = ['objective: quality prioritized', 'policy: external allowed (no PII tag)'];
+  res.json({ runId, nodeId, selected, candidates, reasons, at:new Date().toISOString() });
+});
@@
 // ===== P2: AlertCenter correlations =====
+// If you have AlertCenter routes already, this is additive: tag events with source + pivots.
+const _seedAlerts = () => ([
+  { id:'evt_'+Date.now(), type:'slo_burn', severity:'warn', source:'serving', runId:'1025', provider:'openai', at:new Date().toISOString() },
+  { id:'evt_'+(Date.now()+1), type:'cost_forecast', severity:'breach', source:'finance', tenant:'default', at:new Date().toISOString() }
+]);
+if (!app.locals.__alertEvents) app.locals.__alertEvents = _seedAlerts();
+app.get('/api/maestro/v1/alertcenter/events', (req,res)=>{
+  const { type, severity, tenant, provider } = req.query;
+  const list = (app.locals.__alertEvents || []).filter(e =>
+    (!type || e.type===type) && (!severity || e.severity===severity) &&
+    (!tenant || e.tenant===tenant) && (!provider || e.provider===provider)
+  );
+  res.json(list);
+});
