# Logstash Pipeline Configuration
# Issue: #11813 - Structured Logging with ELK/OpenTelemetry

input {
  # File input for log files
  file {
    path => "/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    tags => ["intelgraph", "file"]
  }

  # TCP input for direct log streaming
  tcp {
    port => 5000
    codec => "json_lines"
    tags => ["intelgraph", "tcp"]
  }

  # Beats input (for Filebeat)
  beats {
    port => 5044
    tags => ["intelgraph", "beats"]
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
    }

    # Promote parsed fields to root level
    ruby {
      code => "
        if event.get('parsed')
          event.get('parsed').each { |k, v|
            event.set(k, v) unless event.get(k)
          }
          event.remove('parsed')
        end
      "
    }
  }

  # Add geo-location for IP addresses if available
  if [clientIp] {
    geoip {
      source => "clientIp"
      target => "geoip"
    }
  }

  # Parse timestamp
  if [timestamp] {
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }

  # Add index name based on service
  mutate {
    add_field => {
      "[@metadata][target_index]" => "intelgraph-logs-%{+YYYY.MM.dd}"
    }
  }

  # Tag audit logs separately
  if [audit] == true {
    mutate {
      add_tag => ["audit"]
      add_field => {
        "[@metadata][target_index]" => "intelgraph-audit-%{+YYYY.MM.dd}"
      }
    }
  }

  # Tag performance logs
  if [performance] == true {
    mutate {
      add_tag => ["performance"]
    }
  }

  # Tag error logs
  if [level] == "ERROR" or [level] == "error" {
    mutate {
      add_tag => ["error"]
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "%{[@metadata][target_index]}"
    document_type => "_doc"
  }

  # Debug output to stdout (optional, for development)
  if "development" in [environment] {
    stdout {
      codec => rubydebug
    }
  }
}
