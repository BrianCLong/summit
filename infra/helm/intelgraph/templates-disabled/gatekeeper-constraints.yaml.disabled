# Gatekeeper OPA Constraints for Classification-Aware Scheduling
# Enforces Federal/Gov Pack security controls at admission time

# Constraint Template: Require classification labels and node affinity
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sclassificationaffinity
  labels:
    gatekeeper.sh/enforcement: "federal"
    security.intelgraph.io/control: "SC-4"  # Information in shared resources
spec:
  crd:
    spec:
      names:
        kind: K8sClassificationAffinity
      validation:
        openAPIV3Schema:
          type: object
          properties:
            requiredClassificationLabel:
              type: string
              description: "Required node classification label key"
            allowedClassifications:
              type: array
              items:
                type: string
              description: "List of allowed classification levels"
            requireNodeAffinity:
              type: boolean
              default: true
              description: "Whether to require explicit node affinity"
            requireTaints:
              type: boolean
              default: true
              description: "Whether to require classification-based taints"
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8sclassificationaffinity
      
      # Get pod classification label
      get_pod_classification = classification {
        classification := input.review.object.metadata.labels["security.intelgraph.io/classification"]
      }
      
      # Check if classification is allowed
      classification_allowed(classification) {
        classification == input.parameters.allowedClassifications[_]
      }
      
      # Check if pod has required node affinity
      has_node_affinity {
        input.review.object.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution
      }
      
      # Check if node affinity includes classification requirement
      has_classification_affinity(classification) {
        terms := input.review.object.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[_]
        expressions := terms.matchExpressions[_]
        expressions.key == input.parameters.requiredClassificationLabel
        expressions.operator == "In"
        classification == expressions.values[_]
      }
      
      # Check if pod has required tolerations for classification taints
      has_classification_toleration(classification) {
        tolerations := input.review.object.spec.tolerations[_]
        tolerations.key == sprintf("classification/%s", [lower(classification)])
        tolerations.operator == "Equal"
        tolerations.effect == "NoSchedule"
      }
      
      # Main violation rules
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        not input.review.object.metadata.labels["security.intelgraph.io/classification"]
        msg := "Pod must have security.intelgraph.io/classification label"
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        classification := get_pod_classification
        not classification_allowed(classification)
        msg := sprintf("Pod classification '%v' not in allowed list: %v", [classification, input.parameters.allowedClassifications])
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        input.parameters.requireNodeAffinity == true
        not has_node_affinity
        msg := "Pod must specify nodeAffinity for classification-based scheduling"
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        classification := get_pod_classification
        input.parameters.requireNodeAffinity == true
        not has_classification_affinity(classification)
        msg := sprintf("Pod must have nodeAffinity for classification '%v' on label '%v'", [classification, input.parameters.requiredClassificationLabel])
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        classification := get_pod_classification
        input.parameters.requireTaints == true
        not has_classification_toleration(classification)
        msg := sprintf("Pod must tolerate classification taint for '%v'", [classification])
      }

---
# Apply classification affinity constraint
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sClassificationAffinity
metadata:
  name: enforce-classification-scheduling
  labels:
    enforcement-level: "strict"
    security.intelgraph.io/control: "SC-4"
spec:
  enforcementAction: "deny"  # Block non-compliant pods
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces: 
    - {{ .Values.namespace | default "intelgraph" }}
  parameters:
    requiredClassificationLabel: "security.intelgraph.io/classification"
    allowedClassifications:
    - {{ .Values.federal.classification | default "UNCLASSIFIED" }}
    {{- range .Values.federal.additionalClassifications }}
    - {{ . }}
    {{- end }}
    requireNodeAffinity: true
    requireTaints: {{ .Values.federal.requireClassificationTaints | default true }}

---
# Constraint Template: FIPS validation requirement
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sfipsvalidation
  labels:
    gatekeeper.sh/enforcement: "federal"
    security.intelgraph.io/control: "SC-13"  # Cryptographic protection
spec:
  crd:
    spec:
      names:
        kind: K8sFipsValidation
      validation:
        openAPIV3Schema:
          type: object
          properties:
            requireFipsNodes:
              type: boolean
              default: true
            fipsNodeLabel:
              type: string
              default: "security.intelgraph.io/fips-validated"
            allowedImages:
              type: array
              items:
                type: string
              description: "FIPS-validated container images"
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8sfipsvalidation
      
      # Check if pod requires FIPS-validated nodes
      requires_fips_node {
        input.review.object.metadata.labels["security.intelgraph.io/fips-required"] == "true"
      }
      
      # Check if pod has FIPS node affinity
      has_fips_node_affinity {
        terms := input.review.object.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[_]
        expressions := terms.matchExpressions[_]
        expressions.key == input.parameters.fipsNodeLabel
        expressions.operator == "In"
        "true" == expressions.values[_]
      }
      
      # Check if image is FIPS-validated
      image_fips_validated(image) {
        startswith(image, input.parameters.allowedImages[_])
      }
      
      # Get all container images
      get_container_images[image] {
        image := input.review.object.spec.containers[_].image
      }
      
      get_container_images[image] {
        image := input.review.object.spec.initContainers[_].image
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        requires_fips_node
        not has_fips_node_affinity
        msg := "Pod with FIPS requirement must schedule on FIPS-validated nodes"
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        requires_fips_node
        image := get_container_images[_]
        not image_fips_validated(image)
        msg := sprintf("Container image '%v' is not FIPS-validated", [image])
      }

---
# Apply FIPS validation constraint
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sFipsValidation
metadata:
  name: enforce-fips-validation
  labels:
    enforcement-level: "strict"
    security.intelgraph.io/control: "SC-13"
spec:
  enforcementAction: {{ .Values.federal.fips.enforcementAction | default "deny" }}
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - {{ .Values.namespace | default "intelgraph" }}
  parameters:
    requireFipsNodes: {{ .Values.federal.fips.requireFipsNodes | default true }}
    fipsNodeLabel: "security.intelgraph.io/fips-validated"
    allowedImages:
    {{- range .Values.federal.fips.allowedImages }}
    - {{ . }}
    {{- end }}
    - "{{ .Values.image.repository }}/conductor-federal"
    - "ghcr.io/spiffe/spire-server"
    - "ghcr.io/spiffe/spire-agent"
    - "ghcr.io/spiffe/spiffe-helper"

---
# Constraint Template: Air-gap enforcement
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sairgapenforcement
  labels:
    gatekeeper.sh/enforcement: "federal"
    security.intelgraph.io/control: "SC-7"  # Boundary protection
spec:
  crd:
    spec:
      names:
        kind: K8sAirGapEnforcement
      validation:
        openAPIV3Schema:
          type: object
          properties:
            airGapEnabled:
              type: boolean
              default: false
            allowedRegistries:
              type: array
              items:
                type: string
              description: "Allowed container registries for air-gap environments"
            requireOfflineRegistry:
              type: boolean
              default: true
            airGapNodeLabel:
              type: string
              default: "security.intelgraph.io/air-gap"
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8sairgapenforcement
      
      # Check if pod is in air-gap mode
      is_airgap_pod {
        input.review.object.metadata.labels["security.intelgraph.io/air-gap"] == "true"
      }
      
      # Check if image is from allowed registry
      image_from_allowed_registry(image) {
        startswith(image, input.parameters.allowedRegistries[_])
      }
      
      # Check if pod has air-gap node affinity
      has_airgap_node_affinity {
        terms := input.review.object.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[_]
        expressions := terms.matchExpressions[_]
        expressions.key == input.parameters.airGapNodeLabel
        expressions.operator == "In"
        "true" == expressions.values[_]
      }
      
      # Get all container images
      get_container_images[image] {
        image := input.review.object.spec.containers[_].image
      }
      
      get_container_images[image] {
        image := input.review.object.spec.initContainers[_].image
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        input.parameters.airGapEnabled == true
        is_airgap_pod
        not has_airgap_node_affinity
        msg := "Air-gap pods must schedule on air-gap nodes"
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        input.parameters.airGapEnabled == true
        is_airgap_pod
        image := get_container_images[_]
        not image_from_allowed_registry(image)
        msg := sprintf("Air-gap environment: image '%v' not from allowed registry", [image])
      }

---
# Apply air-gap enforcement constraint
{{- if .Values.federal.airGap.enabled }}
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sAirGapEnforcement
metadata:
  name: enforce-airgap-compliance
  labels:
    enforcement-level: "strict"
    security.intelgraph.io/control: "SC-7"
spec:
  enforcementAction: "deny"
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - {{ .Values.namespace | default "intelgraph" }}
  parameters:
    airGapEnabled: true
    requireOfflineRegistry: true
    airGapNodeLabel: "security.intelgraph.io/air-gap"
    allowedRegistries:
    {{- range .Values.federal.airGap.allowedRegistries }}
    - {{ . }}
    {{- end }}
    - "localhost:5000/"  # Local registry
    - "airgap-registry.{{ .Values.namespace | default "intelgraph" }}.svc.cluster.local/"
{{- end }}

---
# Constraint Template: Security context enforcement
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8ssecuritycontext
  labels:
    gatekeeper.sh/enforcement: "federal"
    security.intelgraph.io/control: "AC-6"  # Least privilege
spec:
  crd:
    spec:
      names:
        kind: K8sSecurityContext
      validation:
        openAPIV3Schema:
          type: object
          properties:
            runAsNonRoot:
              type: boolean
              default: true
            readOnlyRootFilesystem:
              type: boolean
              default: true
            allowPrivilegeEscalation:
              type: boolean
              default: false
            requiredSeccompProfile:
              type: string
              default: "RuntimeDefault"
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8ssecuritycontext
      
      # Check container security context
      container_violates_security(container) {
        input.parameters.runAsNonRoot == true
        not container.securityContext.runAsNonRoot == true
      }
      
      container_violates_security(container) {
        input.parameters.readOnlyRootFilesystem == true
        not container.securityContext.readOnlyRootFilesystem == true
      }
      
      container_violates_security(container) {
        input.parameters.allowPrivilegeEscalation == false
        container.securityContext.allowPrivilegeEscalation == true
      }
      
      container_violates_security(container) {
        input.parameters.requiredSeccompProfile
        not container.securityContext.seccompProfile.type == input.parameters.requiredSeccompProfile
      }
      
      # Check if ALL capability drops are present
      missing_capability_drops(container) {
        not container.securityContext.capabilities.drop
      }
      
      missing_capability_drops(container) {
        not "ALL" == container.securityContext.capabilities.drop[_]
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        container_violates_security(container)
        msg := sprintf("Container '%v' violates required security context", [container.name])
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        missing_capability_drops(container)
        msg := sprintf("Container '%v' must drop ALL capabilities", [container.name])
      }

---
# Apply security context constraint
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sSecurityContext
metadata:
  name: enforce-security-context
  labels:
    enforcement-level: "strict"
    security.intelgraph.io/control: "AC-6"
spec:
  enforcementAction: "deny"
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - {{ .Values.namespace | default "intelgraph" }}
  parameters:
    runAsNonRoot: true
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    requiredSeccompProfile: "RuntimeDefault"

---
# Constraint Template: Resource limits enforcement
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8sresourcelimits
  labels:
    gatekeeper.sh/enforcement: "federal"
    security.intelgraph.io/control: "SC-5"  # Denial of service protection
spec:
  crd:
    spec:
      names:
        kind: K8sResourceLimits
      validation:
        openAPIV3Schema:
          type: object
          properties:
            requireLimits:
              type: boolean
              default: true
            maxCpu:
              type: string
              default: "2000m"
            maxMemory:
              type: string
              default: "4Gi"
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8sresourcelimits
      
      # Convert resource string to numeric value for comparison
      resource_value(resource_string) = value {
        endswith(resource_string, "m")
        value := to_number(trim_suffix(resource_string, "m"))
      }
      
      resource_value(resource_string) = value {
        endswith(resource_string, "Gi")
        value := to_number(trim_suffix(resource_string, "Gi")) * 1024
      }
      
      resource_value(resource_string) = value {
        endswith(resource_string, "Mi")
        value := to_number(trim_suffix(resource_string, "Mi"))
      }
      
      # Check if container has required limits
      missing_limits(container) {
        input.parameters.requireLimits == true
        not container.resources.limits
      }
      
      missing_limits(container) {
        input.parameters.requireLimits == true
        not container.resources.limits.cpu
      }
      
      missing_limits(container) {
        input.parameters.requireLimits == true
        not container.resources.limits.memory
      }
      
      # Check if limits exceed maximum allowed
      exceeds_cpu_limit(container) {
        cpu_limit := container.resources.limits.cpu
        resource_value(cpu_limit) > resource_value(input.parameters.maxCpu)
      }
      
      exceeds_memory_limit(container) {
        memory_limit := container.resources.limits.memory
        resource_value(memory_limit) > resource_value(input.parameters.maxMemory)
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        missing_limits(container)
        msg := sprintf("Container '%v' missing required resource limits", [container.name])
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        exceeds_cpu_limit(container)
        msg := sprintf("Container '%v' CPU limit exceeds maximum allowed: %v", [container.name, input.parameters.maxCpu])
      }
      
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        container := input.review.object.spec.containers[_]
        exceeds_memory_limit(container)
        msg := sprintf("Container '%v' memory limit exceeds maximum allowed: %v", [container.name, input.parameters.maxMemory])
      }

---
# Apply resource limits constraint
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sResourceLimits
metadata:
  name: enforce-resource-limits
  labels:
    enforcement-level: "strict"
    security.intelgraph.io/control: "SC-5"
spec:
  enforcementAction: {{ .Values.federal.enforcement.resourceLimits | default "deny" }}
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - {{ .Values.namespace | default "intelgraph" }}
  parameters:
    requireLimits: true
    maxCpu: {{ .Values.federal.limits.maxCpu | default "2000m" | quote }}
    maxMemory: {{ .Values.federal.limits.maxMemory | default "4Gi" | quote }}