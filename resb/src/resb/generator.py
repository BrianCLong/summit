"""Synthetic booster pipeline."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

import numpy as np
import pandas as pd
from sklearn.neighbors import NearestNeighbors

from .config import RESBConfig
from .constraints import check_constraints
from .dp import (
    DPReport,
    apply_gaussian_noise,
    gaussian_sigma,
    infer_sensitivity,
    validate_dp_parameters,
)
from .reporting import FidelityReport, UtilityReport, build_fidelity_report, build_utility_report
from .auditor import LeakageAudit, audit_leakage


@dataclass(frozen=True)
class BoostResult:
    """Container holding the artefacts generated by RESB."""

    synthetic: pd.DataFrame
    augmented: pd.DataFrame
    reports: "Reports"
    auditor: LeakageAudit


@dataclass(frozen=True)
class Reports:
    fidelity: FidelityReport
    utility: UtilityReport
    dp: DPReport


class RESBGenerator:
    """Generate constraint-aware rare-event synthetic samples."""

    def __init__(self, config: RESBConfig):
        self.config = config
        validate_dp_parameters(config.epsilon, config.delta)

    def boost(self, df: pd.DataFrame) -> BoostResult:
        """Return synthetic samples, augmented data, and reports."""

        target = self.config.target_column
        if target not in df.columns:
            raise KeyError(f"target column '{target}' missing from dataframe")

        minority_value = self._infer_minority_value(df[target])
        minority_mask = df[target] == minority_value
        minority_df = df[minority_mask].reset_index(drop=True)
        if minority_df.empty:
            raise ValueError("No rows found for the minority class")

        synthetic = self._generate_synthetic(minority_df, target)
        augmented = pd.concat([df, synthetic], ignore_index=True)

        fidelity = build_fidelity_report(df, synthetic, target)
        utility = build_utility_report(
            original=df,
            augmented=augmented,
            target_column=target,
            minority_value=minority_value,
            precision_target=self.config.precision_target,
            seed=self.config.seed,
        )
        dp_report = self._build_dp_report(minority_df)
        auditor = audit_leakage(df, synthetic)
        return BoostResult(
            synthetic=synthetic,
            augmented=augmented,
            reports=Reports(fidelity=fidelity, utility=utility, dp=dp_report),
            auditor=auditor,
        )

    # ------------------------------------------------------------------
    def _generate_synthetic(
        self,
        minority_df: pd.DataFrame,
        target: str,
    ) -> pd.DataFrame:
        rng = np.random.default_rng(self.config.seed)
        multiplier = self.config.boost_multiplier
        n_samples = int(np.ceil(len(minority_df) * multiplier))
        if n_samples <= 0:
            raise ValueError("Computed synthetic sample count <= 0")

        numeric_columns = minority_df.select_dtypes(include=["number"]).columns.tolist()
        categorical_columns = [
            col for col in minority_df.columns if col not in numeric_columns and col != target
        ]

        candidate_rows = []
        sigma_map = self._sigma_map(minority_df, (target,))
        attempts = 0
        idx = 0

        if numeric_columns:
            knn = NearestNeighbors(n_neighbors=min(self.config.k_neighbors, len(minority_df)))
            numeric_matrix = minority_df[numeric_columns].to_numpy(dtype=float)
            knn.fit(numeric_matrix)
        else:
            knn = None
            numeric_matrix = None

        while len(candidate_rows) < n_samples and attempts < n_samples * self.config.max_attempts:
            base_index = idx % len(minority_df)
            idx += 1
            base = minority_df.iloc[base_index]
            candidate = base.copy()

            if numeric_columns and knn is not None and numeric_matrix is not None:
                base_vec = base[numeric_columns].to_numpy(dtype=float)
                neighbors = knn.kneighbors(base_vec.reshape(1, -1), return_distance=False)[0]
                neighbor_idx = int(rng.choice(neighbors))
                neighbor_vec = numeric_matrix[neighbor_idx]
                gap = rng.random(len(numeric_columns))
                candidate.loc[numeric_columns] = base_vec + gap * (neighbor_vec - base_vec)

            for column in categorical_columns:
                values = minority_df[column].dropna().unique()
                if len(values) == 0:
                    continue
                candidate[column] = rng.choice(values)

            candidate[target] = base[target]

            if check_constraints(self.config.constraints, candidate):
                candidate_rows.append(candidate.copy())
            attempts += 1

        synthetic = pd.DataFrame(candidate_rows)
        if synthetic.empty:
            raise RuntimeError("Failed to generate synthetic samples under constraints")

        noisy = apply_gaussian_noise(synthetic, sigma_map, rng)
        noisy[target] = synthetic[target].values
        return noisy.reset_index(drop=True)

    def _infer_minority_value(self, series: pd.Series) -> object:
        if self.config.minority_class is not None:
            return self.config.minority_class
        counts = series.value_counts(dropna=False)
        return counts.idxmin()

    def _sigma_map(self, minority_df: pd.DataFrame, exclude: tuple[str, ...]) -> Dict[str, float]:
        if self.config.dp_sensitivity is not None:
            return {
                column: gaussian_sigma(self.config.epsilon, self.config.delta, sensitivity)
                for column, sensitivity in self.config.dp_sensitivity.items()
                if column not in exclude
            }
        filtered = minority_df.drop(columns=list(exclude), errors="ignore")
        inferred = infer_sensitivity(filtered)
        return {
            column: gaussian_sigma(self.config.epsilon, self.config.delta, sensitivity)
            for column, sensitivity in inferred.items()
            if column not in exclude
        }

    def _build_dp_report(self, minority_df: pd.DataFrame) -> DPReport:
        sigma_map = self._sigma_map(minority_df, (self.config.target_column,))
        return DPReport(
            epsilon=self.config.epsilon,
            delta=self.config.delta,
            sigma=sigma_map,
        )
