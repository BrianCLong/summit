/**
 * Multimodal GraphQL Resolvers
 * P0 Critical - MVP1 requirement for cross-modal entity operations
 */

import MultimodalDataService from '../services/MultimodalDataService.js';
import { Driver } from 'neo4j-driver';
import { PubSub } from 'graphql-subscriptions';

interface User {
  id: string;
  email?: string;
  firstName?: string;
  lastName?: string;
}

interface Context {
  user?: User;
  neo4jDriver: Driver;
  authService: any;
  storageService: any;
  pubsub: PubSub;
  logger: any;
}

interface MediaSourceArgs {
  investigationId?: string;
  mediaType?: string;
  limit?: number;
}

interface EntityArgs {
  investigationId?: string;
  mediaType?: string;
  extractionMethod?: string;
  minConfidence?: number;
  limit?: number;
}

interface CrossModalMatchArgs {
  entityId: string;
  targetMediaTypes: string[];
  minSimilarity?: number;
  limit?: number;
}

interface ExtractionJobArgs {
  investigationId?: string;
  status?: string;
  limit?: number;
}

interface SearchInput {
  query: string;
  mediaTypes?: string[];
  entityTypes?: string[];
  investigationId?: string;
  includeCrossModal?: boolean;
  minConfidence?: number;
  limit?: number;
}

interface SemanticSearchInput {
  embedding: number[];
  mediaTypes?: string[];
  threshold?: number;
  limit?: number;
}

interface MediaSourceInput {
  uri: string;
  mediaType: string;
  mimeType: string;
  filename?: string;
  metadata?: any;
}

interface CreateMultimodalEntityInput {
  type: string;
  label: string;
  description?: string;
  properties: any;
  extractedFrom: string[];
  extractionMethod: string;
  confidence: number;
  boundingBoxes?: any[];
  temporalBounds?: any[];
  spatialContext?: any;
  investigationId: string;
}

interface CreateMultimodalRelationshipInput {
  sourceId: string;
  targetId: string;
  type: string;
  label?: string;
  properties?: any;
  extractedFrom: string[];
  extractionMethod: string;
  confidence: number;
  validFrom?: string;
  validTo?: string;
  spatialContext?: any[];
  temporalContext?: any[];
}

interface ExtractionJobInput {
  mediaSourceId: string;
  extractionMethods: string[];
  investigationId: string;
  processingParams?: any;
}

interface ReprocessMediaArgs {
  mediaSourceId: string;
  extractionMethods: string[];
  investigationId: string;
}

interface BatchUploadArgs {
  inputs: MediaSourceInput[];
}

interface BatchExtractArgs {
  mediaSourceIds: string[];
  extractionMethods: string[];
  investigationId: string;
}

interface GenerateCrossModalMatchesArgs {
  entityId: string;
  targetMediaTypes: string[];
}

interface ComputeSemanticClustersArgs {
  investigationId: string;
  algorithm?: string;
}

interface ValidateExtractionResultsArgs {
  jobId: string;
}

interface CleanupDuplicateEntitiesArgs {
  investigationId: string;
  similarity?: number;
  autoMerge?: boolean;
}

interface UpdateMediaMetadataArgs {
  id: string;
  metadata: any;
}

interface VerifyEntityArgs {
  id: string;
  verified: boolean;
}

interface MergeEntitiesArgs {
  primaryId: string;
  secondaryIds: string[];
}

export const multimodalResolvers = {
  Query: {
    // Media Sources
    mediaSources: async (parent: any, args: MediaSourceArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getMediaSources(args);
    },

    mediaSource: async (parent: any, args: { id: string }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getMediaSource(args.id);
    },

    // Multimodal Entities
    multimodalEntities: async (parent: any, args: EntityArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getMultimodalEntities(args);
    },

    multimodalEntity: async (parent: any, args: { id: string }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getMultimodalEntity(args.id);
    },

    // Cross-modal Matching
    findCrossModalMatches: async (parent: any, args: CrossModalMatchArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.findCrossModalMatches(
        args.entityId,
        args.targetMediaTypes
      );
    },

    // Extraction Jobs
    extractionJobs: async (parent: any, args: ExtractionJobArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getExtractionJobs(args);
    },

    extractionJob: async (parent: any, args: { id: string }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getExtractionJob(args.id);
    },

    // Search and Analytics
    multimodalSearch: async (parent: any, args: { input: SearchInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.multimodalSearch(args.input);
    },

    semanticSearch: async (parent: any, args: { input: SemanticSearchInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.semanticSearch(args.input);
    },

    multimodalAnalytics: async (parent: any, args: { investigationId: string }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getMultimodalAnalytics(args.investigationId);
    },

    // Quality and Verification
    unverifiedEntities: async (parent: any, args: EntityArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.getUnverifiedEntities(args);
    },

    duplicateEntities: async (parent: any, args: { investigationId?: string; similarity?: number; limit?: number }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.findDuplicateEntities(args);
    }
  },

  Mutation: {
    // Media Upload and Management
    uploadMedia: async (parent: any, args: { input: MediaSourceInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.uploadMediaSource(args.input, context.user.id);
    },

    deleteMediaSource: async (parent: any, args: { id: string }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.deleteMediaSource(args.id, context.user.id);
    },

    updateMediaMetadata: async (parent: any, args: UpdateMediaMetadataArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.updateMediaMetadata(args.id, args.metadata, context.user.id);
    },

    // Entity Creation and Management
    createMultimodalEntity: async (parent: any, args: { input: CreateMultimodalEntityInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.createMultimodalEntity(args.input, context.user.id);
    },

    updateMultimodalEntity: async (parent: any, args: { id: string; input: CreateMultimodalEntityInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.updateMultimodalEntity(args.id, args.input, context.user.id);
    },

    verifyMultimodalEntity: async (parent: any, args: VerifyEntityArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.verifyMultimodalEntity(args.id, args.verified, context.user.id);
    },

    mergeMultimodalEntities: async (parent: any, args: MergeEntitiesArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.mergeMultimodalEntities(
        args.primaryId, 
        args.secondaryIds, 
        context.user.id
      );
    },

    // Relationship Management
    createMultimodalRelationship: async (parent: any, args: { input: CreateMultimodalRelationshipInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.createMultimodalRelationship(args.input, context.user.id);
    },

    updateMultimodalRelationship: async (parent: any, args: { id: string; input: CreateMultimodalRelationshipInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.updateMultimodalRelationship(args.id, args.input, context.user.id);
    },

    verifyMultimodalRelationship: async (parent: any, args: VerifyEntityArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.verifyMultimodalRelationship(args.id, args.verified, context.user.id);
    },

    // Processing Pipeline
    startExtractionJob: async (parent: any, args: { input: ExtractionJobInput }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.startExtractionJob(args.input, context.user.id);
    },

    cancelExtractionJob: async (parent: any, args: { id: string }, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.cancelExtractionJob(args.id, context.user.id);
    },

    reprocessMedia: async (parent: any, args: ReprocessMediaArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.startExtractionJob({
        mediaSourceId: args.mediaSourceId,
        extractionMethods: args.extractionMethods,
        investigationId: args.investigationId,
        processingParams: { reprocess: true }
      }, context.user.id);
    },

    // Batch Operations
    batchUploadMedia: async (parent: any, args: BatchUploadArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      const results = [];
      for (const input of args.inputs) {
        try {
          const result = await multimodalService.uploadMediaSource(input, context.user.id);
          results.push(result);
        } catch (error) {
          context.logger.error('Batch upload error:', error);
          // Continue with other uploads
        }
      }
      
      return results;
    },

    batchExtractEntities: async (parent: any, args: BatchExtractArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      const jobs = [];
      for (const mediaSourceId of args.mediaSourceIds) {
        try {
          const job = await multimodalService.startExtractionJob({
            mediaSourceId,
            extractionMethods: args.extractionMethods,
            investigationId: args.investigationId
          }, context.user.id);
          jobs.push(job);
        } catch (error) {
          context.logger.error('Batch extraction error:', error);
          // Continue with other extractions
        }
      }
      
      return jobs;
    },

    // Cross-modal Operations
    generateCrossModalMatches: async (parent: any, args: GenerateCrossModalMatchesArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.findCrossModalMatches(args.entityId, args.targetMediaTypes);
    },

    computeSemanticClusters: async (parent: any, args: ComputeSemanticClustersArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.computeSemanticClusters(args.investigationId, args.algorithm);
    },

    // Quality and Cleanup
    validateExtractionResults: async (parent: any, args: ValidateExtractionResultsArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.validateExtractionResults(args.jobId);
    },

    cleanupDuplicateEntities: async (parent: any, args: CleanupDuplicateEntitiesArgs, context: Context) => {
      if (!context.user) throw new Error('Authentication required');
      
      const multimodalService = new MultimodalDataService(
        context.neo4jDriver, 
        context.authService,
        context.storageService
      );
      
      return await multimodalService.cleanupDuplicateEntities(
        args.investigationId,
        args.similarity || 0.95,
        args.autoMerge || false,
        context.user.id
      );
    }
  },

  Subscription: {
    // Extraction Processing
    extractionJobUpdated: {
      subscribe: async (parent: any, args: { jobId: string }, context: Context) => {
        if (!context.user) throw new Error('Authentication required');
        
        // Return subscription for job updates
        return context.pubsub.asyncIterator([`EXTRACTION_JOB_UPDATED_${args.jobId}`]);
      }
    },

    extractionJobCompleted: {
      subscribe: async (parent: any, args: { investigationId: string }, context: Context) => {
        if (!context.user) throw new Error('Authentication required');
        
        // Return subscription for completed jobs in investigation
        return context.pubsub.asyncIterator([`EXTRACTION_JOB_COMPLETED_${args.investigationId}`]);
      }
    },

    // Entity Updates
    multimodalEntityAdded: {
      subscribe: async (parent: any, args: { investigationId: string }, context: Context) => {
        if (!context.user) throw new Error('Authentication required');
        
        return context.pubsub.asyncIterator([`MULTIMODAL_ENTITY_ADDED_${args.investigationId}`]);
      }
    },

    multimodalEntityUpdated: {
      subscribe: async (parent: any, args: { investigationId: string }, context: Context) => {
        if (!context.user) throw new Error('Authentication required');
        
        return context.pubsub.asyncIterator([`MULTIMODAL_ENTITY_UPDATED_${args.investigationId}`]);
      }
    },

    multimodalEntityVerified: {
      subscribe: async (parent: any, args: { investigationId: string }, context: Context) => {
        if (!context.user) throw new Error('Authentication required');
        
        return context.pubsub.asyncIterator([`MULTIMODAL_ENTITY_VERIFIED_${args.investigationId}`]);
      }
    },

    // Cross-modal Events
    crossModalMatchFound: {
      subscribe: async (parent: any, args: { investigationId: string }, context: Context) => {
        if (!context.user) throw new Error('Authentication required');
        
        return context.pubsub.asyncIterator([`CROSS_MODAL_MATCH_FOUND_${args.investigationId}`]);
      }
    }
  },

  // Type Resolvers
  MultimodalEntity: {
    extractedFrom: async (parent: any, args: any, context: Context) => {
      // Resolve media sources for this entity
      const session = context.neo4jDriver.session();
      
      try {
        const result = await session.run(`
          MATCH (e:MultimodalEntity {id: $entityId})-[:EXTRACTED_FROM]->(m:MediaSource)
          RETURN m
        `, { entityId: parent.id });
        
        return result.records.map(record => record.get('m').properties);
      } finally {
        await session.close();
      }
    },

    crossModalMatches: async (parent: any, args: any, context: Context) => {
      // Resolve cross-modal matches for this entity
      const session = context.neo4jDriver.session();
      
      try {
        const result = await session.run(`
          MATCH (e:MultimodalEntity {id: $entityId})-[:HAS_CROSS_MODAL_MATCH]->(c:CrossModalMatch)
          RETURN c
        `, { entityId: parent.id });
        
        return result.records.map(record => record.get('c').properties);
      } finally {
        await session.close();
      }
    },

    relationships: async (parent: any, args: any, context: Context) => {
      // Resolve multimodal relationships for this entity
      const session = context.neo4jDriver.session();
      
      try {
        const result = await session.run(`
          MATCH (e:MultimodalEntity {id: $entityId})-[r:MultimodalRelationship]-(other:MultimodalEntity)
          RETURN r, other
        `, { entityId: parent.id });
        
        return result.records.map(record => ({
          ...record.get('r').properties,
          sourceEntity: parent,
          targetEntity: record.get('other').properties
        }));
      } finally {
        await session.close();
      }
    }
  },

  ExtractionJob: {
    results: async (parent: any, args: any, context: Context) => {
      if (parent.status !== 'COMPLETED') return null;
      
      // Resolve extraction results
      const session = context.neo4jDriver.session();
      
      try {
        const result = await session.run(`
          MATCH (j:ExtractionJob {id: $jobId})-[:EXTRACTED]->(e:MultimodalEntity)
          OPTIONAL MATCH (j)-[:EXTRACTED]->(r:MultimodalRelationship)
          RETURN collect(DISTINCT e) as entities, collect(DISTINCT r) as relationships
        `, { jobId: parent.id });
        
        if (result.records.length === 0) return null;
        
        const record = result.records[0];
        return {
          entities: record.get('entities').map((e: any) => e.properties),
          relationships: record.get('relationships').map((r: any) => r.properties),
          summary: {
            totalEntities: parent.entitiesExtracted,
            totalRelationships: parent.relationshipsExtracted,
            averageConfidence: 0.8, // Calculate from actual data
            processingTime: parent.duration,
            dataQualityScore: 0.85
          },
          qualityMetrics: {
            overallScore: 0.85,
            extractionAccuracy: 0.9,
            crossModalConsistency: 0.8,
            temporalConsistency: 0.85,
            duplicateRate: 0.05,
            verificationRate: 0.1
          }
        };
      } finally {
        await session.close();
      }
    }
  }
};

export default multimodalResolvers;
