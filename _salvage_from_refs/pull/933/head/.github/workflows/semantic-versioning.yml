name: Semantic Versioning and Release Gates

on:
  pull_request:
    types: [opened, synchronize, edited]
    branches: [main]
  push:
    branches: [main]

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  version-gate-check:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for Breaking Changes
        id: breaking_changes
        run: |
          echo "ðŸ” Analyzing PR for breaking changes..."

          BREAKING_PATTERNS=(
            "BREAKING CHANGE:"
            "breaking:"
            "major:"
            "!:"
            "DROP TABLE"
            "ALTER TABLE.*DROP"
            "DELETE FROM"
            "remove.*function"
            "delete.*endpoint"
          )

          HAS_BREAKING=false

          # Check commit messages
          git log --format="%s %b" origin/main..HEAD | while read -r MSG; do
            for PATTERN in "${BREAKING_PATTERNS[@]}"; do
              if echo "$MSG" | grep -qi "$PATTERN"; then
                echo "âš ï¸ Breaking change detected in commit: $MSG"
                HAS_BREAKING=true
                break
              fi
            done
          done

          # Check file changes
          CHANGED_FILES=$(git diff --name-only origin/main..HEAD)
          echo "Changed files: $CHANGED_FILES"

          # Database schema changes
          if echo "$CHANGED_FILES" | grep -q "migrations/.*\.sql$"; then
            echo "âš ï¸ Database migration detected - potential breaking change"
            HAS_BREAKING=true
          fi

          # GraphQL schema changes
          if echo "$CHANGED_FILES" | grep -q "\.graphql$"; then
            echo "â„¹ï¸ GraphQL schema changes detected - validating compatibility"
            # In a real scenario, would run GraphQL schema compatibility checks
          fi

          echo "has_breaking=$HAS_BREAKING" >> $GITHUB_OUTPUT

      - name: Require Breaking Change Review
        if: steps.breaking_changes.outputs.has_breaking == 'true'
        run: |
          echo "ðŸ›‘ Breaking changes detected - additional review required"

          gh pr edit ${{ github.event.pull_request.number }} \
            --add-label "breaking-change" \
            --add-label "needs:admin-review"

          # Post comment explaining the breaking change detection
          gh pr comment ${{ github.event.pull_request.number }} --body "
          ðŸ›‘ **Breaking Change Detected**

          This PR contains potential breaking changes and requires additional review:

          - Database migrations
          - API changes  
          - Schema modifications
          - Function/endpoint removals

          Please ensure:
          - [ ] Migration strategy is documented
          - [ ] Backward compatibility is considered
          - [ ] Rollback plan is available
          - [ ] Stakeholders are notified

          cc: @BrianCLong
          "

  release-preparation:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze Commit History for Version Bump
        id: version_analysis
        run: |
          echo "ðŸ“Š Analyzing commits since last release..."

          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last release: $LAST_TAG"

          # Analyze commits for version bump type
          COMMITS=$(git log --format="%s" ${LAST_TAG}..HEAD)

          MAJOR_COUNT=0
          MINOR_COUNT=0
          PATCH_COUNT=0

          echo "$COMMITS" | while read -r COMMIT; do
            if echo "$COMMIT" | grep -qi "BREAKING CHANGE\|breaking:\|major:\|!:"; then
              MAJOR_COUNT=$((MAJOR_COUNT + 1))
            elif echo "$COMMIT" | grep -qi "feat\|feature"; then
              MINOR_COUNT=$((MINOR_COUNT + 1))
            elif echo "$COMMIT" | grep -qi "fix\|patch\|chore"; then
              PATCH_COUNT=$((PATCH_COUNT + 1))
            fi
          done

          if [ "$MAJOR_COUNT" -gt 0 ]; then
            VERSION_TYPE="major"
          elif [ "$MINOR_COUNT" -gt 0 ]; then
            VERSION_TYPE="minor"
          else
            VERSION_TYPE="patch"
          fi

          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "Suggested version bump: $VERSION_TYPE"

      - name: Generate Release Notes
        run: |
          echo "ðŸ“ Generating release notes..."

          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          cat > "DRAFT_RELEASE_NOTES.md" << EOF_NOTES
          # Release Notes (Draft)

          **Since**: $LAST_TAG
          **Type**: ${{ steps.version_analysis.outputs.version_type }}
          **Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)

          ## What's Changed

          ### Features
          $(git log --format="- %s" --grep="feat\|feature" ${LAST_TAG}..HEAD)

          ### Bug Fixes  
          $(git log --format="- %s" --grep="fix\|patch" ${LAST_TAG}..HEAD)

          ### Infrastructure & Chores
          $(git log --format="- %s" --grep="chore\|ci\|docs" ${LAST_TAG}..HEAD)

          ### Breaking Changes
          $(git log --format="- %s" --grep="BREAKING\|breaking\|major\|!" ${LAST_TAG}..HEAD)

          ## Metrics
          - Total commits: $(git rev-list --count ${LAST_TAG}..HEAD)
          - Contributors: $(git shortlog -sn ${LAST_TAG}..HEAD | wc -l)
          - Files changed: $(git diff --stat ${LAST_TAG}..HEAD | tail -1)

          ---
          *Auto-generated by IntelGraph Release Engineering*
          EOF_NOTES

          echo "Draft release notes created: DRAFT_RELEASE_NOTES.md"
