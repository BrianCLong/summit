# Golden CI Pipeline for IntelGraph Maestro - One pipeline to rule them all
name: 'ðŸš€ IntelGraph Golden CI Pipeline'

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  KUBECONFIG_DEV: ${{ secrets.KUBECONFIG_DEV }}
  KUBECONFIG_UAT: ${{ secrets.KUBECONFIG_UAT }}
  KUBECONFIG_PROD: ${{ secrets.KUBECONFIG_PROD }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

jobs:
  # Stage 1: Code Quality and Security Gates
  quality-gates:
    name: 'ðŸ” Quality & Security Gates'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      should-deploy: ${{ steps.changes.outputs.deploy }}
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            server/package-lock.json
            client/package-lock.json

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          npm ci
          cd server && npm ci
          cd ../client && npm ci
          pip install -r requirements.txt

      - name: Run pre-commit hooks
        uses: pre-commit/action@v3.0.0
        with:
          extra_args: --all-files

      - name: TypeScript compilation
        run: |
          cd server && npm run build
          cd ../client && npm run build

      - name: Run tests with coverage
        run: |
          npm run test:coverage
          npm run e2e:headless

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true

      - name: Security scan with CodeQL
        uses: github/codeql-action/analyze@v3
        with:
          languages: javascript,typescript,python

      - name: Container security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check image pins
        if: github.event_name == 'pull_request'
        run: ./scripts/ci/check-image-pins.sh

      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            deploy:
              - 'server/**'
              - 'client/**'
              - 'infra/**'
              - 'Dockerfile*'
              - 'package*.json'

  # Stage 2: Build and Sign Images + Generate SBOM
  build-sign-sbom:
    name: 'ðŸ—ï¸ Build, Sign & SBOM'
    needs: [quality-gates]
    if: needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      sbom-path: ${{ steps.sbom.outputs.sbom-path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Install Syft for SBOM
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true

      - name: Generate SBOM
        id: sbom
        run: |
          syft ${{ steps.meta.outputs.tags }} -o spdx-json=sbom.spdx.json
          echo "sbom-path=sbom.spdx.json" >> $GITHUB_OUTPUT

      - name: Sign image with Cosign
        run: |
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
          cosign sign --key cosign.key ${{ steps.meta.outputs.tags }}@${{ steps.build.outputs.digest }}
          rm cosign.key

      - name: Attest SBOM
        run: |
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
          cosign attest --key cosign.key --predicate sbom.spdx.json ${{ steps.meta.outputs.tags }}@${{ steps.build.outputs.digest }}
          rm cosign.key

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v3
        with:
          name: sbom
          path: sbom.spdx.json
          retention-days: 30

  # Stage 3: Deploy to Dev Environment
  deploy-dev:
    name: 'ðŸš€ Deploy to Dev'
    needs: [quality-gates, build-sign-sbom]
    if: needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment:
      name: development
      url: https://maestro.dev.intelgraph.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure dev kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy infrastructure
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/namespaces/
          kubectl apply -f infra/k8s/rbac/
          kubectl apply -f infra/k8s/persistence/
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=postgres-conductor -n dev-orch --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=redis-conductor -n dev-orch --timeout=300s

      - name: Deploy Maestro/Conductor
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/deployments/
          kubectl apply -f infra/k8s/ingress/
          kubectl wait --for=condition=available deployment/maestro-conductor -n dev-orch --timeout=300s

      - name: Deploy task workers
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/workers/
          kubectl wait --for=condition=available deployment/build-worker -n dev-apps --timeout=300s
          kubectl wait --for=condition=available deployment/test-worker -n dev-apps --timeout=300s
          kubectl wait --for=condition=available deployment/security-worker -n dev-apps --timeout=300s

      - name: Update monitoring
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/monitoring/

      - name: Run smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f tests/k8s/smoke-tests.yaml
          kubectl wait --for=condition=complete job/maestro-smoke-test -n dev-orch --timeout=300s

      - name: Update deployment status
        run: |
          echo "âœ… Deployed to dev: ${{ needs.build-sign-sbom.outputs.image-tag }}"
          echo "ðŸ“Š Dashboard: https://maestro.dev.intelgraph.io/conductor"
          echo "ðŸ” Digest: ${{ needs.build-sign-sbom.outputs.image-digest }}"

  # Stage 4: Deploy to UAT (if main branch)
  deploy-uat:
    name: 'ðŸ§ª Deploy to UAT'
    needs: [quality-gates, build-sign-sbom, deploy-dev]
    if: github.ref == 'refs/heads/main' && needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: uat
      url: https://maestro.uat.intelgraph.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl & Helm
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
          chmod 700 get_helm.sh && ./get_helm.sh

      - name: Configure UAT kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_UAT }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to UAT with Canary
        run: |
          export KUBECONFIG=kubeconfig
          # Deploy with 10% canary traffic
          helm upgrade --install maestro-uat ./helm/maestro \
            --namespace uat-orch \
            --create-namespace \
            --set image.tag=${{ needs.build-sign-sbom.outputs.image-tag }} \
            --set canary.enabled=true \
            --set canary.percentage=10 \
            --set environment=uat \
            --wait --timeout=10m

      - name: Run UAT validation tests
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f tests/k8s/uat-validation.yaml
          kubectl wait --for=condition=complete job/uat-validation -n uat-orch --timeout=600s

      - name: Promote canary to 100%
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade maestro-uat ./helm/maestro \
            --namespace uat-orch \
            --set canary.percentage=100 \
            --wait --timeout=5m

  # Stage 5: Deploy to Production (on release)
  deploy-production:
    name: 'ðŸŒŸ Deploy to Production'
    needs: [quality-gates, build-sign-sbom]
    if: github.event_name == 'release' && github.event.action == 'published'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: production
      url: https://maestro.intelgraph.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup production deployment
        run: |
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Production deployment with blue-green
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade --install maestro-prod ./helm/maestro \
            --namespace prod-orch \
            --create-namespace \
            --set image.tag=${{ github.event.release.tag_name }} \
            --set environment=production \
            --set blueGreen.enabled=true \
            --wait --timeout=15m

      - name: Run production smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f tests/k8s/production-smoke.yaml -n prod-orch
          kubectl wait --for=condition=complete job/prod-smoke-test -n prod-orch --timeout=600s

  # Notification and Cleanup
  notify:
    name: 'ðŸ“¢ Notify & Cleanup'
    needs: [quality-gates, build-sign-sbom, deploy-dev, deploy-uat, deploy-production]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#intelgraph-deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: Update GitHub deployment status
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: '${{ job.status }}'
          deployment-id: ${{ github.event.deployment.id }}

  # Security scanning and compliance
  security-compliance:
    name: 'ðŸ”’ Security & Compliance'
    needs: build-sign-sbom
    if: needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Run Grype vulnerability scan
        uses: anchore/scan-action@v3
        with:
          image: ${{ needs.build-sign-sbom.outputs.image-tag }}
          fail-build: true
          severity-cutoff: high

      - name: Generate compliance report
        run: |
          echo "# Security Compliance Report" > compliance-report.md
          echo "## Image: ${{ needs.build-sign-sbom.outputs.image-tag }}" >> compliance-report.md
          echo "## Digest: ${{ needs.build-sign-sbom.outputs.image-digest }}" >> compliance-report.md
          echo "## Scan Date: $(date)" >> compliance-report.md
          echo "## Status: âœ… PASSED" >> compliance-report.md

      - name: Upload compliance report
        uses: actions/upload-artifact@v3
        with:
          name: compliance-report
          path: compliance-report.md
