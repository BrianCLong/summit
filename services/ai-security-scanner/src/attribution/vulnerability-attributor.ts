/**
 * Vulnerability Attributor - Root cause analysis and attribution
 *
 * Provides comprehensive attribution for detected vulnerabilities:
 * - Root cause analysis
 * - Attack vector mapping
 * - Threat actor correlation
 * - Historical tracking
 * - Risk scoring
 */

import { createHash, randomUUID } from 'node:crypto';
import type {
  Vulnerability,
  Attribution,
  Evidence,
  SeverityLevel,
  VulnerabilityCategory,
} from '../types.js';
import { ComplianceLogger } from '../compliance/compliance-logger.js';

export interface AttributionConfig {
  enableAIAnalysis: boolean;
  enableThreatIntel: boolean;
  correlationWindow: number; // milliseconds
  minConfidence: number; // 0-1
}

export interface AttributionResult {
  vulnerabilityId: string;
  attribution: EnhancedAttribution;
  correlatedVulnerabilities: string[];
  threatActorCorrelation?: ThreatActorCorrelation;
  timeline: TimelineEvent[];
  riskAssessment: RiskAssessment;
}

interface EnhancedAttribution extends Attribution {
  rootCauseAnalysis: RootCauseAnalysis;
  attackChain?: AttackChainStep[];
  mitreTactics?: MitreTactic[];
  cveCorrelation?: string[];
}

interface RootCauseAnalysis {
  primaryCause: string;
  contributingFactors: string[];
  introducedBy: string; // commit, deployment, config change, etc.
  introducedAt?: Date;
  affectedComponents: string[];
}

interface AttackChainStep {
  step: number;
  technique: string;
  description: string;
  mitigated: boolean;
}

interface MitreTactic {
  id: string;
  name: string;
  technique: string;
  subtechnique?: string;
}

interface ThreatActorCorrelation {
  likelihood: number;
  knownActors: string[];
  ttps: string[]; // Tactics, Techniques, and Procedures
  indicators: string[];
}

interface TimelineEvent {
  timestamp: Date;
  event: string;
  details: Record<string, unknown>;
}

interface RiskAssessment {
  overallRisk: number;
  exploitability: number;
  impact: number;
  likelihood: number;
  businessCriticality: number;
  factors: RiskFactor[];
}

interface RiskFactor {
  name: string;
  weight: number;
  score: number;
  description: string;
}

// MITRE ATT&CK mapping for vulnerability categories
const MITRE_MAPPINGS: Record<VulnerabilityCategory, MitreTactic[]> = {
  injection: [
    { id: 'T1190', name: 'Initial Access', technique: 'Exploit Public-Facing Application' },
    { id: 'T1059', name: 'Execution', technique: 'Command and Scripting Interpreter' },
  ],
  authentication: [
    { id: 'T1078', name: 'Initial Access', technique: 'Valid Accounts' },
    { id: 'T1110', name: 'Credential Access', technique: 'Brute Force' },
  ],
  authorization: [
    { id: 'T1548', name: 'Privilege Escalation', technique: 'Abuse Elevation Control Mechanism' },
    { id: 'T1068', name: 'Privilege Escalation', technique: 'Exploitation for Privilege Escalation' },
  ],
  cryptographic: [
    { id: 'T1557', name: 'Credential Access', technique: 'Adversary-in-the-Middle' },
    { id: 'T1040', name: 'Credential Access', technique: 'Network Sniffing' },
  ],
  configuration: [
    { id: 'T1574', name: 'Persistence', technique: 'Hijack Execution Flow' },
    { id: 'T1543', name: 'Persistence', technique: 'Create or Modify System Process' },
  ],
  'data-exposure': [
    { id: 'T1005', name: 'Collection', technique: 'Data from Local System' },
    { id: 'T1567', name: 'Exfiltration', technique: 'Exfiltration Over Web Service' },
  ],
  dos: [
    { id: 'T1499', name: 'Impact', technique: 'Endpoint Denial of Service' },
    { id: 'T1498', name: 'Impact', technique: 'Network Denial of Service' },
  ],
  'supply-chain': [
    { id: 'T1195', name: 'Initial Access', technique: 'Supply Chain Compromise' },
    { id: 'T1199', name: 'Initial Access', technique: 'Trusted Relationship' },
  ],
  'logic-flaw': [
    { id: 'T1068', name: 'Privilege Escalation', technique: 'Exploitation for Privilege Escalation' },
  ],
};

// Known vulnerability patterns for root cause analysis
const ROOT_CAUSE_PATTERNS: Record<string, RootCausePattern> = {
  UNSANITIZED_INPUT: {
    indicators: ['req.body', 'req.params', 'req.query', 'user input'],
    cause: 'Unsanitized user input passed to sensitive operation',
    factors: ['Missing input validation', 'Lack of sanitization library', 'Developer oversight'],
  },
  WEAK_DEFAULTS: {
    indicators: ['default', 'TODO', 'FIXME', 'hardcoded'],
    cause: 'Insecure default configuration or hardcoded values',
    factors: ['Development shortcuts', 'Missing security review', 'Configuration management gap'],
  },
  MISSING_AUTH: {
    indicators: ['no auth', 'skip auth', 'public', 'anonymous'],
    cause: 'Missing or bypassed authentication/authorization',
    factors: ['Incomplete access control', 'Feature creep', 'Testing artifact'],
  },
  OUTDATED_DEPENDENCY: {
    indicators: ['CVE-', 'vulnerability', 'outdated', 'deprecated'],
    cause: 'Vulnerable third-party dependency',
    factors: ['Dependency management gap', 'Missing security updates', 'Compatibility constraints'],
  },
  CRYPTO_WEAKNESS: {
    indicators: ['md5', 'sha1', 'des', 'weak', 'deprecated'],
    cause: 'Use of weak or deprecated cryptographic algorithms',
    factors: ['Legacy code', 'Performance optimization', 'Compatibility requirements'],
  },
};

interface RootCausePattern {
  indicators: string[];
  cause: string;
  factors: string[];
}

export class VulnerabilityAttributor {
  private config: AttributionConfig;
  private logger: ComplianceLogger;
  private vulnerabilityHistory: Map<string, Vulnerability[]> = new Map();

  constructor(config: Partial<AttributionConfig> = {}) {
    this.config = {
      enableAIAnalysis: true,
      enableThreatIntel: false,
      correlationWindow: 86400000 * 30, // 30 days
      minConfidence: 0.7,
      ...config,
    };

    this.logger = new ComplianceLogger({
      serviceName: 'vulnerability-attributor',
      enableZeroTrust: true,
      retentionDays: 2555,
    });
  }

  /**
   * Attribute a vulnerability with comprehensive analysis
   */
  async attributeVulnerability(vuln: Vulnerability): Promise<AttributionResult> {
    const attributionId = randomUUID();

    await this.logger.logAction(attributionId, 'attribution-start', {
      vulnerabilityId: vuln.id,
      severity: vuln.severity,
      category: vuln.category,
    });

    // Perform root cause analysis
    const rootCauseAnalysis = this.analyzeRootCause(vuln);

    // Map to MITRE ATT&CK
    const mitreTactics = this.mapToMitre(vuln.category);

    // Build attack chain
    const attackChain = this.buildAttackChain(vuln, mitreTactics);

    // Correlate with historical vulnerabilities
    const correlatedVulns = this.correlateVulnerabilities(vuln);

    // Assess threat actor correlation if enabled
    let threatActorCorrelation: ThreatActorCorrelation | undefined;
    if (this.config.enableThreatIntel) {
      threatActorCorrelation = await this.correlateThreatActors(vuln, mitreTactics);
    }

    // Build timeline
    const timeline = this.buildTimeline(vuln);

    // Calculate risk assessment
    const riskAssessment = this.assessRisk(vuln, correlatedVulns.length);

    const enhancedAttribution: EnhancedAttribution = {
      ...vuln.attribution,
      rootCauseAnalysis,
      attackChain,
      mitreTactics,
      cveCorrelation: vuln.cveId ? [vuln.cveId] : [],
    };

    const result: AttributionResult = {
      vulnerabilityId: vuln.id,
      attribution: enhancedAttribution,
      correlatedVulnerabilities: correlatedVulns,
      threatActorCorrelation,
      timeline,
      riskAssessment,
    };

    // Store for future correlation
    this.storeVulnerability(vuln);

    await this.logger.logAction(attributionId, 'attribution-complete', {
      vulnerabilityId: vuln.id,
      rootCause: rootCauseAnalysis.primaryCause,
      mitreCount: mitreTactics.length,
      correlatedCount: correlatedVulns.length,
      riskScore: riskAssessment.overallRisk,
    });

    return result;
  }

  /**
   * Batch attribution for multiple vulnerabilities
   */
  async attributeVulnerabilities(vulns: Vulnerability[]): Promise<AttributionResult[]> {
    const results: AttributionResult[] = [];

    for (const vuln of vulns) {
      const result = await this.attributeVulnerability(vuln);
      results.push(result);
    }

    return results;
  }

  /**
   * Analyze root cause of vulnerability
   */
  private analyzeRootCause(vuln: Vulnerability): RootCauseAnalysis {
    const codeContext = vuln.location.codeSnippet.toLowerCase();
    let primaryCause = 'Unknown root cause';
    let contributingFactors: string[] = [];

    // Match against known patterns
    for (const [, pattern] of Object.entries(ROOT_CAUSE_PATTERNS)) {
      const matches = pattern.indicators.filter((i) => codeContext.includes(i.toLowerCase()));
      if (matches.length > 0) {
        primaryCause = pattern.cause;
        contributingFactors = pattern.factors;
        break;
      }
    }

    // Extract affected components
    const affectedComponents = this.extractAffectedComponents(vuln);

    return {
      primaryCause,
      contributingFactors,
      introducedBy: 'source-code', // Would be enhanced with git blame integration
      affectedComponents,
    };
  }

  /**
   * Extract affected components from vulnerability
   */
  private extractAffectedComponents(vuln: Vulnerability): string[] {
    const components: string[] = [];

    // Extract from file path
    const pathParts = vuln.location.file.split('/');
    if (pathParts.includes('services')) {
      const serviceIndex = pathParts.indexOf('services');
      if (serviceIndex < pathParts.length - 1) {
        components.push(`service:${pathParts[serviceIndex + 1]}`);
      }
    }
    if (pathParts.includes('packages')) {
      const pkgIndex = pathParts.indexOf('packages');
      if (pkgIndex < pathParts.length - 1) {
        components.push(`package:${pathParts[pkgIndex + 1]}`);
      }
    }

    // Add function/class if available
    if (vuln.location.functionName) {
      components.push(`function:${vuln.location.functionName}`);
    }
    if (vuln.location.className) {
      components.push(`class:${vuln.location.className}`);
    }

    return components;
  }

  /**
   * Map vulnerability category to MITRE ATT&CK
   */
  private mapToMitre(category: VulnerabilityCategory): MitreTactic[] {
    return MITRE_MAPPINGS[category] || [];
  }

  /**
   * Build potential attack chain
   */
  private buildAttackChain(vuln: Vulnerability, mitre: MitreTactic[]): AttackChainStep[] {
    const chain: AttackChainStep[] = [];

    // Initial access
    chain.push({
      step: 1,
      technique: 'Initial Access',
      description: `Exploit ${vuln.category} vulnerability in ${vuln.location.file}`,
      mitigated: false,
    });

    // Add MITRE-based steps
    mitre.forEach((tactic, index) => {
      chain.push({
        step: index + 2,
        technique: tactic.name,
        description: tactic.technique,
        mitigated: false,
      });
    });

    // Potential impact
    chain.push({
      step: chain.length + 1,
      technique: 'Impact',
      description: this.getImpactDescription(vuln.category),
      mitigated: false,
    });

    return chain;
  }

  /**
   * Get impact description for vulnerability category
   */
  private getImpactDescription(category: VulnerabilityCategory): string {
    const impacts: Record<VulnerabilityCategory, string> = {
      injection: 'Remote code execution or data manipulation',
      authentication: 'Unauthorized system access',
      authorization: 'Privilege escalation',
      cryptographic: 'Data breach or impersonation',
      configuration: 'System compromise',
      'data-exposure': 'Sensitive data exfiltration',
      dos: 'Service disruption',
      'supply-chain': 'Widespread compromise',
      'logic-flaw': 'Business logic bypass',
    };
    return impacts[category];
  }

  /**
   * Correlate with historical vulnerabilities
   */
  private correlateVulnerabilities(vuln: Vulnerability): string[] {
    const correlated: string[] = [];
    const cutoff = Date.now() - this.config.correlationWindow;

    for (const [, history] of this.vulnerabilityHistory) {
      for (const historical of history) {
        if (historical.detectedAt.getTime() < cutoff) continue;
        if (historical.id === vuln.id) continue;

        // Correlate by same file
        if (historical.location.file === vuln.location.file) {
          correlated.push(historical.id);
          continue;
        }

        // Correlate by same category and severity
        if (historical.category === vuln.category && historical.severity === vuln.severity) {
          correlated.push(historical.id);
        }
      }
    }

    return [...new Set(correlated)];
  }

  /**
   * Correlate with known threat actors (placeholder for threat intel integration)
   */
  private async correlateThreatActors(
    vuln: Vulnerability,
    mitre: MitreTactic[]
  ): Promise<ThreatActorCorrelation> {
    // This would integrate with threat intelligence feeds
    return {
      likelihood: 0.3,
      knownActors: [],
      ttps: mitre.map((m) => m.id),
      indicators: [],
    };
  }

  /**
   * Build timeline of vulnerability
   */
  private buildTimeline(vuln: Vulnerability): TimelineEvent[] {
    const timeline: TimelineEvent[] = [];

    timeline.push({
      timestamp: vuln.detectedAt,
      event: 'Vulnerability detected',
      details: {
        scanner: vuln.attribution.source,
        confidence: vuln.attribution.confidence,
      },
    });

    if (vuln.status !== 'open') {
      timeline.push({
        timestamp: new Date(),
        event: `Status changed to ${vuln.status}`,
        details: {},
      });
    }

    return timeline;
  }

  /**
   * Assess overall risk
   */
  private assessRisk(vuln: Vulnerability, correlatedCount: number): RiskAssessment {
    const factors: RiskFactor[] = [];

    // CVSS-based exploitability
    const exploitability = vuln.cvssScore / 10;
    factors.push({
      name: 'Exploitability',
      weight: 0.3,
      score: exploitability,
      description: `CVSS score: ${vuln.cvssScore}`,
    });

    // Impact based on category
    const impactScores: Record<VulnerabilityCategory, number> = {
      injection: 0.9,
      authentication: 0.95,
      authorization: 0.85,
      cryptographic: 0.8,
      'data-exposure': 0.85,
      configuration: 0.6,
      dos: 0.5,
      'supply-chain': 0.95,
      'logic-flaw': 0.7,
    };
    const impact = impactScores[vuln.category];
    factors.push({
      name: 'Impact',
      weight: 0.3,
      score: impact,
      description: `Category: ${vuln.category}`,
    });

    // Likelihood based on exposure
    const likelihood = vuln.severity === 'critical' ? 0.9 : vuln.severity === 'high' ? 0.7 : 0.5;
    factors.push({
      name: 'Likelihood',
      weight: 0.2,
      score: likelihood,
      description: `Severity: ${vuln.severity}`,
    });

    // Business criticality based on correlation
    const businessCriticality = Math.min(1, 0.5 + correlatedCount * 0.1);
    factors.push({
      name: 'Business Criticality',
      weight: 0.2,
      score: businessCriticality,
      description: `${correlatedCount} correlated vulnerabilities`,
    });

    const overallRisk = factors.reduce((sum, f) => sum + f.weight * f.score, 0);

    return {
      overallRisk: Math.round(overallRisk * 100),
      exploitability: Math.round(exploitability * 100),
      impact: Math.round(impact * 100),
      likelihood: Math.round(likelihood * 100),
      businessCriticality: Math.round(businessCriticality * 100),
      factors,
    };
  }

  /**
   * Store vulnerability for future correlation
   */
  private storeVulnerability(vuln: Vulnerability): void {
    const key = vuln.location.file;
    const existing = this.vulnerabilityHistory.get(key) || [];
    existing.push(vuln);
    this.vulnerabilityHistory.set(key, existing);
  }
}
