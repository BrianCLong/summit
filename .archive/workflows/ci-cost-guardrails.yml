name: ci-cost-guardrails
on:
  push:
    branches: [ main ]
  schedule:
    - cron: '15 3 * * *' # daily budget sweep
  workflow_dispatch:
    inputs:
      soft_fail:
        description: 'Do not fail the workflow (report only)'
        default: 'false'
        required: false
permissions:
  contents: read
  actions: read
  packages: read
  id-token: write
jobs:
  budget:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with: { node-version: 20 }
      - name: Install deps
        run: npm i -g zx
      - name: CI Budget Check (this run + month-to-date)
        env:
          ORG: ${{ github.repository_owner }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Guardrails (edit to your targets)
          CI_COST_USD_MONTHLY_LIMIT: '5000'   # Prod limit for CI minutes & storage combined
          CI_COST_ALERT_THRESHOLD: '0.8'      # 80%
          RUN_COST_MAX_USD: '30'              # single-run cost cap
          RUNNER_COST_PER_MIN_USD: '0.008'    # est. for GitHub-hosted linux runners
        run: |
          npx zx <<'ZX'
          import 'zx/globals';
          const org = process.env.ORG;
          const repo = process.env.REPO;
          const runId = process.env.RUN_ID;
          const perMin = parseFloat(process.env.RUNNER_COST_PER_MIN_USD);
          const run = await $`gh api repos/${repo}/actions/runs/${runId}`.then(r=>JSON.parse(r.stdout));
          const durMin = (run.run_duration_ms ?? 0) / 60000;
          const runCost = +(durMin * perMin).toFixed(2);
          console.log(`Run duration: ${durMin.toFixed(1)} min, est cost: $${runCost}`);

          // Month-to-date usage: sum workflow runs (approx). Admin-only billing API is not assumed.
          const since = new Date(); since.setDate(1);
          const sinceIso = since.toISOString();
          let page=1, totalMs=0;
          while (true) {
            const resp = await $`gh api repos/${repo}/actions/runs --paginate -X GET -F per_page=100 -F created=>=${sinceIso} -F status=completed -F page=${page}`.then(r=>JSON.parse(r.stdout));
            const runs = resp.workflow_runs || resp;
            if (!runs.length) break;
            for (const wr of runs) totalMs += wr.run_duration_ms || 0;
            page++;
            if (runs.length < 100) break;
          }
          const monthMin = totalMs / 60000;
          const monthCost = +(monthMin * perMin).toFixed(2);
          console.log(`Month-to-date runtime: ${monthMin.toFixed(0)} min, est cost: $${monthCost}`);

          const limit = parseFloat(process.env.CI_COST_USD_MONTHLY_LIMIT);
          const alertThresh = parseFloat(process.env.CI_COST_ALERT_THRESHOLD);
          const alert = monthCost >= limit * alertThresh;
          const hardFail = monthCost > limit || runCost > parseFloat(process.env.RUN_COST_MAX_USD);

          if (alert) console.log(`WARNING: CI cost over ${alertThresh*100}% of budget.`);
          if (hardFail) {
            console.error(`FAIL: CI budget exceeded (run>$${process.env.RUN_COST_MAX_USD} or month>$${limit}).`);
            if ((process.env.INPUT_SOFT_FAIL||'false') !== 'true') process.exit(1);
          }
          ZX

  ghcr:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup crane
        uses: imjasonh/setup-crane@v0.3
      - name: GHCR Image Size Budget
        env:
          REGISTRY: ghcr.io
          IMAGE: ${{ github.repository }}
          MAX_IMAGE_SIZE_MB: '350'   # cap per image
        run: |
          set -euo pipefail
          TAGS=$(gh api /orgs/${GITHUB_REPOSITORY_OWNER}/packages/container/${IMAGE##*/}/versions --paginate | jq -r '.[].metadata.container.tags[]' | sort -u | head -n 10)
          FAIL=0
          for t in $TAGS; do
            ref=${REGISTRY}/${IMAGE}:$t
            size=$(crane manifest ${ref} | jq -r '.layers | map(.size) | add')
            mb=$((size/1024/1024))
            echo "$ref -> ${mb}MB"
            if [ $mb -gt ${MAX_IMAGE_SIZE_MB} ]; then echo "FAIL size>${MAX_IMAGE_SIZE_MB}MB"; FAIL=1; fi
          done
          exit $FAIL