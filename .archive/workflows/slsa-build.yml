name: slsa-build
on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  id-token: write # For OIDC
  attestations: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.build.outputs.image-uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          target: production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          sbom: true
          provenance: true

      - name: Generate SBOM
        run: |
          # Install Syft for SBOM generation
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin v1.0.1
          
          # Generate SBOM for the built image
          syft ${{ steps.build.outputs.image-uri }} -o json > sbom.json
          syft ${{ steps.build.outputs.image-uri }} -o spdx-json > sbom.spdx.json
          
      - name: Security scan with Grype
        run: |
          # Install Grype for vulnerability scanning
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin v1.0.0
          
          # Scan for vulnerabilities
          grype ${{ steps.build.outputs.image-uri }} --output json > vulnerability-report.json
          grype ${{ steps.build.outputs.image-uri }} --fail-on critical --output table

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: v2.2.4

      - name: Sign image with Cosign
        run: |
          echo "Signing image: ${{ steps.build.outputs.image-uri }}"
          cosign sign --yes ${{ steps.build.outputs.image-uri }}

      - name: Attest SBOM
        run: |
          # Attach SBOM as attestation
          cosign attest --yes --predicate sbom.spdx.json --type spdx ${{ steps.build.outputs.image-uri }}
          
      - name: Attest vulnerability scan
        run: |
          # Create vulnerability attestation
          cat > vuln-predicate.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "scanner": "grype",
            "uri": "${{ steps.build.outputs.image-uri }}",
            "version": "$(grype version 2>/dev/null | head -1)",
            "vulnerabilities": $(jq '.matches | length' vulnerability-report.json),
            "critical": $(jq '[.matches[] | select(.vulnerability.severity == "Critical")] | length' vulnerability-report.json),
            "high": $(jq '[.matches[] | select(.vulnerability.severity == "High")] | length' vulnerability-report.json),
            "medium": $(jq '[.matches[] | select(.vulnerability.severity == "Medium")] | length' vulnerability-report.json),
            "low": $(jq '[.matches[] | select(.vulnerability.severity == "Low")] | length' vulnerability-report.json)
          }
          EOF
          
          cosign attest --yes --predicate vuln-predicate.json --type vuln ${{ steps.build.outputs.image-uri }}

      - name: Generate provenance
        run: |
          # Create provenance document
          cat > provenance.json <<EOF
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "predicateType": "https://slsa.dev/provenance/v0.2",
            "subject": [
              {
                "name": "${{ steps.build.outputs.image-uri }}",
                "digest": {
                  "sha256": "${{ steps.build.outputs.digest }}"
                }
              }
            ],
            "predicate": {
              "builder": {
                "id": "https://github.com/actions/runner"
              },
              "buildType": "https://github.com/actions/runner/docker-build",
              "invocation": {
                "configSource": {
                  "uri": "${{ github.server_url }}/${{ github.repository }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  }
                }
              },
              "metadata": {
                "buildInvocationId": "${{ github.run_id }}",
                "buildStartedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "completeness": {
                  "parameters": true,
                  "environment": false,
                  "materials": true
                },
                "reproducible": false
              },
              "materials": [
                {
                  "uri": "${{ github.server_url }}/${{ github.repository }}",
                  "digest": {
                    "sha1": "${{ github.sha }}"
                  }
                }
              ]
            }
          }
          EOF
          
          # Sign provenance
          cosign attest --yes --predicate provenance.json --type slsaprovenance ${{ steps.build.outputs.image-uri }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: slsa-artifacts
          path: |
            sbom.json
            sbom.spdx.json
            vulnerability-report.json
            provenance.json
            vuln-predicate.json

  verify:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Verify image signature
        run: |
          echo "Verifying signature for: ${{ needs.build.outputs.image-uri }}"
          cosign verify ${{ needs.build.outputs.image-uri }} \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com"

      - name: Verify SBOM attestation
        run: |
          echo "Verifying SBOM attestation"
          cosign verify-attestation ${{ needs.build.outputs.image-uri }} \
            --type spdx \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com"

      - name: Verify provenance attestation
        run: |
          echo "Verifying provenance attestation"
          cosign verify-attestation ${{ needs.build.outputs.image-uri }} \
            --type slsaprovenance \
            --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com"

      - name: Policy check
        run: |
          # Check if image meets security policy
          CRITICAL=$(cosign verify-attestation ${{ needs.build.outputs.image-uri }} --type vuln --output json | jq -r '.payload' | base64 -d | jq '.predicate.critical')
          
          if [ "$CRITICAL" -gt "0" ]; then
            echo "❌ Policy violation: $CRITICAL critical vulnerabilities found"
            exit 1
          else
            echo "✅ Security policy passed: No critical vulnerabilities"
          fi

  slsa-provenance:
    needs: build
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    permissions:
      actions: read
      id-token: write
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
    with:
      image: ${{ needs.build.outputs.image-uri }}
      digest: ${{ needs.build.outputs.image-digest }}
    secrets:
      registry-password: ${{ secrets.GITHUB_TOKEN }}

  release:
    needs: [build, verify]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: slsa-artifacts

      - name: Create release bundle
        run: |
          # Create a release bundle with all attestations
          tar -czf maestro-v04-release-bundle.tar.gz \
            sbom.json sbom.spdx.json \
            vulnerability-report.json \
            provenance.json vuln-predicate.json
          
          # Generate release manifest
          cat > release-manifest.json <<EOF
          {
            "version": "v0.4-$(date +%Y%m%d)",
            "image": "${{ needs.build.outputs.image-uri }}",
            "digest": "${{ needs.build.outputs.image-digest }}",
            "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "attestations": {
              "sbom": "sbom.spdx.json",
              "vulnerabilities": "vulnerability-report.json", 
              "provenance": "provenance.json"
            },
            "signatures": {
              "cosign": true,
              "slsa": true
            },
            "security": {
              "critical_vulns": $(jq '.critical' vuln-predicate.json),
              "high_vulns": $(jq '.high' vuln-predicate.json),
              "scan_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            }
          }
          EOF

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: maestro-v04-release
          path: |
            maestro-v04-release-bundle.tar.gz
            release-manifest.json