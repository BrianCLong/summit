# Golden CI Pipeline for IntelGraph Maestro - One pipeline to rule them all
name: 'ðŸš€ IntelGraph Golden CI Pipeline'

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  KUBECONFIG_DEV: ${{ secrets.KUBECONFIG_DEV }}
  KUBECONFIG_UAT: ${{ secrets.KUBECONFIG_UAT }}
  KUBECONFIG_PROD: ${{ secrets.KUBECONFIG_PROD }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

permissions:
  contents: read

jobs:
  # Stage 1: Code Quality and Security Gates
  quality-gates:
    name: 'ðŸ” Quality & Security Gates'
    runs-on: ubuntu-latest
    permissions:
      checks: write
      deployments: read
    timeout-minutes: 15
    strategy:
      matrix:
        shard: [1, 2, 3, 4, 5, 6]
    outputs:
      should-deploy: ${{ steps.changes.outputs.deploy }}
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'pnpm'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> "$GITHUB_ENV"

      - name: Set up pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Set up turbo cache
        uses: actions/cache@v4
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-

      - name: Install dependencies
        run: |
          pnpm -w install
          pip install -r requirements.txt

      - name: Run pre-commit hooks
        uses: pre-commit/action@v3.0.0
        with:
          extra_args: --all-files

      - name: Build
        run: pnpm -w turbo run build

      - name: Split tests
        id: split-tests
        uses: actions/split-tests@v1
        with:
          test-files: '**/*.test.ts'
          timings-file: 'ci/test-timings.json'
          total-shards: ${{ matrix.shard-total }}
          shard-index: ${{ matrix.shard-index }}

      - name: Run tests
        run: pnpm -w turbo run test -- --reporter=junit --outputFile=junit.xml ${{ steps.split-tests.outputs.test-files }}

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.shard }}
          path: junit.xml

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true

      - name: Security scan with CodeQL
        uses: github/codeql-action/analyze@v3
        with:
          languages: javascript,typescript,python

      - name: Container security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check image pins
        if: github.event_name == 'pull_request'
        run: ./scripts/ci/check-image-pins.sh

      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            deploy:
              - 'server/**'
              - 'client/**'
              - 'infra/**'
              - 'Dockerfile*'
              - 'package*.json'

  # Stage 2: Build and Sign Images + Generate SBOM
  python-worker-tests:
    name: 'ðŸ Python Worker Tests'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      - name: Install dependencies
        run: pip install -r worker/requirements.txt
      - name: Run tests
        run: pytest -q --maxfail=1 --disable-warnings --junitxml=pytest.xml

  dbt-build:
    name: 'ðŸ’§ dbt Build'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Cache dbt packages
        uses: actions/cache@v4
        with:
          path: ~/.dbt
          key: ${{ runner.os }}-dbt-${{ hashFiles('**/dbt_project.yml') }}
          restore-keys: |
            ${{ runner.os }}-dbt-
      - name: Install dbt dependencies
        run: pip install dbt-core dbt-postgres
      - name: Install dbt project dependencies
        run: dbt deps
        working-directory: ./warehouse
      - name: Compile dbt models
        run: dbt compile
        working-directory: ./warehouse

  helm-chart-test:
    name: 'Helm Chart Test'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0
      - name: Set up chart-testing
        uses: helm/chart-testing-action@v2.6.1
      - name: Run chart-testing lint
        run: ct lint
      - name: Run chart-testing test
        run: ct test

  flaky-tests:
    name: ' flaky-tests'
    runs-on: ubuntu-latest
    needs: [quality-gates]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Run flaky tests
        run: pnpm -w turbo run test -- --tag=flaky

  build-sign-sbom:
    name: 'ðŸ—ï¸ Build, Sign & SBOM'
    permissions:
      packages: write
    needs: [quality-gates]
    if: needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      sbom-path: ${{ steps.sbom.outputs.sbom-path }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Install Syft for SBOM
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true

      - name: Generate SBOM
        id: sbom
        run: |
          syft ${{ steps.meta.outputs.tags }} -o spdx-json=sbom.spdx.json
          echo "sbom-path=sbom.spdx.json" >> $GITHUB_OUTPUT

      - name: Sign image with Cosign
        run: |
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
          cosign sign --key cosign.key ${{ steps.meta.outputs.tags }}@${{ steps.build.outputs.digest }}
          rm cosign.key

      - name: Attest SBOM
        run: |
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
          cosign attest --key cosign.key --predicate sbom.spdx.json ${{ steps.meta.outputs.tags }}@${{ steps.build.outputs.digest }}
          rm cosign.key

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v3
        with:
          name: sbom
          path: sbom.spdx.json
          retention-days: 30

  # Stage 3: Deploy to Dev Environment
  deploy-dev:
    name: 'ðŸš€ Deploy to Dev'
    permissions:
      deployments: write
    needs: [quality-gates, build-sign-sbom]
    if: needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment:
      name: development
      url: https://maestro.dev.intelgraph.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: Configure dev kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy infrastructure
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/namespaces/
          kubectl apply -f infra/k8s/rbac/
          kubectl apply -f infra/k8s/persistence/
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=postgres-conductor -n dev-orch --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=redis-conductor -n dev-orch --timeout=300s

      - name: Deploy Maestro/Conductor
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/deployments/
          kubectl apply -f infra/k8s/ingress/
          kubectl wait --for=condition=available deployment/maestro-conductor -n dev-orch --timeout=300s

      - name: Deploy task workers
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/workers/
          kubectl wait --for=condition=available deployment/build-worker -n dev-apps --timeout=300s
          kubectl wait --for=condition=available deployment/test-worker -n dev-apps --timeout=300s
          kubectl wait --for=condition=available deployment/security-worker -n dev-apps --timeout=300s

      - name: Update monitoring
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f infra/k8s/monitoring/

      - name: Run smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f tests/k8s/smoke-tests.yaml
          kubectl wait --for=condition=complete job/maestro-smoke-test -n dev-orch --timeout=300s

      - name: Update deployment status
        run: |
          echo "âœ… Deployed to dev: ${{ needs.build-sign-sbom.outputs.image-tag }}"
          echo "ðŸ“Š Dashboard: https://maestro.dev.intelgraph.io/conductor"
          echo "ðŸ” Digest: ${{ needs.build-sign-sbom.outputs.image-digest }}"

  # Stage 4: Deploy to UAT (if main branch)
  deploy-uat:
    name: 'ðŸ§ª Deploy to UAT'
    permissions:
      deployments: write
    needs: [quality-gates, build-sign-sbom, deploy-dev]
    if: github.ref == 'refs/heads/main' && needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: uat
      url: https://maestro.uat.intelgraph.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl & Helm
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
          chmod 700 get_helm.sh && ./get_helm.sh

      - name: Configure UAT kubeconfig
        run: |
          echo "${{ secrets.KUBECONFIG_UAT }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to UAT with Canary
        run: |
          export KUBECONFIG=kubeconfig
          # Deploy with 10% canary traffic
          helm upgrade --install maestro-uat ./helm/maestro \
            --namespace uat-orch \
            --create-namespace \
            --set image.tag=${{ needs.build-sign-sbom.outputs.image-tag }} \
            --set canary.enabled=true \
            --set canary.percentage=10 \
            --set environment=uat \
            --wait --timeout=10m

      - name: Run UAT validation tests
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f tests/k8s/uat-validation.yaml
          kubectl wait --for=condition=complete job/uat-validation -n uat-orch --timeout=600s

      - name: Promote canary to 100%
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade maestro-uat ./helm/maestro \
            --namespace uat-orch \
            --set canary.percentage=100 \
            --wait --timeout=5m

  # Stage 5: Deploy to Production (on release)
  deploy-production:
    name: 'ðŸŒŸ Deploy to Production'
    permissions:
      deployments: write
    needs: [quality-gates, build-sign-sbom]
    if: github.event_name == 'release' && github.event.action == 'published'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: production
      url: https://maestro.intelgraph.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup production deployment
        run: |
          echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Production deployment with blue-green
        run: |
          export KUBECONFIG=kubeconfig
          helm upgrade --install maestro-prod ./helm/maestro \
            --namespace prod-orch \
            --create-namespace \
            --set image.tag=${{ github.event.release.tag_name }} \
            --set environment=production \
            --set blueGreen.enabled=true \
            --wait --timeout=15m

      - name: Run production smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          kubectl apply -f tests/k8s/production-smoke.yaml -n prod-orch
          kubectl wait --for=condition=complete job/prod-smoke-test -n prod-orch --timeout=600s

  # Notification and Cleanup
  notify:
    name: 'ðŸ“¢ Notify & Cleanup'
    permissions:
      deployments: write
    needs:
      [
        quality-gates,
        build-sign-sbom,
        deploy-dev,
        deploy-uat,
        deploy-production,
      ]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#intelgraph-deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: Update GitHub deployment status
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: '${{ job.status }}'
          deployment-id: ${{ github.event.deployment.id }}

  # Security scanning and compliance
  security-compliance:
    name: 'ðŸ”’ Security & Compliance'
    needs: build-sign-sbom
    if: needs.quality-gates.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Run Grype vulnerability scan
        uses: anchore/scan-action@v3
        with:
          image: ${{ needs.build-sign-sbom.outputs.image-tag }}
          fail-build: true
          severity-cutoff: high

      - name: Generate compliance report
        run: |
          echo "# Security Compliance Report" > compliance-report.md
          echo "## Image: ${{ needs.build-sign-sbom.outputs.image-tag }}" >> compliance-report.md
          echo "## Digest: ${{ needs.build-sign-sbom.outputs.image-digest }}" >> compliance-report.md
          echo "## Scan Date: $(date)" >> compliance-report.md
          echo "## Status: âœ… PASSED" >> compliance-report.md

      - name: Upload compliance report
        uses: actions/upload-artifact@v3
        with:
          name: compliance-report
          path: compliance-report.md
