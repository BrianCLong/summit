name: Maestro Conductor vNext - Canary Deployment

permissions:
  contents: read

permissions:
  contents: read

on:
  workflow_dispatch:
    inputs:
      phase:
        description: 'Deployment phase'
        required: true
        type: choice
        options:
          - phase1
          - phase2
          - phase3
          - rollout
        default: phase1

      version:
        description: 'Version to deploy (e.g., v1.2.0-rc.1)'
        required: true
        type: string

      force_deploy:
        description: 'Force deployment even if validations fail'
        required: false
        type: boolean
        default: false

      skip_load_test:
        description: 'Skip load testing phase'
        required: false
        type: boolean
        default: false

      notify_slack:
        description: 'Send Slack notifications'
        required: false
        type: boolean
        default: true

env:
  REGISTRY_URL: ghcr.io
  IMAGE_NAME: maestro-conductor
  KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
  AUTH_TOKEN: ${{ secrets.API_AUTH_TOKEN }}
  TENANT_ID: github-actions-canary

jobs:
  # Pre-deployment validation
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deployment-id: ${{ steps.generate-id.outputs.deployment-id }}
      canary-weight: ${{ steps.phase-config.outputs.canary-weight }}
      expected-duration: ${{ steps.phase-config.outputs.expected-duration }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate deployment ID
        id: generate-id
        run: |
          DEPLOYMENT_ID="canary-$(date +%Y%m%d-%H%M%S)-${{ inputs.phase }}"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "Generated deployment ID: $DEPLOYMENT_ID"

      - name: Get phase configuration
        id: phase-config
        run: |
          case "${{ inputs.phase }}" in
            phase1)
              echo "canary-weight=1" >> $GITHUB_OUTPUT
              echo "expected-duration=48" >> $GITHUB_OUTPUT
              ;;
            phase2)
              echo "canary-weight=5" >> $GITHUB_OUTPUT
              echo "expected-duration=72" >> $GITHUB_OUTPUT
              ;;
            phase3)
              echo "canary-weight=25" >> $GITHUB_OUTPUT
              echo "expected-duration=96" >> $GITHUB_OUTPUT
              ;;
            rollout)
              echo "canary-weight=100" >> $GITHUB_OUTPUT
              echo "expected-duration=168" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Validate version format
        run: |
          if [[ ! "${{ inputs.version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-rc\.[0-9]+)?$ ]]; then
            echo "❌ Invalid version format: ${{ inputs.version }}"
            echo "Expected format: v1.2.3 or v1.2.3-rc.1"
            exit 1
          fi
          echo "✅ Version format valid: ${{ inputs.version }}"

      - name: Check image exists
        run: |
          IMAGE_TAG="${{ inputs.version }}"
          FULL_IMAGE="${REGISTRY_URL}/${{ github.repository }}/${IMAGE_NAME}:${IMAGE_TAG}"

          echo "Checking if image exists: $FULL_IMAGE"

          # Attempt to pull image manifest (without actually pulling)
          if docker manifest inspect "$FULL_IMAGE" >/dev/null 2>&1; then
            echo "✅ Image found: $FULL_IMAGE"
          else
            echo "❌ Image not found: $FULL_IMAGE"
            echo "Available tags:"
            # This would require additional API calls to list available tags
            exit 1
          fi

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config
          kubectl cluster-info

      - name: Validate cluster access
        run: |
          echo "Validating Kubernetes cluster access..."
          kubectl get nodes
          kubectl get namespaces | grep maestro-conductor || true

      - name: Send start notification
        if: inputs.notify_slack
        run: |
          if [[ -n "${{ env.SLACK_WEBHOOK }}" ]]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"🚀 Canary Deployment Started\",
                \"attachments\": [{
                  \"color\": \"#36a64f\",
                  \"fields\": [
                    {\"title\": \"Deployment ID\", \"value\": \"${{ steps.generate-id.outputs.deployment-id }}\", \"short\": true},
                    {\"title\": \"Phase\", \"value\": \"${{ inputs.phase }}\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${{ inputs.version }}\", \"short\": true},
                    {\"title\": \"Canary Weight\", \"value\": \"${{ steps.phase-config.outputs.canary-weight }}%\", \"short\": true},
                    {\"title\": \"Repository\", \"value\": \"${{ github.repository }}\", \"short\": false},
                    {\"title\": \"Workflow\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                  ]
                }]
              }" \
              "${{ env.SLACK_WEBHOOK }}"
          fi

  # Deploy canary
  deploy-canary:
    name: Deploy Canary (${{ inputs.phase }})
    runs-on: ubuntu-latest
    needs: pre-deployment
    outputs:
      deployment-success: ${{ steps.deploy.outputs.success }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl and Helm
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.12.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config

      - name: Execute canary deployment
        id: deploy
        run: |
          echo "Executing canary deployment..."

          # Make deployment script executable
          chmod +x ./scripts/canary-deploy.sh

          # Set deployment parameters
          DEPLOY_ARGS="${{ inputs.phase }} ${{ inputs.version }}"

          if [[ "${{ inputs.force_deploy }}" == "true" ]]; then
            DEPLOY_ARGS+=" --force"
          fi

          if [[ "${{ inputs.notify_slack }}" == "true" && -n "${{ env.SLACK_WEBHOOK }}" ]]; then
            DEPLOY_ARGS+=" --notify ${{ env.SLACK_WEBHOOK }}"
          fi

          # Execute deployment
          if ./scripts/canary-deploy.sh $DEPLOY_ARGS; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "✅ Canary deployment successful"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "❌ Canary deployment failed"
            exit 1
          fi

      - name: Verify deployment
        run: |
          echo "Verifying canary deployment..."

          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod \
            -l "app.kubernetes.io/name=maestro-conductor,version=canary" \
            -n maestro-conductor-canary \
            --timeout=300s

          # Check service health
          CANARY_SERVICE_IP=$(kubectl get service maestro-conductor-canary \
            -n maestro-conductor-canary \
            -o jsonpath='{.spec.clusterIP}')

          echo "Canary service IP: $CANARY_SERVICE_IP"

          # Health check with retry
          for i in {1..10}; do
            if kubectl run temp-health-check-$i --rm -i --restart=Never \
               --image=curlimages/curl -- \
               curl -f "http://${CANARY_SERVICE_IP}:8080/health"; then
              echo "✅ Health check passed"
              break
            else
              echo "Health check attempt $i failed, retrying..."
              sleep 10
            fi

            if [[ $i -eq 10 ]]; then
              echo "❌ Health check failed after 10 attempts"
              exit 1
            fi
          done

  # Traffic management
  configure-traffic:
    name: Configure Traffic Split
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-canary]
    if: needs.deploy-canary.outputs.deployment-success == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config

      - name: Configure traffic split
        run: |
          echo "Configuring traffic split for ${{ inputs.phase }}..."

          # Make traffic manager executable
          chmod +x ./scripts/traffic-manager.sh

          TRAFFIC_ARGS="split ${{ needs.pre-deployment.outputs.canary-weight }}"
          TRAFFIC_ARGS+=" --namespace maestro-conductor-canary"

          if [[ "${{ inputs.notify_slack }}" == "true" && -n "${{ env.SLACK_WEBHOOK }}" ]]; then
            TRAFFIC_ARGS+=" --notify ${{ env.SLACK_WEBHOOK }}"
          fi

          # Execute traffic configuration
          ./scripts/traffic-manager.sh $TRAFFIC_ARGS

          echo "✅ Traffic split configured: ${{ needs.pre-deployment.outputs.canary-weight }}% canary"

      - name: Validate traffic routing
        run: |
          echo "Validating traffic routing configuration..."

          # Validate using traffic manager
          ./scripts/traffic-manager.sh validate --namespace maestro-conductor-canary

          # Show current status
          ./scripts/traffic-manager.sh status --namespace maestro-conductor-canary

  # Load testing
  load-testing:
    name: Execute Load Testing
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-canary, configure-traffic]
    if: needs.deploy-canary.outputs.deployment-success == 'true' && !inputs.skip_load_test

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Artillery
        run: |
          npm install -g artillery@latest
          artillery --version

      - name: Execute load testing
        run: |
          echo "Starting load testing for ${{ inputs.phase }}..."

          # Make load test script executable
          chmod +x ./scripts/canary-load-test.sh

          # Configure load test parameters
          LOAD_TEST_ARGS="${{ inputs.phase }}"
          LOAD_TEST_ARGS+=" --base-url https://api.maestro-conductor.com"
          LOAD_TEST_ARGS+=" --auth-token ${{ env.AUTH_TOKEN }}"
          LOAD_TEST_ARGS+=" --tenant-id ${{ env.TENANT_ID }}"
          LOAD_TEST_ARGS+=" --save-results"
          LOAD_TEST_ARGS+=" --real-time-metrics"

          if [[ "${{ inputs.notify_slack }}" == "true" && -n "${{ env.SLACK_WEBHOOK }}" ]]; then
            LOAD_TEST_ARGS+=" --slack-webhook ${{ env.SLACK_WEBHOOK }}"
          fi

          # Execute load testing
          ./scripts/canary-load-test.sh $LOAD_TEST_ARGS

      - name: Upload load test results
        uses: actions/upload-artifact@v4
        with:
          name: load-test-results-${{ needs.pre-deployment.outputs.deployment-id }}
          path: /tmp/canary-load-test-results/
          retention-days: 30

  # Post-deployment validation
  post-deployment:
    name: Post-deployment Validation
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-canary, configure-traffic]
    if: always() && needs.deploy-canary.outputs.deployment-success == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config

      - name: Execute rollback validation
        run: |
          echo "Executing post-deployment validation..."

          # Make validation script executable
          chmod +x ./scripts/validate-rollback.sh

          # Run comprehensive validation
          ./scripts/validate-rollback.sh \
            --verify-service-health \
            --check-data-integrity \
            --confirm-customer-access \
            --namespace maestro-conductor-canary \
            --detailed

      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."

          REPORT_FILE="/tmp/deployment-report-${{ needs.pre-deployment.outputs.deployment-id }}.md"

          cat > "$REPORT_FILE" << EOF
          # Canary Deployment Report

          **Deployment ID:** ${{ needs.pre-deployment.outputs.deployment-id }}
          **Phase:** ${{ inputs.phase }}
          **Version:** ${{ inputs.version }}
          **Canary Weight:** ${{ needs.pre-deployment.outputs.canary-weight }}%
          **Expected Duration:** ${{ needs.pre-deployment.outputs.expected-duration }} hours
          **Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          ## Deployment Status

          - ✅ Pre-deployment validation passed
          - ✅ Canary deployment successful
          - ✅ Traffic routing configured
          - ${{ !inputs.skip_load_test && '✅ Load testing completed' || '⏭️ Load testing skipped' }}
          - ✅ Post-deployment validation passed

          ## Next Steps

          1. Monitor canary deployment for ${{ needs.pre-deployment.outputs.expected-duration }} hours
          2. Review metrics and alerts in Grafana dashboard
          3. Collect customer feedback
          4. Proceed to next phase or rollback if issues detected

          ## Monitoring Links

          - [Grafana Dashboard](https://grafana.maestro-conductor.com/d/canary-deployment)
          - [Prometheus Alerts](https://prometheus.maestro-conductor.com/alerts)
          - [GitHub Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          EOF

          echo "Deployment report generated: $REPORT_FILE"
          cat "$REPORT_FILE"

      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report-${{ needs.pre-deployment.outputs.deployment-id }}
          path: /tmp/deployment-report-*.md
          retention-days: 90

  # Final notification
  notify-completion:
    name: Send Completion Notification
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-canary, configure-traffic, load-testing, post-deployment]
    if: always() && inputs.notify_slack

    steps:
      - name: Determine overall status
        id: status
        run: |
          if [[ "${{ needs.deploy-canary.result }}" == "success" && \
                "${{ needs.configure-traffic.result }}" == "success" && \
                ("${{ needs.load-testing.result }}" == "success" || "${{ needs.load-testing.result }}" == "skipped") && \
                ("${{ needs.post-deployment.result }}" == "success" || "${{ needs.post-deployment.result }}" == "skipped") ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "color=#36a64f" >> $GITHUB_OUTPUT
            echo "icon=✅" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "color=#ff0000" >> $GITHUB_OUTPUT
            echo "icon=❌" >> $GITHUB_OUTPUT
          fi

      - name: Send completion notification
        if: env.SLACK_WEBHOOK
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"${{ steps.status.outputs.icon }} Canary Deployment Completed\",
              \"attachments\": [{
                \"color\": \"${{ steps.status.outputs.color }}\",
                \"fields\": [
                  {\"title\": \"Status\", \"value\": \"${{ steps.status.outputs.status }}\", \"short\": true},
                  {\"title\": \"Deployment ID\", \"value\": \"${{ needs.pre-deployment.outputs.deployment-id }}\", \"short\": true},
                  {\"title\": \"Phase\", \"value\": \"${{ inputs.phase }}\", \"short\": true},
                  {\"title\": \"Version\", \"value\": \"${{ inputs.version }}\", \"short\": true},
                  {\"title\": \"Canary Weight\", \"value\": \"${{ needs.pre-deployment.outputs.canary-weight }}%\", \"short\": true},
                  {\"title\": \"Monitor Duration\", \"value\": \"${{ needs.pre-deployment.outputs.expected-duration }} hours\", \"short\": true},
                  {\"title\": \"Deploy Result\", \"value\": \"${{ needs.deploy-canary.result }}\", \"short\": true},
                  {\"title\": \"Traffic Result\", \"value\": \"${{ needs.configure-traffic.result }}\", \"short\": true},
                  {\"title\": \"Load Test Result\", \"value\": \"${{ needs.load-testing.result }}\", \"short\": true},
                  {\"title\": \"Validation Result\", \"value\": \"${{ needs.post-deployment.result }}\", \"short\": true},
                  {\"title\": \"Workflow\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                ]
              }]
            }" \
            "${{ env.SLACK_WEBHOOK }}"

  # Emergency rollback trigger (manual)
  emergency-rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && !inputs.force_deploy
    needs: [pre-deployment, deploy-canary]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config

      - name: Execute emergency rollback
        run: |
          echo "Executing emergency rollback due to deployment failure..."

          # Make rollback script executable
          chmod +x ./scripts/emergency-rollback.sh

          # Determine stable version (this would need to be configured)
          STABLE_VERSION=$(kubectl get deployment maestro-conductor-stable \
            -n maestro-conductor \
            -o jsonpath='{.spec.template.spec.containers[0].image}' | \
            cut -d: -f2)

          ROLLBACK_REASON="Automated rollback due to canary deployment failure"

          ./scripts/emergency-rollback.sh \
            --version "$STABLE_VERSION" \
            --reason "$ROLLBACK_REASON" \
            --notify "${{ env.SLACK_WEBHOOK }}"

      - name: Send rollback notification
        if: env.SLACK_WEBHOOK
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"🚨 Emergency Rollback Executed\",
              \"attachments\": [{
                \"color\": \"#ff6b35\",
                \"fields\": [
                  {\"title\": \"Reason\", \"value\": \"Canary deployment failure\", \"short\": false},
                  {\"title\": \"Failed Deployment\", \"value\": \"${{ needs.pre-deployment.outputs.deployment-id }}\", \"short\": true},
                  {\"title\": \"Failed Version\", \"value\": \"${{ inputs.version }}\", \"short\": true},
                  {\"title\": \"Workflow\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                ]
              }]
            }" \
            "${{ env.SLACK_WEBHOOK }}"