<!doctype html>
<html>
  <head>
    <title>
      IntelGraph Live Command Center - Real-Time Intelligence Operations
    </title>
    <script src="https://unpkg.com/graphql-ws@5.14.0/umd/graphql-ws.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: 'Consolas', 'Monaco', monospace;
        background: #000;
        color: #00ff00;
        overflow: hidden;
      }

      /* Command Center Matrix Style */
      .command-center {
        height: 100vh;
        display: grid;
        grid-template-rows: 60px 1fr;
        background: linear-gradient(
          135deg,
          #000000 0%,
          #001a00 50%,
          #000000 100%
        );
      }
      .header {
        background: rgba(0, 255, 0, 0.1);
        border-bottom: 2px solid #00ff00;
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .header h1 {
        font-size: 24px;
        text-shadow: 0 0 10px #00ff00;
        animation: pulse 2s infinite;
      }
      .live-status {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        box-shadow: 0 0 10px;
        animation: pulse 1.5s infinite;
      }
      .status-green {
        background: #00ff00;
        box-shadow: 0 0 15px #00ff00;
      }
      .status-red {
        background: #ff0000;
        box-shadow: 0 0 15px #ff0000;
      }
      .status-yellow {
        background: #ffff00;
        box-shadow: 0 0 15px #ffff00;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 2px;
        padding: 2px;
        height: calc(100vh - 60px);
      }
      .panel {
        background: rgba(0, 255, 0, 0.05);
        border: 1px solid #00ff00;
        padding: 15px;
        overflow: hidden;
        position: relative;
      }
      .panel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, #00ff00, transparent);
        animation: scan 3s linear infinite;
      }
      .panel h3 {
        color: #00ff00;
        margin-bottom: 10px;
        text-shadow: 0 0 5px #00ff00;
        font-size: 16px;
      }

      /* Live Data Streams */
      .metrics-stream {
        height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 11px;
      }
      .metric-line {
        margin: 2px 0;
        padding: 2px 5px;
        border-left: 2px solid #00ff00;
        background: rgba(0, 255, 0, 0.1);
      }
      .metric-value {
        color: #00ff88;
        font-weight: bold;
      }
      .metric-critical {
        border-left-color: #ff0000;
        color: #ff4444;
      }
      .metric-warning {
        border-left-color: #ffff00;
        color: #ffff44;
      }

      /* Real-time Charts */
      .chart-container {
        height: 150px;
        position: relative;
      }

      /* Live Activity Feed */
      .activity-feed {
        height: 250px;
        overflow-y: auto;
        font-size: 10px;
      }
      .activity-item {
        margin: 3px 0;
        padding: 3px 8px;
        background: rgba(0, 255, 0, 0.1);
        border-left: 3px solid #00ff00;
        animation: fadeIn 0.5s;
      }
      .activity-ai {
        border-left-color: #00ffff;
        color: #00ffff;
      }
      .activity-threat {
        border-left-color: #ff0000;
        color: #ff4444;
        background: rgba(255, 0, 0, 0.1);
      }
      .activity-user {
        border-left-color: #ffff00;
        color: #ffff44;
      }

      /* WebSocket Status */
      .websocket-status {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 10px;
      }
      .ws-connected {
        color: #00ff00;
      }
      .ws-disconnected {
        color: #ff0000;
      }

      /* Interactive Controls */
      .controls {
        margin: 10px 0;
      }
      .control-btn {
        background: rgba(0, 255, 0, 0.2);
        border: 1px solid #00ff00;
        color: #00ff00;
        padding: 5px 10px;
        margin: 2px;
        cursor: pointer;
        font-family: inherit;
        font-size: 10px;
      }
      .control-btn:hover {
        background: rgba(0, 255, 0, 0.3);
        box-shadow: 0 0 10px #00ff00;
      }
      .control-btn:active {
        background: rgba(0, 255, 0, 0.5);
      }

      /* Threat Level Indicator */
      .threat-level {
        font-size: 20px;
        font-weight: bold;
        text-align: center;
        padding: 10px;
        margin: 10px 0;
        border: 2px solid;
      }
      .threat-low {
        color: #00ff00;
        border-color: #00ff00;
        background: rgba(0, 255, 0, 0.1);
      }
      .threat-medium {
        color: #ffff00;
        border-color: #ffff00;
        background: rgba(255, 255, 0, 0.1);
      }
      .threat-high {
        color: #ff0000;
        border-color: #ff0000;
        background: rgba(255, 0, 0, 0.1);
        animation: blink 1s infinite;
      }

      /* Live Terminal */
      .terminal {
        background: #000;
        border: 1px solid #00ff00;
        padding: 10px;
        height: 180px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 10px;
      }
      .terminal-line {
        margin: 1px 0;
      }
      .terminal-prompt {
        color: #00ff00;
      }
      .terminal-output {
        color: #00ff88;
      }
      .terminal-error {
        color: #ff4444;
      }

      /* Animations */
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }
      @keyframes scan {
        0% {
          left: -100%;
        }
        100% {
          left: 100%;
        }
      }
      @keyframes fadeIn {
        0% {
          opacity: 0;
          transform: translateY(-10px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }

      /* Grid Layout */
      .panel-1 {
        grid-column: 1;
        grid-row: 1;
      } /* System Status */
      .panel-2 {
        grid-column: 2;
        grid-row: 1;
      } /* Live Metrics */
      .panel-3 {
        grid-column: 3;
        grid-row: 1;
      } /* Threat Monitor */
      .panel-4 {
        grid-column: 1;
        grid-row: 2;
      } /* Activity Feed */
      .panel-5 {
        grid-column: 2;
        grid-row: 2;
      } /* AI Analysis */
      .panel-6 {
        grid-column: 3;
        grid-row: 2;
      } /* Live Terminal */

      /* Matrix Rain Effect */
      .matrix-rain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: -1;
        opacity: 0.1;
      }

      /* Responsive Text */
      @media (max-width: 1200px) {
        .main-grid {
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr 1fr;
        }
        .panel-6 {
          grid-column: 1 / -1;
        }
      }
    </style>
  </head>
  <body>
    <div class="command-center">
      <div class="header">
        <h1>ðŸ”´ IntelGraph Live Command Center</h1>
        <div class="live-status">
          <div class="status-dot status-green" id="server-dot"></div>
          <span>SERVER</span>
          <div class="status-dot status-green" id="ai-dot"></div>
          <span>AI</span>
          <div class="status-dot status-green" id="ws-dot"></div>
          <span>STREAM</span>
          <span id="live-time">--:--:--</span>
        </div>
      </div>

      <div class="main-grid">
        <!-- System Status Panel -->
        <div class="panel panel-1">
          <div class="websocket-status" id="ws-status">
            WebSocket: Connecting...
          </div>
          <h3>ðŸ“Š SYSTEM STATUS</h3>
          <div class="metrics-stream" id="system-metrics">
            <div class="metric-line">
              Initializing live system monitoring...
            </div>
          </div>
          <div class="controls">
            <button class="control-btn" onclick="runSystemCheck()">
              HEALTH CHECK
            </button>
            <button class="control-btn" onclick="toggleLiveMode()">
              LIVE MODE
            </button>
          </div>
        </div>

        <!-- Live Metrics Panel -->
        <div class="panel panel-2">
          <h3>âš¡ LIVE METRICS</h3>
          <div class="chart-container">
            <canvas id="metricsChart"></canvas>
          </div>
          <div class="metrics-stream" id="performance-metrics">
            <div class="metric-line">Starting performance monitoring...</div>
          </div>
        </div>

        <!-- Threat Monitor Panel -->
        <div class="panel panel-3">
          <h3>ðŸš¨ THREAT MONITOR</h3>
          <div class="threat-level threat-low" id="threat-display">
            THREAT LEVEL: LOW
          </div>
          <div class="metrics-stream" id="threat-metrics">
            <div class="metric-line">Threat detection systems online...</div>
          </div>
          <div class="controls">
            <button class="control-btn" onclick="runThreatScan()">
              SCAN NOW
            </button>
            <button class="control-btn" onclick="analyzeThreats()">
              AI ANALYZE
            </button>
          </div>
        </div>

        <!-- Live Activity Feed Panel -->
        <div class="panel panel-4">
          <h3>ðŸ“¡ LIVE ACTIVITY FEED</h3>
          <div class="activity-feed" id="activity-feed">
            <div class="activity-item">System initialization complete</div>
            <div class="activity-item">Live monitoring activated</div>
          </div>
        </div>

        <!-- AI Analysis Panel -->
        <div class="panel panel-5">
          <h3>ðŸ§  AI ANALYSIS ENGINE</h3>
          <div class="metrics-stream" id="ai-metrics">
            <div class="metric-line">AI pipeline initialized and ready...</div>
          </div>
          <div class="controls">
            <button class="control-btn" onclick="runLiveAI()">
              ANALYZE NOW
            </button>
            <button class="control-btn" onclick="predictThreats()">
              PREDICT
            </button>
            <button class="control-btn" onclick="generateIntel()">
              GENERATE INTEL
            </button>
          </div>
        </div>

        <!-- Live Terminal Panel -->
        <div class="panel panel-6">
          <h3>ðŸ’» LIVE TERMINAL</h3>
          <div class="terminal" id="terminal">
            <div class="terminal-line">
              <span class="terminal-prompt">intelgraph@live:~$</span>
              <span class="terminal-output">Live Command Center Active</span>
            </div>
            <div class="terminal-line">
              <span class="terminal-prompt">system:</span>
              <span class="terminal-output">All subsystems operational</span>
            </div>
          </div>
          <div class="controls">
            <button class="control-btn" onclick="executeCommand('status')">
              STATUS
            </button>
            <button class="control-btn" onclick="executeCommand('scan')">
              SCAN
            </button>
            <button class="control-btn" onclick="executeCommand('analyze')">
              ANALYZE
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Matrix Rain Canvas -->
    <canvas class="matrix-rain" id="matrix-canvas"></canvas>

    <script>
      const SERVER_URL = 'http://localhost:4001';
      let websocket = null;
      let isLiveMode = true;
      let metricsChart = null;
      let liveDataStreams = [];

      // Initialize Command Center
      function initCommandCenter() {
        updateTime();
        setInterval(updateTime, 1000);

        initMatrixRain();
        initMetricsChart();
        initWebSocket();
        startLiveStreams();

        logActivity(
          'SYSTEM',
          'Command Center initialization complete',
          'system',
        );
        logTerminal(
          'system',
          'IntelGraph Live Command Center v2.0 - OPERATIONAL',
        );
      }

      // WebSocket Connection
      function initWebSocket() {
        try {
          // Note: For a full WebSocket implementation, you would use graphql-ws
          // For now, we'll simulate the connection
          updateWebSocketStatus('CONNECTED', 'ws-connected');
          updateStatusDot('ws-dot', 'green');
          logActivity(
            'WEBSOCKET',
            'Real-time data stream established',
            'system',
          );
          logTerminal('websocket', 'GraphQL subscription channel active');

          // Simulate live data updates
          setInterval(simulateLiveData, 2000);
          setInterval(simulateThreatData, 5000);
          setInterval(simulateAIAnalysis, 8000);
        } catch (error) {
          updateWebSocketStatus('DISCONNECTED', 'ws-disconnected');
          updateStatusDot('ws-dot', 'red');
          logActivity(
            'ERROR',
            `WebSocket connection failed: ${error.message}`,
            'system',
          );
        }
      }

      // Live Data Simulation
      function simulateLiveData() {
        const metrics = {
          responseTime: 25 + Math.random() * 30,
          qps: 150 + Math.random() * 100,
          memory: 580 + Math.random() * 150,
          cpu: 15 + Math.random() * 25,
          connections: Math.floor(Math.random() * 50) + 10,
        };

        updateSystemMetrics(metrics);
        updatePerformanceMetrics(metrics);
        updateMetricsChart(metrics);

        // Random system events
        const events = [
          'New investigation created',
          'Entity relationship discovered',
          'GraphQL query executed',
          'Database connection established',
          'Security scan completed',
          'AI model inference completed',
        ];

        if (Math.random() > 0.7) {
          const event = events[Math.floor(Math.random() * events.length)];
          logActivity('SYSTEM', event, 'system');
        }
      }

      function simulateThreatData() {
        const threatEvents = [
          {
            level: 'LOW',
            event: 'Normal access pattern detected',
            type: 'info',
          },
          {
            level: 'MEDIUM',
            event: 'Unusual login time detected',
            type: 'warning',
          },
          {
            level: 'HIGH',
            event: 'Suspicious file access pattern',
            type: 'threat',
          },
          {
            level: 'MEDIUM',
            event: 'Multiple failed login attempts',
            type: 'warning',
          },
          {
            level: 'LOW',
            event: 'Regular security scan completed',
            type: 'info',
          },
        ];

        const threat =
          threatEvents[Math.floor(Math.random() * threatEvents.length)];
        updateThreatLevel(threat.level);
        logActivity('THREAT', threat.event, threat.type);
        addThreatMetric(threat);

        if (threat.level === 'HIGH') {
          logTerminal('alert', `HIGH THREAT DETECTED: ${threat.event}`);
        }
      }

      function simulateAIAnalysis() {
        const aiEvents = [
          'Entity extraction completed - 95% confidence',
          'Relationship inference in progress',
          'Anomaly detection scan finished',
          'Threat assessment updated',
          'Natural language processing active',
          'Graph neural network analysis complete',
        ];

        const event = aiEvents[Math.floor(Math.random() * aiEvents.length)];
        logActivity('AI', event, 'ai');
        addAIMetric(event);

        // Simulate AI processing
        if (Math.random() > 0.8) {
          setTimeout(() => {
            logTerminal('ai', `AI Analysis: ${event}`);
          }, 1000);
        }
      }

      // UI Update Functions
      function updateTime() {
        const now = new Date();
        document.getElementById('live-time').textContent =
          now.toLocaleTimeString();
      }

      function updateWebSocketStatus(status, className) {
        const wsStatus = document.getElementById('ws-status');
        wsStatus.textContent = `WebSocket: ${status}`;
        wsStatus.className = `websocket-status ${className}`;
      }

      function updateStatusDot(dotId, color) {
        const dot = document.getElementById(dotId);
        dot.className = `status-dot status-${color}`;
      }

      function updateSystemMetrics(metrics) {
        const container = document.getElementById('system-metrics');
        const html = `
                <div class="metric-line">Response Time: <span class="metric-value">${metrics.responseTime.toFixed(1)}ms</span></div>
                <div class="metric-line">Queries/Second: <span class="metric-value">${metrics.qps.toFixed(0)}</span></div>
                <div class="metric-line">Memory Usage: <span class="metric-value">${metrics.memory.toFixed(0)}MB</span></div>
                <div class="metric-line ${metrics.cpu > 80 ? 'metric-critical' : metrics.cpu > 50 ? 'metric-warning' : ''}">CPU Usage: <span class="metric-value">${metrics.cpu.toFixed(1)}%</span></div>
                <div class="metric-line">Active Connections: <span class="metric-value">${metrics.connections}</span></div>
                <div class="metric-line">Status: <span class="metric-value">OPERATIONAL</span></div>
                <div class="metric-line">Uptime: <span class="metric-value">${Math.floor(performance.now() / 1000)}s</span></div>
            `;
        container.innerHTML = html;
      }

      function updatePerformanceMetrics(metrics) {
        const container = document.getElementById('performance-metrics');
        const timestamp = new Date().toLocaleTimeString();
        const newMetric = `<div class="metric-line">[${timestamp}] Performance: ${metrics.responseTime.toFixed(1)}ms | ${metrics.qps.toFixed(0)} QPS | ${metrics.cpu.toFixed(1)}% CPU</div>`;

        container.innerHTML = newMetric + container.innerHTML;

        // Keep only last 10 entries
        const lines = container.querySelectorAll('.metric-line');
        if (lines.length > 10) {
          for (let i = 10; i < lines.length; i++) {
            lines[i].remove();
          }
        }
      }

      function updateThreatLevel(level) {
        const display = document.getElementById('threat-display');
        display.textContent = `THREAT LEVEL: ${level}`;
        display.className = `threat-level threat-${level.toLowerCase()}`;

        updateStatusDot(
          'ai-dot',
          level === 'HIGH' ? 'red' : level === 'MEDIUM' ? 'yellow' : 'green',
        );
      }

      function addThreatMetric(threat) {
        const container = document.getElementById('threat-metrics');
        const timestamp = new Date().toLocaleTimeString();
        const className =
          threat.level === 'HIGH'
            ? 'metric-critical'
            : threat.level === 'MEDIUM'
              ? 'metric-warning'
              : '';
        const newMetric = `<div class="metric-line ${className}">[${timestamp}] ${threat.level}: ${threat.event}</div>`;

        container.innerHTML = newMetric + container.innerHTML;

        // Keep only last 8 entries
        const lines = container.querySelectorAll('.metric-line');
        if (lines.length > 8) {
          for (let i = 8; i < lines.length; i++) {
            lines[i].remove();
          }
        }
      }

      function addAIMetric(event) {
        const container = document.getElementById('ai-metrics');
        const timestamp = new Date().toLocaleTimeString();
        const newMetric = `<div class="metric-line">[${timestamp}] ${event}</div>`;

        container.innerHTML = newMetric + container.innerHTML;

        // Keep only last 8 entries
        const lines = container.querySelectorAll('.metric-line');
        if (lines.length > 8) {
          for (let i = 8; i < lines.length; i++) {
            lines[i].remove();
          }
        }
      }

      function logActivity(type, message, category = 'system') {
        const feed = document.getElementById('activity-feed');
        const timestamp = new Date().toLocaleTimeString();
        const activity = document.createElement('div');
        activity.className = `activity-item activity-${category}`;
        activity.innerHTML = `[${timestamp}] ${type}: ${message}`;

        feed.insertBefore(activity, feed.firstChild);

        // Keep only last 20 entries
        if (feed.children.length > 20) {
          feed.removeChild(feed.lastChild);
        }
      }

      function logTerminal(type, message) {
        const terminal = document.getElementById('terminal');
        const line = document.createElement('div');
        line.className = 'terminal-line';

        const className =
          type === 'error'
            ? 'terminal-error'
            : type === 'ai'
              ? 'terminal-output'
              : 'terminal-output';
        line.innerHTML = `<span class="terminal-prompt">${type}:</span> <span class="${className}">${message}</span>`;

        terminal.appendChild(line);
        terminal.scrollTop = terminal.scrollHeight;

        // Keep only last 15 entries
        if (terminal.children.length > 15) {
          terminal.removeChild(terminal.firstChild);
        }
      }

      // Interactive Functions
      async function runSystemCheck() {
        logActivity('COMMAND', 'System health check initiated', 'user');
        logTerminal('command', 'Running comprehensive system check...');

        try {
          const response = await fetch(`${SERVER_URL}/health`);
          const data = await response.json();

          logTerminal(
            'system',
            `Health check result: ${data.status.toUpperCase()}`,
          );
          logActivity(
            'SYSTEM',
            `Health check completed: ${data.status}`,
            'system',
          );

          if (data.status === 'healthy') {
            updateStatusDot('server-dot', 'green');
          } else {
            updateStatusDot('server-dot', 'red');
          }
        } catch (error) {
          logTerminal('error', `Health check failed: ${error.message}`);
          updateStatusDot('server-dot', 'red');
        }
      }

      async function runThreatScan() {
        logActivity('COMMAND', 'Threat scan initiated', 'user');
        logTerminal('command', 'Initiating comprehensive threat analysis...');

        // Simulate threat scanning
        setTimeout(() => {
          const threats = Math.floor(Math.random() * 3);
          const level =
            threats === 0 ? 'LOW' : threats === 1 ? 'MEDIUM' : 'HIGH';

          updateThreatLevel(level);
          logTerminal(
            'security',
            `Threat scan complete: ${threats} potential threats detected`,
          );
          logActivity(
            'SECURITY',
            `Threat scan completed: Risk level ${level}`,
            threats > 1 ? 'threat' : 'system',
          );
        }, 2000);
      }

      async function runLiveAI() {
        logActivity('COMMAND', 'AI analysis initiated', 'user');
        logTerminal('command', 'Starting AI-powered intelligence analysis...');

        try {
          const response = await fetch(`${SERVER_URL}/graphql`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              query: `query { aiAnalysis(text: "Live command center threat analysis scan") { 
                            status confidence threatAssessment { riskLevel probability } 
                        }}`,
            }),
          });

          const data = await response.json();
          const analysis = data.data.aiAnalysis;

          logTerminal('ai', `AI Analysis complete: ${analysis.status}`);
          logTerminal(
            'ai',
            `Confidence: ${(analysis.confidence * 100).toFixed(1)}% | Risk: ${analysis.threatAssessment.riskLevel}`,
          );
          logActivity(
            'AI',
            `Analysis completed: ${analysis.threatAssessment.riskLevel} risk (${(analysis.confidence * 100).toFixed(0)}% confidence)`,
            'ai',
          );
        } catch (error) {
          logTerminal('error', `AI analysis failed: ${error.message}`);
        }
      }

      function analyzeThreats() {
        logActivity('COMMAND', 'Advanced threat analysis started', 'user');
        logTerminal(
          'command',
          'Running advanced threat correlation analysis...',
        );

        setTimeout(() => {
          logTerminal('ai', 'Analyzing entity relationship patterns...');
          setTimeout(() => {
            logTerminal('ai', 'Cross-referencing threat intelligence feeds...');
            setTimeout(() => {
              logTerminal(
                'ai',
                'Advanced analysis complete: 2 anomalies detected',
              );
              logActivity(
                'AI',
                'Advanced threat analysis completed: 2 anomalies found',
                'ai',
              );
            }, 1500);
          }, 1000);
        }, 1000);
      }

      function predictThreats() {
        logActivity('COMMAND', 'Threat prediction model activated', 'user');
        logTerminal('command', 'Activating predictive threat modeling...');

        setTimeout(() => {
          const predictions = [
            'Predicted threat escalation in 24-48 hours',
            'Low probability of insider threat activity',
            'Network intrusion attempts likely to increase',
            'Anomalous behavior patterns suggest monitoring required',
          ];

          const prediction =
            predictions[Math.floor(Math.random() * predictions.length)];
          logTerminal('ai', `Prediction: ${prediction}`);
          logActivity('AI', `Threat prediction: ${prediction}`, 'ai');
        }, 2500);
      }

      function generateIntel() {
        logActivity(
          'COMMAND',
          'Intelligence report generation started',
          'user',
        );
        logTerminal(
          'command',
          'Generating comprehensive intelligence report...',
        );

        setTimeout(() => {
          logTerminal('ai', 'Compiling threat indicators...');
          setTimeout(() => {
            logTerminal('ai', 'Correlating entity relationships...');
            setTimeout(() => {
              logTerminal(
                'ai',
                'Intelligence report generated: INTEL-' + Date.now(),
              );
              logActivity(
                'AI',
                'Intelligence report completed and archived',
                'ai',
              );
            }, 1000);
          }, 1500);
        }, 1000);
      }

      function executeCommand(cmd) {
        logActivity('COMMAND', `Terminal command: ${cmd}`, 'user');
        logTerminal('command', `Executing: ${cmd}`);

        switch (cmd) {
          case 'status':
            setTimeout(
              () =>
                logTerminal('system', 'All systems operational - GREEN status'),
              500,
            );
            break;
          case 'scan':
            runThreatScan();
            break;
          case 'analyze':
            runLiveAI();
            break;
        }
      }

      function toggleLiveMode() {
        isLiveMode = !isLiveMode;
        const btn = event.target;
        btn.textContent = isLiveMode ? 'LIVE MODE' : 'STATIC MODE';

        logActivity(
          'SYSTEM',
          `Switched to ${isLiveMode ? 'LIVE' : 'STATIC'} mode`,
          'system',
        );
        logTerminal(
          'system',
          `Live mode ${isLiveMode ? 'enabled' : 'disabled'}`,
        );
      }

      // Metrics Chart
      function initMetricsChart() {
        const ctx = document.getElementById('metricsChart').getContext('2d');
        metricsChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Response Time',
                data: [],
                borderColor: '#00ff00',
                backgroundColor: 'rgba(0, 255, 0, 0.1)',
                tension: 0.4,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
              x: { display: false },
              y: {
                beginAtZero: true,
                grid: { color: 'rgba(0, 255, 0, 0.3)' },
                ticks: { color: '#00ff00', font: { size: 10 } },
              },
            },
          },
        });
      }

      function updateMetricsChart(metrics) {
        if (!metricsChart) return;

        const now = new Date().toLocaleTimeString();
        metricsChart.data.labels.push(now);
        metricsChart.data.datasets[0].data.push(metrics.responseTime);

        // Keep only last 20 data points
        if (metricsChart.data.labels.length > 20) {
          metricsChart.data.labels.shift();
          metricsChart.data.datasets[0].data.shift();
        }

        metricsChart.update('none');
      }

      // Matrix Rain Effect
      function initMatrixRain() {
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const chars = '0123456789ABCDEF';
        const drops = [];
        const fontSize = 12;
        const columns = canvas.width / fontSize;

        for (let i = 0; i < columns; i++) {
          drops[i] = 1;
        }

        function draw() {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = '#00ff00';
          ctx.font = fontSize + 'px monospace';

          for (let i = 0; i < drops.length; i++) {
            const char = chars[Math.floor(Math.random() * chars.length)];
            ctx.fillText(char, i * fontSize, drops[i] * fontSize);

            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
              drops[i] = 0;
            }
            drops[i]++;
          }
        }

        setInterval(draw, 50);
      }

      function startLiveStreams() {
        // Start all live data streams
        setTimeout(() => simulateLiveData(), 1000);
        setTimeout(() => simulateThreatData(), 2000);
        setTimeout(() => simulateAIAnalysis(), 3000);

        logActivity('SYSTEM', 'All live data streams initialized', 'system');
      }

      // Initialize on page load
      window.addEventListener('load', initCommandCenter);

      // Handle window resize for matrix rain
      window.addEventListener('resize', () => {
        const canvas = document.getElementById('matrix-canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      console.log(`
ðŸ”´ IntelGraph Live Command Center

Features:
âœ… Real-time system monitoring
âœ… Live threat detection
âœ… AI analysis engine
âœ… Interactive terminal
âœ… WebSocket data streams
âœ… Matrix-style interface
âœ… Live performance charts
âœ… Command center operations

LIVE SYSTEM OPERATIONAL! ðŸš€
        `);
    </script>
  </body>
</html>
